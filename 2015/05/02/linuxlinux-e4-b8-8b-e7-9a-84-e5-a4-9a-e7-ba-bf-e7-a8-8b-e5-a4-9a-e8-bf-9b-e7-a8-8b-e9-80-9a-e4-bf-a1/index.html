<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++,linux,多线程通讯," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="进程（fork）   什么是一个进程？进程这个概念是针对系统而不是针对用户的，对用户来说，他面对的概念是程序。当用户敲入命令执行一个程序的时候，对系统而言，它将启动一个进程。但和程序不同的是，在这个进程中，系统可能需要再启动一个或多个进程来完成独立的多个任务。多进程编程的主要内容包括进程控制和进程间通信，在了解这些之前，我们先要简单知道进程的结构。  1-2.  Linux下进程的结构Linux">
<meta name="keywords" content="C++,linux,多线程通讯">
<meta property="og:type" content="article">
<meta property="og:title" content="[linux]Linux下的多线程多进程通信">
<meta property="og:url" content="https://kidozh.github.io/2015/05/02/linuxlinux-e4-b8-8b-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-9a-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1/index.html">
<meta property="og:site_name" content="kidozh">
<meta property="og:description" content="进程（fork）   什么是一个进程？进程这个概念是针对系统而不是针对用户的，对用户来说，他面对的概念是程序。当用户敲入命令执行一个程序的时候，对系统而言，它将启动一个进程。但和程序不同的是，在这个进程中，系统可能需要再启动一个或多个进程来完成独立的多个任务。多进程编程的主要内容包括进程控制和进程间通信，在了解这些之前，我们先要简单知道进程的结构。  1-2.  Linux下进程的结构Linux">
<meta property="og:updated_time" content="2018-05-21T05:56:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[linux]Linux下的多线程多进程通信">
<meta name="twitter:description" content="进程（fork）   什么是一个进程？进程这个概念是针对系统而不是针对用户的，对用户来说，他面对的概念是程序。当用户敲入命令执行一个程序的时候，对系统而言，它将启动一个进程。但和程序不同的是，在这个进程中，系统可能需要再启动一个或多个进程来完成独立的多个任务。多进程编程的主要内容包括进程控制和进程间通信，在了解这些之前，我们先要简单知道进程的结构。  1-2.  Linux下进程的结构Linux">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kidozh.github.io/2015/05/02/linuxlinux-e4-b8-8b-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-9a-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1/"/>





  <title>[linux]Linux下的多线程多进程通信 | kidozh</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kidozh</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">某不科学的kidozh</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/05/02/linuxlinux-e4-b8-8b-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-9a-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/11661760?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">[linux]Linux下的多线程多进程通信</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-02T17:33:40+08:00">
                2015-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li>进程（fork）</li>
</ol>
<ol>
<li>什么是一个进程？进程这个概念是针对系统而不是针对用户的，对用户来说，他面对的概念是程序。当用户敲入命令执行一个程序的时候，对系统而言，它将启动一个进程。但和程序不同的是，在这个进程中，系统可能需要再启动一个或多个进程来完成独立的多个任务。多进程编程的主要内容包括进程控制和进程间通信，在了解这些之前，我们先要简单知道进程的结构。</li>
</ol>
<p>1-2.  Linux下进程的结构<br>Linux下一个进程在内存里有三部分的数据，就是”代码段”、”堆栈段”和”数据段”。其实学过汇编语言的人一定知道，一般的CPU都有上述三种段寄存器，以方便操作系统的运行。这三个部分也是构成一个完整的执行序列的必要的部分。<br>“代码段”，顾名思义，就是存放了程序代码的数据，假如机器中有数个进程运行相同的一个程序，那么它们就可以使用相同的代码段。”堆栈段”存放的就是子程序的返回地址、子程序的参数以及程序的局部变量。而数据段则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用malloc之类的函数取得的空间）。这其中有许多细节问题，这里限于篇幅就不多介绍了。系统如果同时运行数个相同的程序，它们之间就不能使用同一个堆栈段和数据段。</p>
<ol>
<li>Linux下的进程控制在传统的Unix环境下，有两个基本的操作用于创建和修改进程：函数fork( )用来创建一个新的进程，该进程几乎是当前进程的一个完全拷贝；函数族exec( )用来启动另外的进程以取代当前运行的进程。Linux的进程控制和传统的Unix进程控制基本一致，只在一些细节的地方有些区别，例如在Linux系统中调用vfork和fork完全相同，而在有些版本的Unix系统中，vfork调用有不同的功能。由于这些差别几乎不影响我们大多数的编程，在这里我们不予考虑。</li>
</ol>
<p>1-2.1 fork( )<br>fork在英文中是”分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork，就产生了另一个进程，于是进程就”分叉”了，所以这个名字取得很形象。下面就看看如何具体使用fork，这段程序演示了使用fork的基本框架：</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li><strong>void</strong> main(){   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    if</strong> ( fork() == 0 ) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 子进程程序 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    for</strong> ( i = 1; i &lt;1000; i ++ ) printf(“This is child process/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    else</strong> {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 父进程程序</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>        for</strong> ( i = 1; i &lt;1000; i ++ ) printf(“This is process process/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p> 程序运行后，你就能看到屏幕上交替出现子进程与父进程各打印出的一千条信息了。如果程序还在运行中，你用ps命令就能看到系统中有两个它在运行了。<br>　　 那么调用这个fork函数时发生了什么呢？fork函数启动一个新的进程，前面我们说过，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现，这将是我们下面的内容。既然它们如此相象，系统如何来区分它们呢？这是由函数的返回值来决定的。对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps函数就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能，正如我们上面举的例子一样。我们看到，上面例子执行时两条信息是交互无规则的打印出来的，这是父子进程独立执行的结果，虽然我们的代码似乎和串行的代码没有什么区别。<br>　　 读者也许会问，如果一个大程序在运行中，它的数据段和堆栈都很大，一次fork就要复制一次，那么fork的系统开销不是很大吗？其实UNIX自有其解决的办法，大家知道，一般CPU都是以”页”为单位来分配内存空间的，每一个页都是实际物理内存的一个映像，比如INTEL的CPU，其一页在通常情况下是4086字节大小，而无论是数据段还是堆栈段都是由许多”页”构成的，fork函数复制这两个段，只是”逻辑”上的，并非”物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的”页”从物理上也分开。系统在空间上的开销就可以达到最小。</p>
<p>1.2-2 exec( )函数族<br>　　 下面我们来看看一个进程如何来启动另一个程序的执行。在Linux中要使用exec函数族。系统调用execve（）对当前进程进行替换，替换者为一个指定的程序，其参数包括文件名（filename）、参数列表（argv）以及环境变量（envp）。exec函数族当然不止一个，但它们大致相同，在Linux中，它们分别是：execl，execlp，execle，execv，execve和execvp，下面我只以execlp为例，其它函数究竟与execlp有何区别，请通过manexec命令来了解它们的具体情况。<br>　　 一个进程一旦调用exec类函数，它本身就”死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。（不过exec类函数中有的还允许继承环境变量之类的信息。）<br>　　 那么如果我的程序想启动另一程序的执行但自己仍想继续运行的话，怎么办呢？那就是结合fork与exec的使用。下面一段代码显示如何启动运行其它程序：</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li><strong>char</strong> command[256];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main()   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    int</strong> rtn; /<em>子进程的返回数值</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    while</strong>(1) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 从终端读取要执行的命令 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “&gt;” );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fgets( command, 256, stdin );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>command[strlen(command)-1] = 0;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>        if</strong> ( fork() == 0 ) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 子进程执行此命令 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>execlp( command, command );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 如果exec函数返回，表明没有正常执行命令，打印错误信息</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>perror( command );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit( errorno );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>        else</strong> {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 父进程， 等待子进程结束，并打印子进程的返回值 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>wait ( &amp;rtn );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “ child process return %d/n”,. rtn );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<p>此程序从终端读入命令并执行之，执行完成后，父进程继续等待从终端读入命令。熟悉DOS和WINDOWS系统调用的朋友一定知道DOS/WINDOWS也有exec类函数，其使用方法是类似的，但DOS/WINDOWS还有spawn类函数，因为DOS是单任务的系统，它只能将”父进程”驻留在机器内再执行”子进程”，这就是spawn类的函数。WIN32已经是多任务的系统了，但还保留了spawn类函数，WIN32中实现spawn函数的方法同前述UNIX中的方法差不多，开设子进程后父进程等待子进程结束后才继续运行。UNIX在其一开始就是多任务的系统，所以从核心角度上讲不需要spawn类函数。<br>　　 在这一节里，我们还要讲讲system（）和popen（）函数。system（）函数先调用fork（），然后再调用exec（）来执行用户的登录shell，通过它来查找可执行文件的命令并分析参数，最后它么使用wait（）函数族之一来等待子进程的结束。函数popen（）和函数system（）相似，不同的是它调用pipe（）函数创建一个管道，通过它来完成程序的标准输入和标准输出。这两个函数是为那些不太勤快的程序员设计的，在效率和安全方面都有相当的缺陷，在可能的情况下，应该尽量避免。</p>
<pre><code>1-3 Linux下的进程间通信 




    首先，进程间通信至少可以通过传送打开文件来实现，不同的进程通过一个或多个文件来传递信息，事实上，在很多应用系统里，都使用了这种方法。但一般说来，进程间通信      （IPC：InterProcess Communication）不包括这种似乎比较低级的通信方法。Unix系统中实现进程间通信的方法很多，而且不幸的是，极少方法能在所有的Unix系统中进行移植       （唯一一种是半双工的管道，这也是最原始的一种通信方式）。而Linux作为一种新兴的操作系统，几乎支持所有的Unix下常用的进程间通信方法：管道、消息队列、共享内存、信        号量、套接口等等。下面我们将逐一介绍。




    2.3.1 管道
</code></pre><p>　　            管道是进程间通信中最古老的方式，它包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者用于运行于同一台机器上的任意两个进程间的通信。<br>　　            无名管道由pipe（）函数创建：<br>　　             #include <unistd.h><br>　　            int pipe(int filedis[2])；<br>　　            参数filedis返回两个文件描述符：filedes[0]为读而打开，filedes[1]为写而打开。filedes[1]的输出是filedes[0]的输入。下面的例子示范了如何在父进程和子进程间实现通信。</unistd.h></p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>#define INPUT 0   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#define OUTPUT 1   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> file_descriptors[2];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>定义子进程号 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>pid_t pid;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>char</strong> buf[256];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> returned_count;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>创建无名管道</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>pipe(file_descriptors);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>创建子进程</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     if</strong>((pid = fork()) == -1) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“Error in fork/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>执行子进程</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     if</strong>(pid == 0) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“in the spawned (child) process…/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>子进程向父进程写数据，关闭管道的读端</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>close(file_descriptors[INPUT]);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>write(file_descriptors[OUTPUT], “test data”, strlen(“test data”));   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}</li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>else</strong> {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>执行父进程</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“in the spawning (parent) process…/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>父进程从管道读取子进程写的数据，关闭管道的写端</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>close(file_descriptors[OUTPUT]);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>returned_count = read(file_descriptors[INPUT], buf, <strong>sizeof</strong>(buf));   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“%d bytes of data received from spawned process: %s/n”,   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>returned_count, buf);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<pre><code>在Linux系统下，有名管道可由两种方式创建：命令行方式mknod系统调用和函数mkfifo。下面的两种途径都在当前目录下生成了一个名为myfifo的有名管道：
</code></pre><p>　　　　      方式一：mkfifo(“myfifo”,”rw”);<br>　　　　      方式二：mknod myfifo p<br>　　       生成了有名管道后，就可以使用一般的文件I/O函数如open、close、read、write等来对它进行操作。下面即是一个简单的例子，假设我们已经创建了一个名为myfifo的有名管道。</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>/<em> 进程一：读有名管道</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <unistd.h>   </unistd.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>FILE</strong> * in_file;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> count = 1;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>char</strong> buf[80];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>in_file = fopen(“mypipe”, “r”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>if</strong> (in_file == NULL) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“Error in fdopen./n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     while</strong> ((count = fread(buf, 1, 80, in_file)) &gt; 0)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“received from pipe: %s/n”, buf);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fclose(in_file);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　 /<em> 进程二：写有名管道</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <unistd.h>   </unistd.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     FILE</strong> * out_file;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     int</strong> count = 1;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     char</strong> buf[80];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>out_file = fopen(“mypipe”, “w”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     if</strong> (out_file == NULL) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“Error opening pipe.”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>sprintf(buf,”this is test data for the named pipe example/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fwrite(buf, 1, 80, out_file);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fclose(out_file);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<pre><code>the following is self-study &gt;&gt;




2.3.2 消息队列
</code></pre><p>　　      消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，事实上，它是一种正逐渐被淘汰的通信方式，我们可以用流管道或者套接口的方式来取代它，所以，我们对此方式也不再解释，也建议读者忽略这种方式。</p>
<p>　　      2.3.3 共享内存<br>　　      共享内存是运行在同一台机器上的进程间通信最快的方式，因为数据不需要在不同的进程间复制。通常由一个进程创建一块共享内存区，其余进程对这块内存区进行读写。得到共享内存有两种方式：映射/dev/mem设备和内存映像文件。前一种方式不给系统带来额外的开销，但在现实中并不常用，因为它控制存取的将是实际的物理内存，在Linux系统下，这只有通过限制Linux系统存取的内存才可以做到，这当然不太实际。常用的方式是通过shmXXX函数族来实现利用共享内存进行存储的。<br>　　      首先要用的函数是shmget，它获得一个共享存储标识符。<br>　　　　     #include <sys types.h=""><br>　　　　     #include <sys ipc.h=""><br>　　　　     #include <sys shm.h=""><br>　　　　　int shmget(key_t key, int size, int flag);<br>　　      这个函数有点类似大家熟悉的malloc函数，系统按照请求分配size大小的内存用作共享内存。Linux系统内核中每个IPC结构都有的一个非负整数的标识符，这样对一个消息队列发送消息时只要引用标识符就可以了。这个标识符是内核由IPC结构的关键字得到的，这个关键字，就是上面第一个函数的key。数据类型key_t是在头文件sys/types.h中定义的，它是一个长整形的数据。在我们后面的章节中，还会碰到这个关键字。<br>　　      当共享内存创建后，其余进程可以调用shmat（）将其连接到自身的地址空间中。<br>　　      void <em>shmat(int shmid, void </em>addr, int flag);<br>　　      shmid为shmget函数返回的共享存储标识符，addr和flag参数决定了以什么方式来确定连接的地址，函数的返回值即是该进程数据段所连接的实际地址，进程可以对此进程进行读写操作。<br>　　        使用共享存储来实现进程间通信的注意点是对数据存取的同步，必须确保当一个进程去读取数据时，它所想要的数据已经写好了。通常，信号量被要来实现对共享存储数据存取的同步，另外，可以通过使用shmctl函数设置共享存储内存的某些标志位如SHM_LOCK、SHM_UNLOCK等来实现。</sys></sys></sys></p>
<p>　　         2.3.4 信号量<br>　　      信号量又称为信号灯，它是用来协调不同进程间的数据对象的，而最主要的应用是前一节的共享内存方式的进程间通信。本质上，信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作：<br>　　      （1） 测试控制该资源的信号量。<br>　　      （2） 若此信号量的值为正，则允许进行使用该资源。进程将进号量减1。<br>　　      （3） 若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤（1）。<br>　　      （4） 当进程不再使用一个信号量控制的资源时，信号量值加1。如果此时有进程正在睡眠等待此信号量，则唤醒此进程。<br>　　      维护信号量状态的是Linux内核操作系统而不是用户进程。我们可以从头文件/usr/src/linux/include　/linux　/sem.h中看到内核用来维护信号量状态的各个结构的定义。信号量是一个数据集合，用户可以单独使用这一集合的每个元素。要调用的第一个函数是semget，用以获得一个信号量ID。
　　</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>#include <sys types.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　 #include <sys ipc.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　 #include <sys sem.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　 <strong>int</strong> semget(key_t key, <strong>int</strong> nsems, <strong>int</strong> flag);   </li>
</ol>
</li>
</ol>
<p>　　         key是前面讲过的IPC结构的关键字，它将来决定是创建新的信号量集合，还是引用一个现有的信号量集合。nsems是该集合中的信号量数。如果是创建新集合（一般在服务器中），则必须指定nsems；如果是引用一个现有的信号量集合（一般在客户机中）则将nsems指定为0。<br>　　         semctl函数用来对信号量进行操作。<br>　　      int semctl(int semid, int semnum, int cmd, union semun arg);<br>　　      不同的操作是通过cmd参数来实现的，在头文件sem.h中定义了7种不同的操作，实际编程时可以参照使用。<br>　　      semop函数自动执行信号量集合上的操作数组。<br>　　      int semop(int semid, struct sembuf semoparray[], size_t nops);<br>　　         semoparray是一个指针，它指向一个信号量操作数组。nops规定该数组中操作的数量。<br>　　        下面，我们看一个具体的例子，它创建一个特定的IPC结构的关键字和一个信号量，建立此信号量的索引，修改索引指向的信号量的值，最后我们清除信号量。在下面的代码中，函数ftok生成我们上文所说的唯一的IPC关键字。</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <sys types.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <sys sem.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <sys ipc.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>key_t unique_key; /<em> 定义一个IPC关键字</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> id;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>struct</strong> sembuf lock_it;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>union</strong> semun options;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>unique_key = ftok(“.”, ‘a’); /<em> 生成关键字，字符’a’是一个随机种子</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 创建一个新的信号量集合</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>id = semget(unique_key, 1, IPC_CREAT | IPC_EXCL | 0666);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“semaphore id=%d/n”, id);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>options.val = 1; /<em>设置变量值</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>semctl(id, 0, SETVAL, options); /<em>设置索引0的信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>打印出信号量的值</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>i = semctl(id, 0, GETVAL, 0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“value of semaphore at index 0 is %d/n”, i);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>下面重新设置信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>lock_it.sem_num = 0; /<em>设置哪个信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>lock_it.sem_op = -1; /<em>定义操作</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>lock_it.sem_flg = IPC_NOWAIT; /<em>操作方式</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>if</strong> (semop(id, &amp;lock_it, 1) == -1) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“can not lock semaphore./n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>i = semctl(id, 0, GETVAL, 0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“value of semaphore at index 0 is %d/n”, i);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>清除信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>semctl(id, 0, IPC_RMID, 0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<p>　　       2.3.5 套接口<br>　　      套接口（socket）编程是实现Linux系统和其他大多数操作系统中进程间通信的主要方式之一。我们熟知的WWW服务、FTP服务、TELNET服务等都是基于套接口编程来实现的。除了在异地的计算机进程间以外，套接口同样适用于本地同一台计算机内部的进程间通信。关于套接口的经典教材同样是Richard Stevens编著的《Unix网络编程：联网的API和套接字》，清华大学出版社出版了该书的影印版。它同样是Linux程序员的必备书籍之一。<br>　　      关于这一部分的内容，可以参照本文作者的另一篇文章《设计自己的网络蚂蚁》，那里由常用的几个套接口函数的介绍和示例程序。这一部分或许是Linux进程间通信编程中最须关注和最吸引人的一部分，毕竟，Internet 正在我们身边以不可思议的速度发展着，如果一个程序员在设计编写他下一个程序的时候，根本没有考虑到网络，考虑到Internet，那么，可以说，他的设计很难成功。</p>
<p>3 Linux的进程和Win32的进程/线程比较<br>　　      熟悉WIN32编程的人一定知道，WIN32的进程管理方式与Linux上有着很大区别，在UNIX里，只有进程的概念，但在WIN32里却还有一个”线程”的概念，那么Linux和WIN32在这里究竟有着什么区别呢？<br>　　      WIN32里的进程/线程是继承自OS/2的。在WIN32里，”进程”是指一个程序，而”线程”是一个”进程”里的一个执行”线索”。从核心上讲，WIN32的多进程与Linux并无多大的区别，在WIN32里的线程才相当于Linux的进程，是一个实际正在执行的代码。但是，WIN32里同一个进程里各个线程之间是共享数据段的。这才是与Linux的进程最大的不同。<br>　　      下面这段程序显示了WIN32下一个进程如何启动一个线程。</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li><strong>int</strong> g;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>DWORD</strong> WINAPI ChildProcess( <strong>LPVOID</strong> lpParameter ){   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>for</strong> ( i = 1; i &lt;1000; i ++) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>g ++;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “This is Child Thread: %d/n”, g );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>ExitThread( 0 );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>};   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main()   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> threadID;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>g = 0;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>CreateThread( NULL, 0, ChildProcess, NULL, 0, &amp;threadID );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>for</strong> ( i = 1; i &lt;1000; i ++) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>g ++;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “This is Parent Thread: %d/n”, g );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<p>　　       在WIN32下，使用CreateThread函数创建线程，与Linux下创建进程不同，WIN32线程不是从创建处开始运行的，而是由CreateThread指定一个函数，线程就从那个函数处开始运行。此程序同前面的UNIX程序一样，由两个线程各打印1000条信息。threadID是子线程的线程号，另外，全局变量g是子线程与父线程共享的，这就是与Linux最大的不同之处。大家可以看出，WIN32的进程/线程要比Linux复杂，在Linux要实现类似WIN32的线程并不难，只要fork以后，让子进程调用ThreadProc函数，并且为全局变量开设共享数据区就行了，但在WIN32下就无法实现类似fork的功能了。所以现在WIN32下的C语言编译器所提供的库函数虽然已经能兼容大多数Linux/UNIX的库函数，但却仍无法实现fork。<br>　　        对于多任务系统，共享数据区是必要的，但也是一个容易引起混乱的问题，在WIN32下，一个程序员很容易忘记线程之间的数据是共享的这一情况，一个线程修改过一个变量后，另一个线程却又修改了它，结果引起程序出问题。但在Linux下，由于变量本来并不共享，而由程序员来显式地指定要共享的数据，使程序变得更清晰与安全。<br>至于WIN32的”进程”概念，其含义则是”应用程序”，也就是相当于UNIX下的exec了。<br>　　         Linux也有自己的多线程函数pthread，它既不同于Linux的进程，也不同于WIN32下的进程，关于pthread的介绍和如何在Linux环境下编写多线程程序我们将在另一篇文章《Linux下的多线程编程》中讲述。</p>
<pre><code>4 鸣谢
</code></pre><p>　　       本文部分内容参照<a href="http://www.lisoleg.org/" target="_blank" rel="external">www.lisoleg.org</a>内的《Linux下的多进程编程》，原作者俞磊。</p>
<pre><code>The part ends in there.&lt;&lt;
</code></pre><ol>
<li>线程（thread）2-1 介绍</li>
</ol>
<p>线程（thread）技术早在60年代就被提出，但真正应用多线程到操作系统中去，是在80年代中期，solaris是这方面的佼佼者。传统的Unix也支持线程的概念，但是在一个进程（process）中只允许有一个线程，这样多线程就意味着多进程。现在，多线程技术已经被许多操作系统所支持，包括Windows/NT，当然，也包括Linux。<br>为什么有了进程的概念后，还要再引入线程呢？使用多线程到底有哪些好处？什么的系统应该选用多线程？我们首先必须回答这些问题。<br>使用多线程的理由之一是和进程相比，它是一种非常”节俭”的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。<br>使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。<br>除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：<br>1) 提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。<br>2) 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。<br>3) 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。<br>下面我们先来尝试编写一个简单的多线程程序。<br>2 简单的多线程编程<br>Linux系统下的多线程遵循POSIX线程接口，称为pthread。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。顺便说一下，Linux下pthread的实现是通过系统调用clone（）来实现的。clone（）是Linux所特有的系统调用，它的使用方式类似fork，关于clone（）的详细情况，有兴趣的读者可以去查看有关文档说明。下面我们展示一个最简单的多线程程序</p>
<ol>
<li><ol>
<li>/<em> example.c</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　#include <stdlib.h>   </stdlib.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　#include <pthread.h>   </pthread.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　<strong>void</strong> <strong>thread</strong>(<strong>void</strong>)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　    <strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　    <strong>for</strong>(i=0;i&lt;3;i++)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　    printf(“This is a pthread.\n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　<strong>int</strong> main(<strong>void</strong>)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   pthread_t id;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>int</strong> i,ret;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   ret=pthread_create(&amp;id,NULL,(<strong>void</strong> <em>) <em>*thread</em></em>,NULL);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>if</strong>(ret!=0){   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   printf (“Create pthread error!\n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   exit (1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   }   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>for</strong>(i=0;i&lt;3;i++)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   printf(“This is the main process.\n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   pthread_join(id,NULL);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>return</strong> (0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　} </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p>我们编译此程序：<br>　　gcc example1.c -lpthread -o example1<br>　　运行example1，我们得到如下结果：<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is the main process.<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is a pthread.<br>　　再次运行，我们可能得到如下结果：<br>　　This is a pthread.<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is the main process.<br>　　前后两次结果不一样，这是两个线程争夺CPU资源的结果。上面的示例中，我们使用到了两个函数，　pthread_create和pthread_join，并声明了一个pthread_t型的变量。<br>　　pthread_t在头文件/usr/include/bits/pthreadtypes.h中定义：<br>　　typedef unsigned long int pthread_t;<br>　　它是一个线程的标识符。函数pthread_create用来创建一个线程，它的原型为：<br>　　   extern int pthread_create <strong>P ((pthread_t *</strong>thread, <strong>const pthread_attr_t *</strong>attr,<br>　　   void <em>(</em><strong>start_routine) (void <em>), void </em></strong>arg));<br>　　第一个参数为指向线程标识符的指针，第二个参数用来设置线程属性，第三个参数是线程运行函数的起始地址，最后一个参数是运行函数的参数。这里，我们的函数thread不需要参数，所以最后一个参数设为空指针。第二个参数我们也设为空指针，这样将生成默认属性的线程。对线程属性的设定和修改我们将在下一节阐述。当创建线程成功时，函数返回0，若不为0则说明创建线程失败，常见的错误返回代码为EAGAIN和EINVAL。前者表示系统限制创建新的线程，例如线程数目过多了；后者表示第二个参数代表的线程属性值非法。创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。<br>　　函数pthread_join用来等待一个线程的结束。函数原型为：<br>　　   extern int pthread_join <strong>P ((pthread_t </strong>th, void <em>*<strong>thread_return));<br>　　第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，它可以用来存储被等待线程的返回值。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。一个线程的结束有两种途径，一种是象我们上面的例子一样，函数结束了，调用它的线程也就结束了；另一种方式是通过函数pthread_exit来实现。它的函数原型为：<br>　　   extern void pthread_exit </strong>P ((void </em><strong>retval)) </strong>attribute<strong> ((</strong>noreturn__));<br>　　唯一的参数是函数的返回代码，只要pthread_join中的第二个参数thread_return不是NULL，这个值将被传递给thread_return。最后要说明的是，一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread_join的线程则返回错误代码ESRCH。<br>　　在这一节里，我们编写了一个最简单的线程，并掌握了最常用的三个函数pthread_create，pthread_join和pthread_exit。下面，我们来了解线程的一些常用属性以及如何设置这些属性。<br>　　3 修改线程的属性<br>　　在上一节的例子里，我们用pthread_create函数创建了一个线程，在这个线程中，我们使用了默认参数，即将该函数的第二个参数设为NULL。的确，对大多数程序来说，使用默认属性就够了，但我们还是有必要来了解一下线程的有关属性。<br>　　属性结构为pthread_attr_t，它同样在头文件/usr/include/pthread.h中定义，喜欢追根问底的人可以自己去查看。属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。属性对象主要包括是否绑定、是否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。<br>　　关于线程的绑定，牵涉到另外一个概念：轻进程（LWP：Light Weight Process）。轻进程可以理解为内核线程，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状况下，则顾名思义，即某个线程固定的”绑”在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。<br>　　设置线程绑定状态的函数为pthread_attr_setscope，它有两个参数，第一个是指向属性结构的指针，第二个是绑定类型，它有两个取值：PTHREAD_SCOPE_SYSTEM（绑定的）和PTHREAD_SCOPE_PROCESS（非绑定的）。下面的代码即创建了一个绑定的线程。</p>
<p>　　#include <pthread.h><br>　　pthread_attr_t attr;<br>　　pthread_t tid;<br>　　/<em>初始化属性值，均设为默认值</em>/<br>　　pthread_attr_init(&amp;attr);<br>　　pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);<br>　　pthread_create(&amp;tid, &amp;attr, (void *) my_function, NULL); </pthread.h></p>
<p>　　线程的分离状态决定一个线程以什么样的方式来终止自己。在上面的例子中，我们采用了线程的默认属性，即为非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。设置线程分离状态的函数为pthread_attr_setdetachstate（pthread_attr_t *attr, int detachstate）。第二个参数可选为PTHREAD_CREATE_DETACHED（分离线程）和 PTHREAD _CREATE_JOINABLE（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。<br>　　另外一个可能常用的属性是线程的优先级，它存放在结构sched_param中。用函数pthread_attr_getschedparam和函数pthread_attr_setschedparam进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。下面即是一段简单的例子。</p>
<p>　    #include <pthread.h><br>　　#include <sched.h><br>　　pthread_attr_t attr;<br>　　pthread_t tid;<br>　　sched_param param;<br>　　int newprio=20;<br>　　pthread_attr_init(&amp;attr);<br>　　pthread_attr_getschedparam(&amp;attr, &amp;param);<br>　　param.sched_priority=newprio;<br>　　pthread_attr_setschedparam(&amp;attr, &amp;param);<br>　　pthread_create(&amp;tid, &amp;attr, (void <em>)myfunction, myarg);<br>　　4 线程的数据处理<br>　　和进程相比，线程的最大优点之一是数据的共享性，各个进程共享父进程处沿袭的数据段，可以方便的获得、修改数据。但这也给多线程编程带来了许多问题。我们必须当心有多个不同的进程访问相同的变量。许多函数是不可重入的，即同时不能运行一个函数的多个拷贝（除非使用不同的数据段）。在函数中声明的静态变量常常带来问题，函数的返回值也会有问题。因为如果返回的是函数内部静态声明的空间的地址，则在一个线程调用该函数得到地址后使用该地址指向的数据时，别的线程可能调用此函数并修改了这一段数据。在进程中共享的变量必须用关键字volatile来定义，这是为了防止编译器在优化时（如gcc中使用-OX参数）改变它们的使用方式。为了保护变量，我们必须使用信号量、互斥等方法来保证我们对变量的正确使用。下面，我们就逐步介绍处理线程数据时的有关知识。<br>　　4.1 线程数据<br>　　在单线程的程序里，有两种基本的数据：全局变量和局部变量。但在多线程程序里，还有第三种数据类型：线程数据（TSD: Thread-Specific Data）。它和全局变量很象，在线程内部，各个函数可以象使用全局变量一样调用它，但它对线程外部的其它线程是不可见的。这种数据的必要性是显而易见的。例如我们常见的变量errno，它返回标准的出错信息。它显然不能是一个局部变量，几乎每个函数都应该可以调用它；但它又不能是一个全局变量，否则在A线程里输出的很可能是B线程的出错信息。要实现诸如此类的变量，我们就必须使用线程数据。我们为每个线程数据创建一个键，它和这个键相关联，在各个线程里，都使用这个键来指代线程数据，但在不同的线程里，这个键代表的数据是不同的，在同一个线程里，它代表同样的数据内容。<br>　　和线程数据相关的函数主要有4个：创建一个键；为一个键指定线程数据；从一个键读取线程数据；删除键。<br>　　创建键的函数原型为：<br>　　extern int pthread_key_create __P ((pthread_key_t </em><strong>key,<br>　　void (*</strong>destr_function) (void <em>)));<br>　　第一个参数为指向一个键值的指针，第二个参数指明了一个destructor函数，如果这个参数不为空，那么当每个线程结束时，系统将调用这个函数来释放绑定在这个键上的内存块。这个函数常和函数pthread_once ((pthread_once_t</em>once_control, void (<em>initroutine) (void)))一起使用，为了让这个键只被创建一次。函数pthread_once声明一个初始化函数，第一次调用pthread_once时它执行这个函数，以后的调用将被它忽略。<br>　　在下面的例子中，我们创建一个键，并将它和某个数据相关联。我们要定义一个函数createWindow，这个函数定义一个图形窗口（数据类型为Fl_Window </em>，这是图形界面开发工具FLTK中的数据类型）。由于各个线程都会调用这个函数，所以我们使用线程数据。<br>　　/<em> 声明一个键</em>/<br>　　pthread_key_t myWinKey;<br>　　/<em> 函数 createWindow </em>/<br>　　void createWindow ( void ) {<br>　　Fl_Window <em> win;<br>　　static pthread_once_t once= PTHREAD_ONCE_INIT;<br>　　/</em> 调用函数createMyKey，创建键<em>/<br>　　pthread_once ( &amp; once, createMyKey) ;<br>　　/</em>win指向一个新建立的窗口<em>/<br>　　win=new Fl_Window( 0, 0, 100, 100, “MyWindow”);<br>　　/</em> 对此窗口作一些可能的设置工作，如大小、位置、名称等<em>/<br>　　setWindow(win);<br>　　/</em> 将窗口指针值绑定在键myWinKey上<em>/<br>　　pthread_setspecific ( myWinKey, win);<br>　　}<br>　　/</em> 函数 createMyKey，创建一个键，并指定了destructor <em>/<br>　　void createMyKey ( void ) {<br>　　pthread_key_create(&amp;myWinKey, freeWinKey);<br>　　}<br>　　/</em> 函数 freeWinKey，释放空间<em>/<br>　　void freeWinKey ( Fl_Window </em> win){<br>　　delete win;<br>　　}<br>　　这样，在不同的线程中调用函数createMyWin，都可以得到在线程内部均可见的窗口变量，这个变量通过函数pthread_getspecific得到。在上面的例子中，我们已经使用了函数pthread_setspecific来将线程数据和一个键绑定在一起。这两个函数的原型如下：<br>　　extern int pthread_setspecific <strong>P ((pthread_key_t </strong>key,<strong>const void *</strong>pointer));<br>　　extern void <em>pthread_getspecific <strong>P ((pthread_key_t </strong>key));<br>　　这两个函数的参数意义和使用方法是显而易见的。要注意的是，用pthread_setspecific为一个键指定新的线程数据时，必须自己释放原有的线程数据以回收空间。这个过程函数pthread_key_delete用来删除一个键，这个键占用的内存将被释放，但同样要注意的是，它只释放键占用的内存，并不释放该键关联的线程数据所占用的内存资源，而且它也不会触发函数pthread_key_create中定义的destructor函数。线程数据的释放必须在释放键之前完成。<br>　　4.2 互斥锁<br>　　互斥锁用来保证一段时间内只有一个线程在执行一段代码。必要性显而易见：假设各个线程向同一个文件顺序写入数据，最后得到的结果一定是灾难性的。<br>　　我们先看下面一段代码。这是一个读/写程序，它们公用一个缓冲区，并且我们假定一个缓冲区只能保存一条信息。即缓冲区只有两个状态：有信息或没有信息。<br>　　void reader_function ( void );<br>　　void writer_function ( void );<br>　　char buffer;<br>　　int buffer_has_item=0;<br>　　pthread_mutex_t mutex;<br>　　struct timespec delay;<br>　　void main ( void ){<br>　　pthread_t reader;<br>　　/</em> 定义延迟时间<em>/<br>　　delay./</em> <em>/tv_sec = 2;<br>　　delay../</em> <em>/tv_nec = 0;<br>　　/</em> 用默认属性初始化一个互斥锁对象<em>/<br>　　pthread_mutex_init (&amp;mutex,NULL);<br>　　pthread_create(&amp;reader, pthread_attr_default, (void </em>)&amp;reader_function), NULL);<br>　　writer_function( );<br>　　}<br>　　void writer_function (void){<br>　　while(1){<br>　　/<em> 锁定互斥锁</em>/<br>　　pthread_mutex_lock (&amp;mutex);<br>　　if (buffer_has_item==0){<br>　　buffer=make_new_item( );<br>　　buffer_has_item=1;<br>　　}<br>　　/<em> 打开互斥锁</em>/<br>　　pthread_mutex_unlock(&amp;mutex);<br>　　pthread_delay_np(&amp;delay);<br>　　}<br>　　}<br>　　void reader_function(void){<br>　　while(1){<br>　　pthread_mutex_lock(&amp;mutex);<br>　　if(buffer_has_item==1){<br>　　consume_item(buffer);<br>　　buffer_has_item=0;<br>　　}<br>　　pthread_mutex_unlock(&amp;mutex);<br>　　pthread_delay_np(&amp;delay);<br>　　}<br>　　}<br>　　这里声明了互斥锁变量mutex，结构pthread_mutex_t为不公开的数据类型，其中包含一个系统分配的属性对象。函数pthread_mutex_init用来生成一个互斥锁。NULL参数表明使用默认属性。如果需要声明特定属性的互斥锁，须调用函数pthread_mutexattr_init。函数pthread_mutexattr_setpshared和函数pthread_mutexattr_settype用来设置互斥锁属性。前一个函数设置属性pshared，它有两个取值，PTHREAD_PROCESS_PRIVATE和PTHREAD_PROCESS_SHARED。前者用来不同进程中的线程同步，后者用于同步本进程的不同线程。在上面的例子中，我们使用的是默认属性PTHREAD<em>PROCESS</em> PRIVATE。后者用来设置互斥锁类型，可选的类型有PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE和PTHREAD _MUTEX_DEFAULT。它们分别定义了不同的上所、解锁机制，一般情况下，选用最后一个默认属性。<br>　　pthread_mutex_lock声明开始用互斥锁上锁，此后的代码直至调用pthread_mutex_unlock为止，均被上锁，即同一时间只能被一个线程调用执行。当一个线程执行到pthread_mutex_lock处时，如果该锁此时被另一个线程使用，那此线程被阻塞，即程序将等待到另一个线程释放此互斥锁。在上面的例子中，我们使用了pthread_delay_np函数，让线程睡眠一段时间，就是为了防止一个线程始终占据此函数。<br>　　上面的例子非常简单，就不再介绍了，需要提出的是在使用互斥锁的过程中很有可能会出现死锁：两个线程试图同时占用两个资源，并按不同的次序锁定相应的互斥锁，例如两个线程都需要锁定互斥锁1和互斥锁2，a线程先锁定互斥锁1，b线程先锁定互斥锁2，这时就出现了死锁。此时我们可以使用函数pthread_mutex_trylock，它是函数pthread_mutex_lock的非阻塞版本，当它发现死锁不可避免时，它会返回相应的信息，程序员可以针对死锁做出相应的处理。另外不同的互斥锁类型对死锁的处理不一样，但最主要的还是要程序员自己在程序设计注意这一点。<br>　　4.3 条件变量<br>　　前一节中我们讲述了如何使用互斥锁来实现线程间数据的共享和通信，互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。<br>　　条件变量的结构为pthread_cond_t，函数pthread_cond_init（）被用来初始化一个条件变量。它的原型为：<br>　　extern int pthread_cond_init <strong>P ((pthread_cond_t *</strong>cond,<strong>const pthread_condattr_t *</strong>cond_attr));<br>　　其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构pthread_condattr<em>t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用，默认值是PTHREAD</em> PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread<em>cond</em> destroy（pthread_cond_t cond）。　<br>　　函数pthread_cond_wait（）使线程阻塞在一个条件变量上。它的函数原型为：<br>　　extern int pthread_cond_wait <strong>P ((pthread_cond_t *</strong>cond,<br>　　pthread_mutex_t <em><strong>mutex));<br>　　线程解开mutex指向的锁并被条件变量cond阻塞。线程可以被函数pthread_cond_signal和函数pthread_cond_broadcast唤醒，但是要注意的是，条件变量只是起阻塞和唤醒线程的作用，具体的判断条件还需用户给出，例如一个变量是否为0等等，这一点我们从后面的例子中可以看到。线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，一般说来线程应该仍阻塞在这里，被等待被下一次唤醒。这个过程一般用while语句实现。<br>　　另一个用来阻塞线程的函数是pthread_cond_timedwait（），它的原型为：<br>　　extern int pthread_cond_timedwait </strong>P ((pthread_cond_t </em><strong>cond,<br>　　pthread_mutex_t *</strong>mutex, <strong>const struct timespec *</strong>abstime));<br>　　它比函数pthread_cond_wait（）多了一个时间参数，经历abstime段时间后，即使条件变量不满足，阻塞也被解除。<br>　　函数pthread_cond_signal（）的原型为：<br>　　extern int pthread_cond_signal <strong>P ((pthread_cond_t *</strong>cond));<br>　　它用来释放被阻塞在条件变量cond上的一个线程。多个线程阻塞在此条件变量上时，哪一个线程被唤醒是由线程的调度策略所决定的。要注意的是，必须用保护条件变量的互斥锁来保护这个函数，否则条件满足信号又可能在测试条件和调用pthread_cond_wait函数之间被发出，从而造成无限制的等待。下面是使用函数pthread_cond_wait（）和函数pthread_cond_signal（）的一个简单的例子。<br>　　pthread_mutex_t count_lock;<br>　　pthread_cond_t count_nonzero;<br>　　unsigned count;<br>　　decrement_count　() {<br>　　pthread_mutex_lock (&amp;count_lock);<br>　　while(count==0)<br>　　pthread_cond_wait( &amp;count_nonzero, &amp;count_lock);<br>　　count=count -1;<br>　　pthread_mutex_unlock (&amp;count_lock);<br>　　}<br>　　increment_count(){<br>　　pthread_mutex_lock(&amp;count_lock);<br>　　if(count==0)<br>　　pthread_cond_signal(&amp;count_nonzero);<br>　　count=count+1;<br>　　pthread_mutex_unlock(&amp;count_lock);<br>　　}<br>　　count值为0时，decrement函数在pthread_cond_wait处被阻塞，并打开互斥锁count_lock。此时，当调用到函数increment_count时，pthread_cond_signal（）函数改变条件变量，告知decrement_count（）停止阻塞。读者可以试着让两个线程分别运行这两个函数，看看会出现什么样的结果。<br>　　函数pthread_cond_broadcast（pthread_cond_t <em>cond）用来唤醒所有被阻塞在条件变量cond上的线程。这些线程被唤醒后将再次竞争相应的互斥锁，所以必须小心使用这个函数。<br>　　4.4 信号量<br>　　信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。当公共资源增加时，调用函数sem_post（）增加信号量。只有当信号量值大于０时，才能使用公共资源，使用后，函数sem_wait（）减少信号量。函数sem<em>trywait（）和函数pthread</em> mutex_trylock（）起同样的作用，它是函数sem_wait（）的非阻塞版本。下面我们逐个介绍和信号量有关的一些函数，它们都在头文件/usr/include/semaphore.h中定义。<br>　　信号量的数据类型为结构sem_t，它本质上是一个长整型的数。函数sem_init（）用来初始化一个信号量。它的原型为：<br>　　extern int sem_init __P ((sem_t </em><strong>sem, int </strong>pshared, unsigned int __value));<br>　　sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。<br>　　函数sem_post( sem_t <em>sem )用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。<br>　　函数sem_wait( sem_t </em>sem )被用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem_trywait ( sem_t <em>sem )是函数sem_wait（）的非阻塞版本，它直接将信号量sem的值减一。<br>　　函数sem_destroy(sem_t </em>sem)用来释放信号量sem。<br>　　下面我们来看一个使用信号量的例子。在这个例子中，一共有4个线程，其中两个线程负责从文件读取数据到公共的缓冲区，另两个线程从缓冲区读取数据作不同的处理（加和乘运算）。<br>　　/<em> File sem.c </em>/<br>　　#include <stdio.h><br>　　#include <pthread.h><br>　　#include <semaphore.h><br>　　#define MAXSTACK 100<br>　　int stack[MAXSTACK][2];<br>　　int size=0;<br>　　sem_t sem;<br>　　/<em> 从文件1.dat读取数据，每读一次，信号量加一</em>/<br>　　void ReadData1(void){<br>　　FILE <em>fp=fopen(“1.dat”,”r”);<br>　　while(!feof(fp)){<br>　　fscanf(fp,”%d %d”,&amp;stack[0],&amp;stack[1]);<br>　　sem_post(&amp;sem);<br>　　++size;<br>　　}<br>　　fclose(fp);<br>　　}<br>　　/</em>从文件2.dat读取数据<em>/<br>　　void ReadData2(void){<br>　　FILE </em>fp=fopen(“2.dat”,”r”);<br>　　while(!feof(fp)){<br>　　fscanf(fp,”%d %d”,&amp;stack[0],&amp;stack[1]);<br>　　sem_post(&amp;sem);<br>　　++size;<br>　　}<br>　　fclose(fp);<br>　　}<br>　　/<em>阻塞等待缓冲区有数据，读取数据后，释放空间，继续等待</em>/<br>　　void HandleData1(void){<br>　　while(1){<br>　　sem_wait(&amp;sem);<br>　　printf(“Plus:%d+%d=%d\n”,stack[0],stack[1],<br>　　stack[0]+stack[1]);<br>　　–size;<br>　　}<br>　　}<br>　　void HandleData2(void){<br>　　while(1){<br>　　sem_wait(&amp;sem);<br>　　printf(“Multiply:%d<em>%d=%d\n”,stack[0],stack[1],<br>　　stack[0]</em>stack[1]);<br>　　–size;<br>　　}<br>　　}<br>　　int main(void){<br>　　pthread_t t1,t2,t3,t4;<br>　　sem_init(&amp;sem,0,0);<br>　　pthread_create(&amp;t1,NULL,(void <em>)HandleData1,NULL);<br>　　pthread_create(&amp;t2,NULL,(void </em>)HandleData2,NULL);<br>　　pthread_create(&amp;t3,NULL,(void <em>)ReadData1,NULL);<br>　　pthread_create(&amp;t4,NULL,(void </em>)ReadData2,NULL);<br>　　/<em> 防止程序过早退出，让它在此无限期等待</em>/<br>　　pthread_join(t1,NULL);<br>　　}<br>　　在Linux下，我们用命令gcc -lpthread sem.c -o sem生成可执行文件sem。 我们事先编辑好数据文件1.dat和2.dat，假设它们的内容分别为1 2 3 4 5 6 7 8 9 10和 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 ，我们运行sem，得到如下的结果：<br>　　Multiply:-1<em>-2=2<br>　　Plus:-1+-2=-3<br>　　Multiply:9</em>10=90<br>　　Plus:-9+-10=-19<br>　　Multiply:-7<em>-8=56<br>　　Plus:-5+-6=-11<br>　　Multiply:-3</em>-4=12<br>　　Plus:9+10=19<br>　　Plus:7+8=15<br>　　Plus:5+6=11<br>　　从中我们可以看出各个线程间的竞争关系。而数值并未按我们原先的顺序显示出来这是由于size这个数值被各个线程任意修改的缘故。这也往往是多线程编程要注意的问题。<br>　　5 小结<br>　　多线程编程是一个很有意思也很有用的技术，使用多线程技术的网络蚂蚁是目前最常用的下载工具之一，使用多线程技术的grep比单线程的grep要快上几倍，类似的例子还有很多。希望大家能用多线程技术写出高效实用的好程序来。</semaphore.h></pthread.h></stdio.h></sched.h></pthread.h></p>
<p>Last!!!!!!!!!Linux内核对多进程和多线程的支持方式：</p>
<pre><code>线程机制支持并发程序设计技术，在多处理器上能真正保证并行处理。而在linux实现线程很特别，linux把所有的线程都当作进程实现。linux下线程看起来就像普通进程(只是该进程和其他进程共享资源，如地址空间)。上述机制与Microsoft windows或是Sun Solaris实现差异很大。




Linux的线程实现是在核外进行的，核内提供的是创建进程的接口do_fork()。内核提供了两个系统调用__clone()和fork()，最终都用不同的参数调用do_fork()核内API。 do_fork() 提供了很多参数，包括CLONE_VM（共享内存空间）、CLONE_FS（共享文件系统信息）、CLONE_FILES（共享文件描述符表）、CLONE_SIGHAND（共享信号句柄表）和CLONE_PID（共享进程ID，仅对核内进程，即0号进程有效）。当使用fork系统调用产生多进程时，内核调用do_fork()不使用任何共享属性，进程拥有独立的运行环境。当使用pthread_create()来创建线程时，则最终设置了所有这些属性来调用__clone()，而这些参数又全部传给核内的do_fork()，从而创建的”进程”拥有共享的运行环境，只有栈是独立的，由 __clone()传入。




 即：Linux下**不管是多线程编程还是多进程编程，最终都是用do_fork实现**的多进程编程，只是进程创建时的参数不同，从而导致有不同的共享环境。Linux线程在核内是以轻量级进程的形式存在的，拥有独立的进程表项，而所有的创建、同步、删除等操作都在核外pthread库中进行。pthread 库使用一个管理线程（__pthread_manager() ，每个进程独立且唯一）来管理线程的创建和终止，为线程分配线程ID，发送线程相关的信号，而主线程pthread_create()） 的调用者则通过管道将请求信息传给管理线程。
</code></pre><p>很多朋友都说使用多线程的好处是资源占用少，其隐含之意就是说进程占用资源比线程多，对吧？但实际上Linux下多进程是否就真的点用很多资源呢？暂且不说进程是否比线程占用资源多，就进程占用资源的多少情况而言，Linux确实是做得相当节省的。产生一个多进程时肯定是要产生的一点内存是要复制进程表项，即一个task_struct结构，但这个结构本身做得相当小巧。其它对于一个进程来说必须有的数据段、代码段、堆栈段是不是全盘复制呢？对于多进程来说，代码段是肯定不用复制的，因为父进程和各子进程的代码段是相同的，数据段和堆栈段呢？也不一定，因为在Linux里广泛使用的一个技术叫copy-on-write，即写时拷贝。copy-on-write意味着什么呢？意味着资源节省，假设有一个变量x在父进程里存在，当这个父进程创建一个子进程或多个子进程时这个变量x是否复制到了子进程的内存空间呢？不会的，子进程和父进程使用同一个内存空间的变量，但当子进程或父进程要改变变量x的值时就会复制该变量，从而导致父子进程里的变量值不同。<strong>父子进程变量是互不影响的，由于父子进程地址空间是完全隔开的，变量的地址可以是完全相同的</strong>。</p>
<pre><code> Linux的”线程”和”进程”实际上处于一个调度层次，共享一个进程标识符空间，这种限制使得不可能在Linux上实现完全意义上的POSIX线程机制，因此众多的Linux线程库实现尝试都只能尽可能实现POSIX的绝大部分语义，并在功能上尽可能逼近。Linux进程的创建是非常迅速的。内核设计与实现一书中甚至指出Linux创建进程的速度和其他针对线程优化的操作系统（Windows,Solaris）创建线程的速度相比，测试结果非常的好，也就是说创建速度很快。由于异步信号是内核以进程为单位分发的，而LinuxThreads的每个线程对内核来说都是一个进程，且没有实现”线程组”，因此，某些语义不符合POSIX标准，比如没有实现向进程中所有线程发送信号，README对此作了说明。LinuxThreads中的线程同步很大程度上是建立在信号基础上的，这种通过内核复杂的信号处理机制的同步方式，效率一直是个问题。LinuxThreads 的问题，特别是兼容性上的问题，严重阻碍了Linux上的跨平台应用（如Apache）采用多线程设计，从而使得Linux上的线程应用一直保持在比较低的水平。在Linux社区中，已经有很多人在为改进线程性能而努力，其中既包括用户级线程库，也包括核心级和用户级配合改进的线程库。目前最为人看好的有两个项目，一个是RedHat公司牵头研发的NPTL（Native Posix Thread Library），另一个则是IBM投资开发的NGPT（Next Generation Posix Threading），二者都是围绕完全兼容POSIX 1003.1c，同时在核内和核外做工作以而实现多对多线程模型。这两种模型都在一定程度上弥补了LinuxThreads的缺点，且都是重起炉灶全新设计的。




 综上所述的**结论是在Linux下编程多用多进程编程少用多线程编程**。




IBM有个家伙做了个测试，发现切换线程context的时候，windows比linux快一倍多。进出最快的锁（windows2k的 critical section和linux的pthread_mutex），windows比linux的要快五倍左右。当然这并不是说linux不好，而且在经过实际编程之后，综合来看我觉得linux更适合做high performance server，不过在多线程这个具体的领域内，linux还是稍逊windows一点。这应该是情有可原的，毕竟unix家族都是从多进程过来的，而 windows从头就是多线程的。
</code></pre><p>如果是UNIX/linux环境，采用多线程没必要。</p>
<p>多线程比多进程性能高？误导！</p>
<p>应该说，<strong>多线程比多进程成本低，但性能更低</strong>。</p>
<p>在UNIX环境，多进程调度开销比多线程调度开销，没有显著区别，就是说，UNIX进程调度效率是很高的。内存消耗方面，二者只差全局数据区，现在内存都很便宜，服务器内存动辄若干G，根本不是问题。</p>
<p><strong>多进程是立体交通系统，虽然造价高，上坡下坡多耗点油，但是不堵车。</strong></p>
<p><strong>多线程是平面交通系统，造价低，但红绿灯太多，老堵车。</strong></p>
<p>我们现在都开跑车，油（主频）有的是，不怕上坡下坡，就怕堵车。</p>
<p>高性能交易服务器中间件，如TUXEDO，都是主张多进程的。实际测试表明，TUXEDO性能和并发效率是非常高的。TUXEDO是贝尔实验室的，与UNIX同宗，应该是对UNIX理解最为深刻的，他们的意见应该具有很大的参考意义。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    kido zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kidozh.github.io/2015/05/02/linuxlinux-e4-b8-8b-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-9a-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1/" title="[linux]Linux下的多线程多进程通信">https://kidozh.github.io/2015/05/02/linuxlinux-e4-b8-8b-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-9a-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/linux/" rel="tag"># linux</a>
          
            <a href="/tags/多线程通讯/" rel="tag"># 多线程通讯</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/05/01/ug-e4-ba-8c-e6-ac-a1-e5-bc-80-e5-8f-91ugvs2013-e7-9a-84-e9-85-8d-e7-bd-ae/" rel="next" title="[UG二次开发]UG+VS2013 的配置">
                <i class="fa fa-chevron-left"></i> [UG二次开发]UG+VS2013 的配置
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/05/03/python-e8-bd-ac-e8-bd-bd-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab-1-e7-bb-99-e6-88-91-e4-b8-80-e4-b8-aa-e7-90-86-e7-94-b1-e5-85-88/" rel="prev" title="[Python][转载] 科学计算：Python VS. MATLAB (1)----给我一个理由先">
                [Python][转载] 科学计算：Python VS. MATLAB (1)----给我一个理由先 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/11661760?s=460&v=4"
               alt="kido zhang" />
          <p class="site-author-name" itemprop="name">kido zhang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">113</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">78</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kidozh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/331837926Ji" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kidozh" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/kidozh" target="_blank" title="douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      douban
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/kidozh" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 &mdash; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kido zhang</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Pisces
    </a>
  </div>


        







        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
