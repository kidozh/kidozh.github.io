<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Python,sqlalchemy," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="前言『关系』是关系型数据库的一大特色，也是我们在建模过程中的一个重要的抽象过程。在前面的两个教程中，我们分别回顾了使用SQLAlchemy在数据库中进行创建和简单查询的方法，今天我们来深入到更为复杂和抽象部分。 建立关系之前我们已经建立了一个用户(User)表，现在我们来考虑增加一个与用户关联的新的表。在我们的系统里面，用户可以存储多个与之相关的email地址。这是一种基本的一对多的关系。我们把这">
<meta name="keywords" content="Python,sqlalchemy">
<meta property="og:type" content="article">
<meta property="og:title" content="SQLAlchemy关系">
<meta property="og:url" content="https://kidozh.github.io/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/index.html">
<meta property="og:site_name" content="kidozh">
<meta property="og:description" content="前言『关系』是关系型数据库的一大特色，也是我们在建模过程中的一个重要的抽象过程。在前面的两个教程中，我们分别回顾了使用SQLAlchemy在数据库中进行创建和简单查询的方法，今天我们来深入到更为复杂和抽象部分。 建立关系之前我们已经建立了一个用户(User)表，现在我们来考虑增加一个与用户关联的新的表。在我们的系统里面，用户可以存储多个与之相关的email地址。这是一种基本的一对多的关系。我们把这">
<meta property="og:updated_time" content="2018-05-21T05:56:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SQLAlchemy关系">
<meta name="twitter:description" content="前言『关系』是关系型数据库的一大特色，也是我们在建模过程中的一个重要的抽象过程。在前面的两个教程中，我们分别回顾了使用SQLAlchemy在数据库中进行创建和简单查询的方法，今天我们来深入到更为复杂和抽象部分。 建立关系之前我们已经建立了一个用户(User)表，现在我们来考虑增加一个与用户关联的新的表。在我们的系统里面，用户可以存储多个与之相关的email地址。这是一种基本的一对多的关系。我们把这">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kidozh.github.io/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/"/>





  <title>SQLAlchemy关系 | kidozh</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kidozh</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">某不科学的kidozh</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-project">
          <a href="/projects/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            我的项目
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cv">
          <a href="/kidozh-cv/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            我的简历
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/11661760?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">SQLAlchemy关系</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-05T04:20:42+08:00">
                2016-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>『关系』是关系型数据库的一大特色，也是我们在建模过程中的一个重要的抽象过程。在前面的两个教程中，我们分别回顾了使用SQLAlchemy在数据库中进行<a href="http://www.jianshu.com/p/0d234e14b5d3" target="_blank" rel="external">创建</a>和<a href="http://www.jianshu.com/p/8d085e2f2657" target="_blank" rel="external">简单查询</a>的方法，今天我们来深入到更为复杂和抽象部分。</p>
<h1 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h1><p>之前我们已经建立了一个用户(User)表，现在我们来考虑增加一个与用户关联的新的表。在我们的系统里面，用户可以存储多个与之相关的email地址。这是一种基本的一对多的关系。我们把这个新增加的存储email地址的表称为<code>addresses</code>。应用Declarative，我们按照如下方式定义这个新表：</p>
<pre><code>&gt;&gt;&gt; from sqlalchemy import ForeignKey
&gt;&gt;&gt; from sqlalchemy.orm import relationship

&gt;&gt;&gt; class Address(Base):
...     __tablename__ = &apos;addresses&apos;
...     id = Column(Integer, primary_key=True)
...     email_address = Column(String, nullable=False)
...     user_id = Column(Integer, ForeignKey(&apos;users.id&apos;))
...
...     user = relationship(&quot;User&quot;, back_populates=&quot;addresses&quot;)
...
...     def __repr__(self):
...         return &quot;&lt;Address(email_address=&apos;%s&apos;)&gt;&quot; % self.email_address

&gt;&gt;&gt; User.addresses = relationship(
...     &quot;Address&quot;, order_by=Address.id, back_populates=&quot;user&quot;)`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">上面的代码中我们使用了一个新的名为`ForeignKey`的构造。其含义为，其所在的列的值域应当被限制在另一个表的指定列的取值范围之类。这一特性是关系型数据库的核心特性之一。就上例而言，`addresses.user_id`这一列的取值范围，应当包含在`users.id`的取值范围之内。</div><div class="line"></div><div class="line">除了`ForeignKey`之外，我们还引入了一个`relationship`，来告诉ORM，`Address`类需要被连接到`User`类。`relationship`和`ForeignKey`这个两个属性决定了表之间关系的属性，决定了这个关系是多对一的。</div><div class="line"></div><div class="line">在完成对`Address`类的声明之后，我们还定义另一个`relationship`，将其赋值给了`User.addresses`。在两个`relationship`中，我们都有传入了一个`relationship.back_populates`的属性来为反向关系所对应的属性进行命名。（作者：到这里为止，看来SQLAlchemy中定义关系要比Django的ORM要麻烦许多。Django中只需要一行就可以了。而且这里的两个`relationship`的定义明显是冗余的）</div><div class="line"></div><div class="line">多对一的关系的反向永远都是一对多的关系。关于更多的`relationship()`的配置方法，可以参见这个链接[Basic Relationship Patterns](http://docs.sqlalchemy.org/en/rel_1_0/orm/basic_relationships.html#relationship-patterns)。</div><div class="line"></div><div class="line">上述我们定义的两个互补的关系`Address.user`和`User.addresses`被称为双向关系([bidirectional relationship](http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-bidirectional-relationship))，这是SQLAlchemy的核心特性这一。</div><div class="line"></div><div class="line">`relationship()`的参数配置中指向被连接的类的字符串，可以指向工程中任何位置所定义的，基于`declarative base`的类，而无先后之分。Declarative会在完成所有的映射以后的将这些字符串转换为适当的、实际使用的参数形式。</div><div class="line"></div><div class="line"># 使用关联对象</div><div class="line"></div><div class="line">现在，当我们创建一个`User`实例的时候，会同时创建一个空的`addresses`的collection。这个collection可能是多种类型，如list, set, 或是dictionary。默认情况下，其应当为一个Python列表。</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; jack = User(name=’jack’, fullname=’Jack Bean’, password=’gjffdd’)</p>
<pre><code>&gt;&gt;&gt; jack.addresses
[]`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">此时你可以自由的向这个列表里面插入`User`对象。</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt; jack.addresses = [
    ...                 Address(email_address=&#39;jack@google.com&#39;),
    ...                 Address(email_address=&#39;j25@yahoo.com&#39;)]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">当使用bidirectional relationship时，通过其中一个方向的关系（如上例）会自动出现在另一个方向的关系上。</div></pre></td></tr></table></figure></p>
<p>`&gt;&gt;&gt; jack.addresses[1]<br>    <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x41;&#x64;&#100;&#114;&#x65;&#115;&#115;&#x28;&#x65;&#109;&#97;&#x69;&#108;&#x5f;&#97;&#x64;&#x64;&#114;&#x65;&#x73;&#x73;&#x3d;&#39;&#x6a;&#x32;&#53;&#64;&#121;&#x61;&#x68;&#x6f;&#111;&#46;&#x63;&#111;&#109;&#x27;&#41;">&#x41;&#x64;&#100;&#114;&#x65;&#115;&#115;&#x28;&#x65;&#109;&#97;&#x69;&#108;&#x5f;&#97;&#x64;&#x64;&#114;&#x65;&#x73;&#x73;&#x3d;&#39;&#x6a;&#x32;&#53;&#64;&#121;&#x61;&#x68;&#x6f;&#111;&#46;&#x63;&#111;&#109;&#x27;&#41;</a></p>
<pre><code>&gt;&gt;&gt; jack.addresses[1].user
&lt;User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, password=&apos;gjffdd&apos;)&gt;`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">让我们把jack添加进入`Session`。</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; session.add(jack)</p>
<pre><code>&gt;&gt;&gt; session.commit()
INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
(&apos;jack&apos;, &apos;Jack Bean&apos;, &apos;gjffdd&apos;)
INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
(&apos;jack@google.com&apos;, 5)
INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
(&apos;j25@yahoo.com&apos;, 5)
COMMIT`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">可以发现上面执行了三个`INSERT`命令，也就是说与jack关联的两个`Address`对象也被提交了。现在我们通过查询来取出jack。</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; jack = session.query(User).\<br>    … filter_by(name=’jack’).one()<br>    BEGIN (implicit)<br>    SELECT users.id AS users_id,<br>            users.name AS users_name,<br>            users.fullname AS users_fullname,<br>            users.password AS users_password<br>    FROM users<br>    WHERE users.name = ?<br>    (‘jack’,)</p>
<pre><code>&gt;&gt;&gt; jack
&lt;User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, password=&apos;gjffdd&apos;)&gt;`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">可以发现目前只有针对`User`表的查询，而没有对`Address`表的查询。此时访问`addresses`属性，相关的SQL才会执行</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt; jack.addresses
    SELECT addresses.id AS addresses_id,
            addresses.email_address AS
            addresses_email_address,
            addresses.user_id AS addresses_user_id
    FROM addresses
    WHERE ? = addresses.user_id ORDER BY addresses.id
    (5,)
    [&lt;Address(email_address=&#39;jack@google.com&#39;)&gt;, &lt;Address(email_address=&#39;j25@yahoo.com&#39;)&gt;]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">上面这种方式我们称之为[lazy loading](http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-lazy-loading)。</div><div class="line"></div><div class="line"># 使用join进行查询</div><div class="line"></div><div class="line">现在我们有了两会在那个彼此关联的数据表了，相比与上一篇教程中的简单查询情况，此时试图对这两张表进行联合查询就更加复杂一些了。关于join技术，读者可以自行阅读[我的前一篇文章](http://www.jianshu.com/p/9e1d3793cba6)。</div><div class="line"></div><div class="line">为了在`User`和`Address`之间构造一个简单的join，我们可以通过`Query.filter()`来连接其相关列（本质是隐式写法的JOIN）。下面是一个简单的例子：</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; for u, a in session.query(User, Address).\
    ...                     filter(User.id==Address.user_id).\
    ...                     filter(Address.email_address==&#39;jack@google.com&#39;).\
    ...                     all():
    ...     print(u)
    ...     print(a)
    &lt;User(name=&#39;jack&#39;, fullname=&#39;Jack Bean&#39;, password=&#39;gjffdd&#39;)&gt;
    &lt;Address(email_address=&#39;jack@google.com&#39;)&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">而实际的SQL JOIN语法，可以通过`Query.join()`来想实现</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; session.query(User).join(Address).\
    ...         filter(Address.email_address==&#39;jack@google.com&#39;).\
    ...         all()
    users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users JOIN addresses ON users.id = addresses.user_id
    WHERE addresses.email_address = ?
    (&#39;jack@google.com&#39;,)
    [&lt;User(name=&#39;jack&#39;, fullname=&#39;Jack Bean&#39;, password=&#39;gjffdd&#39;)&gt;]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">在上面的例子中由于只存在一个ForeignKey，`Query.join`知道如何选取合适的列进行JOIN。如果没有定义ForeignKey，或者存在多个，此时你需要手动指明你参与JOIN的列。`Query.join()`以如下方式进行：</div></pre></td></tr></table></figure></p>
<p><code>query.join(Address, User.id==Address.user_id)    # explicit condition
    query.join(User.addresses)                       # specify relationship from left to right
    query.join(Address, User.addresses)              # same, with explicit target
    query.join(&#39;addresses&#39;)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">对于OUTER JOIN，只需要使用`Query.outerjoin()`就可以了。</div></pre></td></tr></table></figure></p>
<p><code>query.outerjoin(User.addresses)   # LEFT OUTER JOIN</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">关于`join()`更为详细的用法，还是请参考官方的文档[join](http://docs.sqlalchemy.org/en/rel_1_0/orm/query.html#sqlalchemy.orm.query.Query.join)</div><div class="line"></div><div class="line">## 使用Aliases</div><div class="line"></div><div class="line">当你的查询涉及多个表，而其中同一个表出现了多次时，你需要的为重复的表aliase一个新的名字来避免冲突。这个功能其实我们在上一篇文章里面也提到过，下面是关于`aliased`的一个例子：</div></pre></td></tr></table></figure></p>
<p>`&gt;&gt;&gt; from sqlalchemy.orm import aliased</p>
<pre><code>&gt;&gt;&gt; adalias1 = aliased(Address)
&gt;&gt;&gt; adalias2 = aliased(Address)
&gt;&gt;&gt; for username, email1, email2 in \
...     session.query(User.name, adalias1.email_address, adalias2.email_address).\
...     join(adalias1, User.addresses).\
...     join(adalias2, User.addresses).\
...     filter(adalias1.email_address==&apos;jack@google.com&apos;).\
...     filter(adalias2.email_address==&apos;j25@yahoo.com&apos;):
...     print(username, email1, email2)
SELECT users.name AS users_name,
        addresses_1.email_address AS addresses_1_email_address,
        addresses_2.email_address AS addresses_2_email_address
FROM users JOIN addresses AS addresses_1
        ON users.id = addresses_1.user_id
JOIN addresses AS addresses_2
        ON users.id = addresses_2.user_id
WHERE addresses_1.email_address = ?
        AND addresses_2.email_address = ?
(&apos;jack@google.com&apos;, &apos;j25@yahoo.com&apos;)
jack jack@google.com j25@yahoo.com`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 使用子查询(Subqueries)</div><div class="line"></div><div class="line">`Query`适合于用来构造子查询。假如我们想要取出`User`记录，并且同时计算各个用户的`Address`的数量。产生这种功能的SQL指令最好的办法是按照user的id分组统计地址的数量，然后join到外层查询。此时我们需要LEFT JOIN，这样可以使得没有地址的用户也会出现在查询结果中（地址数量为0）。 我们期望的SQL命令是这样的：</div></pre></td></tr></table></figure>
<p><code>SELECT users.*, adr_count.address_count FROM users LEFT OUTER JOIN
        (SELECT user_id, count(*) AS address_count
            FROM addresses GROUP BY user_id) AS adr_count
        ON users.id=adr_count.user_id</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">使用`Query`，我们可以从内到外来构造上面的语句。</div></pre></td></tr></table></figure></p>
<p>`&gt;&gt;&gt; from sqlalchemy.sql import func</p>
<pre><code>&gt;&gt;&gt; stmt = session.query(Address.user_id, func.count(&apos;*&apos;).\
...         label(&apos;address_count&apos;)).\
...         group_by(Address.user_id).subquery()`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">`func`我们已经在之前的教程中认识过了。`subquery()`可以产生一个内嵌了alias（是一个`query.statement.alias()`）的查询(SELECT)语句的表达。</div><div class="line"></div><div class="line">当我们生成了statement之后，其完全可以视为一个`Table`来使用。你可以通过`c`来访问它的属性。</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt; for u, count in session.query(User, stmt.c.address_count).\
    ...     outerjoin(stmt, User.id==stmt.c.user_id).order_by(User.id):
    ...     print(u, count)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            anon_1.address_count AS anon_1_address_count
    FROM users LEFT OUTER JOIN
        (SELECT addresses.user_id AS user_id, count(?) AS address_count
        FROM addresses GROUP BY addresses.user_id) AS anon_1
        ON users.id = anon_1.user_id
    ORDER BY users.id
    (&#39;*&#39;,)
    &lt;User(name=&#39;ed&#39;, fullname=&#39;Ed Jones&#39;, password=&#39;f8s7ccs&#39;)&gt; None
    &lt;User(name=&#39;wendy&#39;, fullname=&#39;Wendy Williams&#39;, password=&#39;foobar&#39;)&gt; None
    &lt;User(name=&#39;mary&#39;, fullname=&#39;Mary Contrary&#39;, password=&#39;xxg527&#39;)&gt; None
    &lt;User(name=&#39;fred&#39;, fullname=&#39;Fred Flinstone&#39;, password=&#39;blah&#39;)&gt; None
    &lt;User(name=&#39;jack&#39;, fullname=&#39;Jack Bean&#39;, password=&#39;gjffdd&#39;)&gt; 2</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 从子查询中取出Entity</div><div class="line"></div><div class="line">在前一个例子中，我们从子查询活着的是一个临时性的JOIN后的表，但是这个表并未定义我们在ORM中定义的Entity。如果我们想将这个临时表映射到ORM中的类呢？此时我们可以使用`aliased`这个函数来完成这个映射。</div></pre></td></tr></table></figure></p>
<p>`&gt;&gt;&gt; stmt = session.query(Address).\<br>    …                 filter(Address.email_address != ‘j25@yahoo.com’).\<br>    …                 subquery()</p>
<pre><code>&gt;&gt;&gt; adalias = aliased(Address, stmt)
&gt;&gt;&gt; for user, address in session.query(User, adalias).\
...         join(adalias, User.addresses):
...     print(user)
...     print(address)
SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            anon_1.id AS anon_1_id,
            anon_1.email_address AS anon_1_email_address,
            anon_1.user_id AS anon_1_user_id
FROM users JOIN
    (SELECT addresses.id AS id,
            addresses.email_address AS email_address,
            addresses.user_id AS user_id
    FROM addresses
    WHERE addresses.email_address != ?) AS anon_1
    ON users.id = anon_1.user_id
(&apos;j25@yahoo.com&apos;,)
&lt;User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, password=&apos;gjffdd&apos;)&gt;
&lt;Address(email_address=&apos;jack@google.com&apos;)&gt;`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># 使用EXISTS</div><div class="line"></div><div class="line">EXISTS关键字是一个BOOL型操作符。当查询结果存在至少一行时返回True。EXISTS可以常常和JOIN搭配使用。</div><div class="line"></div><div class="line">下面是一个显式的EXISTS构造方法：</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; from sqlalchemy.sql import exists</p>
<pre><code>&gt;&gt;&gt; stmt = exists().where(Address.user_id==User.id)
&gt;&gt;&gt; for name, in session.query(User.name).filter(stmt):
...     print(name)
SELECT users.name AS users_name
FROM users
WHERE EXISTS (SELECT *
FROM addresses
WHERE addresses.user_id = users.id)
()
jack`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">`Query`还定义了若干个自动使用了EXISTS的操作。上面的例子可以用`any()`来完成：</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt; for name, in session.query(User.name).\
    ...         filter(User.addresses.any()):
    ...     print(name)
    SELECT users.name AS users_name
    FROM users
    WHERE EXISTS (SELECT 1
    FROM addresses
    WHERE users.id = addresses.user_id)
    ()
    jack</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">`any()`也接受筛选条件来限制匹配的行：</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; for name, in session.query(User.name).\
    ...     filter(User.addresses.any(Address.email_address.like(&#39;%google%&#39;))):
    ...     print(name)
    jack</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">`has()`对于的many-to-one的关系，起到的是和`any()`同样的作用（注意这里`~`表示NOT）：</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; session.query(Address).\
    ...         filter(~Address.user.has(User.name==&#39;jack&#39;)).all()
    []</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">    ## 常用的关系操作</div><div class="line"></div><div class="line">    下面只是简单的列出了一些常用的操作。想要更为详细的了解这些功能，还是推荐去官网的相关文档。</div><div class="line"></div><div class="line">*   **eq**() (many-to-one “equals” comparison):</div></pre></td></tr></table></figure></p>
<p><code>query.filter(Address.user == someuser)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">*   **ne**() (many-to-one “not equals” comparison):</div></pre></td></tr></table></figure></p>
<p><code>query.filter(Address.user != someuser)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">*   IS NULL (many-to-one comparison, also uses **eq**()):</div></pre></td></tr></table></figure></p>
<p><code>query.filter(Address.user == None)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">*   contains() (used for one-to-many collections):</div></pre></td></tr></table></figure></p>
<p><code>query.filter(User.addresses.contains(someaddress))</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">*   any() (used for collections):</div></pre></td></tr></table></figure></p>
<p>`query.filter(User.addresses.any(Address.email_address == ‘bar’))</p>
<pre><code># also takes keyword arguments:
query.filter(User.addresses.any(email_address=&apos;bar&apos;))`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">*   has() (used for scalar references):</div></pre></td></tr></table></figure>
<p><code>query.filter(Address.user.has(name=&#39;ed&#39;))</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">*   Query.with_parent() (used for any relationship):</div></pre></td></tr></table></figure></p>
<p><code>session.query(Address).with_parent(someuser, &#39;addresses&#39;)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## Eager Loading（找不到合适的翻译）</div><div class="line"></div><div class="line">前面的教程中我们有提及到lazing loading的机制。当我们通过查询取出用户时，与之关联的地址并没有取出来。当我们试图获取`User.addresses`时，相关的针对地址的SQL查询才起作用。如果你想要减少query的次数的话，就需要使用Eager Loading了。SQLAlchemy提供了三种Eager Loading的方式，其中两种是自动的，而第三种涉及到自定义的筛选条件。所有的这三种Eager Loading方式都会通过调用`Query.options()`来影响查询的过程，促使`Query`生成需要的额外配置来取出期望的内容。</div><div class="line"></div><div class="line"># Subquery Loading</div><div class="line"></div><div class="line">在上面的例子中，我们希望在 取出用户的时候就同步取出对应的地址。此时你们可以此采用`orm.subqueryload()`。这个函数可以发起第二个SELECT查询来取出与结果相关的另一个表的信息。这里取名为&quot;subquery&quot;的原因是，此处的`Query`在发起第二个查询时作为子查询而被复用了。详细过程参加下面的程序：</div></pre></td></tr></table></figure></p>
<p>`&gt;&gt;&gt; from sqlalchemy.orm import subqueryload</p>
<pre><code>&gt;&gt;&gt; jack = session.query(User).\
...                 options(subqueryload(User.addresses)).\
...                 filter_by(name=&apos;jack&apos;).one()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users
WHERE users.name = ?
(&apos;jack&apos;,)
SELECT addresses.id AS addresses_id,
        addresses.email_address AS addresses_email_address,
        addresses.user_id AS addresses_user_id,
        anon_1.users_id AS anon_1_users_id
FROM (SELECT users.id AS users_id
    FROM users WHERE users.name = ?) AS anon_1
JOIN addresses ON anon_1.users_id = addresses.user_id
ORDER BY anon_1.users_id, addresses.id
(&apos;jack&apos;,)
&gt;&gt;&gt; jack
&lt;User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, password=&apos;gjffdd&apos;)&gt;

&gt;&gt;&gt; jack.addresses
[&lt;Address(email_address=&apos;jack@google.com&apos;)&gt;, &lt;Address(email_address=&apos;j25@yahoo.com&apos;)&gt;]`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">**注意**：当`subqueryload()`和涉及limiting的函数一起使用的时候（如`Query.first()`, `Query.limit()`, Query.offset()`等），应当加上一个以Unique的行作为参数的`Query.order_by()`来确保结果的正确性。详情参见[The importance of Ordering](http://docs.sqlalchemy.org/en/rel_1_0/orm/loading_relationships.html#subqueryload-ordering)</div><div class="line"></div><div class="line"># Joined Load</div><div class="line"></div><div class="line">这种自动Eager Loading的方式要更为常用一些。Joined Loading发起了一个JOIN（默认是LEFT OUTER JOIN），故而查询结果和制定的与之关联的行可以被同时取出。我们这里以和上面的Subquery Loading中同样的查询目的为例。</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; from sqlalchemy.orm import joinedload</p>
<pre><code>&gt;&gt;&gt; jack = session.query(User).\
...                        options(joinedload(User.addresses)).\
...                        filter_by(name=&apos;jack&apos;).one()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        addresses_1.id AS addresses_1_id,
        addresses_1.email_address AS addresses_1_email_address,
        addresses_1.user_id AS addresses_1_user_id
FROM users
    LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id
WHERE users.name = ? ORDER BY addresses_1.id
(&apos;jack&apos;,)

&gt;&gt;&gt; jack
&lt;User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, password=&apos;gjffdd&apos;)&gt;

&gt;&gt;&gt; jack.addresses
[&lt;Address(email_address=&apos;jack@google.com&apos;)&gt;, &lt;Address(email_address=&apos;j25@yahoo.com&apos;)&gt;]`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">注意到，如果你是在命令行运行了前一个Subquery Loading的例子的话，在这里jack的addresses实际上已经填充了的，但是这里的Joined Load仍然是会发起JOIN。另外，LEFT OUTER JOIN指令实际上有可能导致重复的User出现，但是在结果中实际得到的User却不会重复。这是因为`Query`实际上是基于Object Identity采用了一种&quot;uniquing&quot;的策略。</div><div class="line"></div><div class="line">历史上来看`joinedload()`出现的更早一些。`joinedloading()`更加适合于处理Many-to-one的关系。</div><div class="line"></div><div class="line"># 显式的Join + EagerLoad</div><div class="line"></div><div class="line">第三种方式我们是我们自己显式的调用join来定位JOIN连接主键，并接着关联表的信息填充到查询结果中对应对象或者列表中。这个特性需要使用到`orm.contains_eager()`函数。这个机制最典型的用途是pre-loading many-to-one关系，同时添加对这个关系的筛选。我们用下面的这个例子来阐述说明上面这些比较绕的话。假设我们需要筛选出用户的名字为jack的邮件地址，进行这个查询的方法如下：</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; from sqlalchemy.orm import contains_eager</p>
<pre><code>&gt;&gt;&gt; jacks_addresses = session.query(Address).\
...                             join(Address.user).\
...                             filter(User.name==&apos;jack&apos;).\
...                             options(contains_eager(Address.user)).\
...                             all()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        addresses.id AS addresses_id,
        addresses.email_address AS addresses_email_address,
        addresses.user_id AS addresses_user_id
FROM addresses JOIN users ON users.id = addresses.user_id
WHERE users.name = ?
(&apos;jack&apos;,)

&gt;&gt;&gt; jacks_addresses
[&lt;Address(email_address=&apos;jack@google.com&apos;)&gt;, &lt;Address(email_address=&apos;j25@yahoo.com&apos;)&gt;]

&gt;&gt;&gt; jacks_addresses[0].user
&lt;User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, password=&apos;gjffdd&apos;)&gt;`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 关系中的删除问题</div><div class="line"></div><div class="line">沃恩尝试删除jack，来看结果：</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; session.delete(jack)</p>
<pre><code>&gt;&gt;&gt; session.query(User).filter_by(name=&apos;jack&apos;).count()
UPDATE addresses SET user_id=? WHERE addresses.id = ?
((None, 1), (None, 2))
DELETE FROM users WHERE users.id = ?
(5,)
SELECT count(*) AS count_1
FROM (SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users
WHERE users.name = ?) AS anon_1
(&apos;jack&apos;,)
0`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">那么与jack关联的地址呢？</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt; session.query(Address).filter(
    ...     Address.email_address.in_([&#39;jack@google.com&#39;, &#39;j25@yahoo.com&#39;])
    ...  ).count()
    2</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">地址记录仍然在这里。如果我们commit的话，我们可以从上面的SQL语句中发现，相关的`Address`的`user_id`属性被设置成了NULL。这不符合我们的要求。那么我们需要自己来设置关系的删除规则。</div><div class="line"></div><div class="line">## 配置delete/delete-orphan Cascade</div><div class="line"></div><div class="line">我们通过配置`User.addresses`关系的**cascade***选项来控制删除行为。尽管SQLAlchemy允许你在任何时候给ORM添加属性或者关系。此时我们还是需要移除现存的关系并且重新开始（作者：django的ORM包含）。让我们首先关闭当前的session</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; session.close()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">并且使用一个新的`declarative_base()`:</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; Base = declarative_base()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">下面我们重新声明`User`类，注意`addresses`中的配置：</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; class User(Base):
    ...     __tablename__ = &#39;users&#39;
    ...
    ...     id = Column(Integer, primary_key=True)
    ...     name = Column(String)
    ...     fullname = Column(String)
    ...     password = Column(String)
    ...
    ...     addresses = relationship(&quot;Address&quot;, back_populates=&#39;user&#39;,
    ...                     cascade=&quot;all, delete, delete-orphan&quot;)
    ...
    ...     def __repr__(self):
    ...        return &quot;&lt;User(name=&#39;%s&#39;, fullname=&#39;%s&#39;, password=&#39;%s&#39;)&gt;&quot; % (
    ...                                self.name, self.fullname, self.password)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">接下来重新声明`Address`。</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; class Address(Base):
    ...     __tablename__ = &#39;addresses&#39;
    ...     id = Column(Integer, primary_key=True)
    ...     email_address = Column(String, nullable=False)
    ...     user_id = Column(Integer, ForeignKey(&#39;users.id&#39;))
    ...     user = relationship(&quot;User&quot;, back_populates=&quot;addresses&quot;)
    ...
    ...     def __repr__(self):
    ...         return &quot;&lt;Address(email_address=&#39;%s&#39;)&gt;&quot; % self.email_address</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">现在让我们取出jack(下面我们使用了一个之前没有提到的函数`get()`，其参数为查询目标的主键)，现在从`addresses`中删除一个地址的话，会导致这个`Address`被删除。</div></pre></td></tr></table></figure></p>
<p>`# load Jack by primary key<br>    SQL&gt;&gt;&gt; jack = session.query(User).get(5)</p>
<pre><code># remove one Address (lazy load fires off)
SQL&gt;&gt;&gt; del jack.addresses[1]

# only one address remains
SQL&gt;&gt;&gt; session.query(Address).filter(
...     Address.email_address.in_([&apos;jack@google.com&apos;, &apos;j25@yahoo.com&apos;])
... ).count()
1`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">删除jack也会导致剩下jack以及其所有的`Address`都会被删除:</div></pre></td></tr></table></figure>
<p>`&gt;&gt; session.delete(jack)</p>
<pre><code>SQL&gt;&gt;&gt; session.query(User).filter_by(name=&apos;jack&apos;).count()
0

SQL&gt;&gt;&gt; session.query(Address).filter(
...    Address.email_address.in_([&apos;jack@google.com&apos;, &apos;j25@yahoo.com&apos;])
... ).count()
0`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">关于更多的Cascade配置请参见官方文档。</div><div class="line"></div><div class="line">## 建立多对多关系ManyToMany Relationship</div><div class="line"></div><div class="line">现在我们需要引入一个新的模型来阐述多对多的关系了。假设我们需要完成一个博客应用。在这个应用里面我们可以书写`BlogPost`，每个博客都有若干`Keyword`。</div><div class="line"></div><div class="line">对于一个多对多的关系，我们需要建立一个未映射的（也就是没有一个Python类与之对应的）表`Table`来作为中间联系的表。</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; from sqlalchemy import Table, Text</p>
<pre><code>&gt;&gt;&gt; # association table
&gt;&gt;&gt; post_keywords = Table(&apos;post_keywords&apos;, Base.metadata,
...     Column(&apos;post_id&apos;, ForeignKey(&apos;posts.id&apos;), primary_key=True),
...     Column(&apos;keyword_id&apos;, ForeignKey(&apos;keywords.id&apos;), primary_key=True)
... )`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">不同于我们之前的典型的ORM方法，在上面的代码中我们直接声明了一个`Table`，而没有制定与之对应的Python类。`Table`是一个构造函数，其参数中的每个`Colomn`以逗号分隔。</div><div class="line"></div><div class="line">下面我们来定义`BlogPost`和`Keyword`。我们这里需要使用`relationship()`在这两个类中定义一对互补的关系，其中每个关系的都指向`post_keyword`这个表。</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; class BlogPost(Base):<br>    …     <strong>tablename</strong> = ‘posts’<br>    …<br>    …     id = Column(Integer, primary_key=True)<br>    …     user_id = Column(Integer, ForeignKey(‘users.id’))<br>    …     headline = Column(String(255), nullable=False)<br>    …     body = Column(Text)<br>    …<br>    …     # many to many BlogPost&lt;-&gt;Keyword<br>    …     keywords = relationship(‘Keyword’,<br>    …                             secondary=post_keywords,<br>    …                             back_populates=’posts’)<br>    …<br>    …     def <strong>init</strong>(self, headline, body, author):<br>    …         self.author = author<br>    …         self.headline = headline<br>    …         self.body = body<br>    …<br>    …     def <strong>repr</strong>(self):<br>    …         return “BlogPost(%r, %r, %r)” % (self.headline, self.body, self.author)</p>
<pre><code>&gt;&gt;&gt; class Keyword(Base):
...     __tablename__ = &apos;keywords&apos;
...
...     id = Column(Integer, primary_key=True)
...     keyword = Column(String(50), nullable=False, unique=True)
...     posts = relationship(&apos;BlogPost&apos;,
...                          secondary=post_keywords,
...                          back_populates=&apos;keywords&apos;)
...
...     def __init__(self, keyword):
...         self.keyword = keyword`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">在上面的定义中，我们可以发现和OneToMany关系不同，`relationship()`中多了一个`secondary`的参数，这个参数指向了中间表(原文为associated table)。这个中间表只包含了指向多对多关系两侧的表的主键的列。如果这个表包含了其他属性，甚至是自身的主键，SQLAlchemy需要你使用另一种，称为`association object`的机制来处理。</div><div class="line"></div><div class="line">我们还希望我们的`BlogPost`能够拥有一个`author`属性，这个属性指向我们先前定义的`User`。此时我们需要再定义一个双向关系。由于一个作者可能拥有很多文章，我们希望访问`User.posts`的时候可以加以筛选而不是载入全部的相关文章。为此我们在定义`User.posts`中的时候，设置`lazy=&apos;dynamic&apos;`，来控制载入策略。</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; BlogPost.author = relationship(User, back_populates=”posts”)</p>
<pre><code>&gt;&gt;&gt; User.posts = relationship(BlogPost, back_populates=&quot;author&quot;, lazy=&quot;dynamic&quot;)`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">然后让我们来创建数据库中对应的表</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt; Base.metadata.create_all(engine)
    PRAGMA...
    CREATE TABLE keywords (
        id INTEGER NOT NULL,
        keyword VARCHAR(50) NOT NULL,
        PRIMARY KEY (id),
        UNIQUE (keyword)
    )
    ()
    COMMIT
    CREATE TABLE posts (
        id INTEGER NOT NULL,
        user_id INTEGER,
        headline VARCHAR(255) NOT NULL,
        body TEXT,
        PRIMARY KEY (id),
        FOREIGN KEY(user_id) REFERENCES users (id)
    )
    ()
    COMMIT
    CREATE TABLE post_keywords (
        post_id INTEGER NOT NULL,
        keyword_id INTEGER NOT NULL,
        PRIMARY KEY (post_id, keyword_id),
        FOREIGN KEY(post_id) REFERENCES posts (id),
        FOREIGN KEY(keyword_id) REFERENCES keywords (id)
    )
    ()
    COMMIT</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">多对多关系的使用方法道也没有太大的不同之处。让我们先来给windy添加博文。</div></pre></td></tr></table></figure></p>
<p>`&gt;&gt;&gt; wendy = session.query(User).\<br>    …                 filter_by(name=’wendy’).\<br>    …                 one()</p>
<pre><code>&gt;&gt;&gt; post = BlogPost(&quot;Wendy&apos;s Blog Post&quot;, &quot;This is a test&quot;, wendy)
&gt;&gt;&gt; session.add(post)`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">给博文添加一些关键字。目前数据库里面还没有关键字存在，我们创建一些：</div></pre></td></tr></table></figure>
<p>`&gt;&gt;&gt; post.keywords.append(Keyword(‘wendy’))</p>
<pre><code>&gt;&gt;&gt; post.keywords.append(Keyword(&apos;firstpost&apos;))`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">我们可以开始查询了。先以&apos;firstpost&apos;为关键字来检索所有的博文。我们使用`any`来查询拥有关键词&apos;firstpost&apos;的博文：</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt; session.query(BlogPost).\
    ...             filter(BlogPost.keywords.any(keyword=&#39;firstpost&#39;)).\
    ...             all()
    [BlogPost(&quot;Wendy&#39;s Blog Post&quot;, &#39;This is a test&#39;, &lt;User(name=&#39;wendy&#39;, fullname=&#39;Wendy Williams&#39;, password=&#39;foobar&#39;)&gt;)]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">如果我们希望将查询范围限制在wendy用户所拥有的博文之内，</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt; session.query(BlogPost).\
    ...             filter(BlogPost.author==wendy).\
    ...             filter(BlogPost.keywords.any(keyword=&#39;firstpost&#39;)).\
    ...             all()
    SELECT posts.id AS posts_id,
            posts.user_id AS posts_user_id,
            posts.headline AS posts_headline,
            posts.body AS posts_body
    FROM posts
    WHERE ? = posts.user_id AND (EXISTS (SELECT 1
        FROM post_keywords, keywords
        WHERE posts.id = post_keywords.post_id
            AND keywords.id = post_keywords.keyword_id
            AND keywords.keyword = ?))
    (2, &#39;firstpost&#39;)
    [BlogPost(&quot;Wendy&#39;s Blog Post&quot;, &#39;This is a test&#39;, &lt;User(name=&#39;wendy&#39;, fullname=&#39;Wendy Williams&#39;, password=&#39;foobar&#39;)&gt;)]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">或者我们可以直接在wendy的`posts`属性上进行查询：</div></pre></td></tr></table></figure></p>
<p>`&gt;&gt;&gt; wendy.posts.\<br>    …         filter(BlogPost.keywords.any(keyword=’firstpost’)).\<br>    …         all()<br>    [BlogPost(“Wendy’s Blog Post”, ‘This is a test’, <user(name='wendy', fullname="Wendy Williams" ,="" password="foobar" )="">)]</user(name='wendy',></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    kido zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kidozh.github.io/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/" title="SQLAlchemy关系">https://kidozh.github.io/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
            <a href="/tags/sqlalchemy/" rel="tag"># sqlalchemy</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/05/sqlalchemy-e6-9f-a5-e8-af-a2/" rel="next" title="SQLAlchemy查询">
                <i class="fa fa-chevron-left"></i> SQLAlchemy查询
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/14/abaqus-e6-a8-a1-e6-8b-9f-e8-9e-ba-e6-a0-93-e8-bf-9e-e6-8e-a5-e7-9a-84-e6-96-b9-e6-b3-95/" rel="prev" title="ABAQUS模拟螺栓连接的方法">
                ABAQUS模拟螺栓连接的方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/11661760?s=460&v=4"
               alt="kido zhang" />
          <p class="site-author-name" itemprop="name">kido zhang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">113</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">78</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kidozh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/331837926Ji" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kidozh" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/kidozh" target="_blank" title="douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      douban
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/kidozh" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#建立关系"><span class="nav-number">2.</span> <span class="nav-text">建立关系</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 &mdash; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kido zhang</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Pisces
    </a>
  </div>


        







        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
