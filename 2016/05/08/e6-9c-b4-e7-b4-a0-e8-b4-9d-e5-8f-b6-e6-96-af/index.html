<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Python,朴素贝叶斯,机器学习,概率," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="前言在机器学习之中，我们可以通过概率论来进行分类。最简单的就是朴素贝叶斯分类器了。 特点优点 可以处理多类别问题 在数据较少的情况依然有效  缺点对于输入数据的准备方式较为敏感 条件概率贝叶斯决策理论要求计算两个概率$$p1(c{1}|x,y)$$和$$p2(c{2}|x,y)$$：  当p1&amp;gt;p2时，那么这个事件属于1 当p1&amp;lt;p2时，那么这个事件属于2  过程 收集数据 准备数据">
<meta name="keywords" content="Python,朴素贝叶斯,机器学习,概率">
<meta property="og:type" content="article">
<meta property="og:title" content="朴素贝叶斯">
<meta property="og:url" content="https://kidozh.github.io/2016/05/08/e6-9c-b4-e7-b4-a0-e8-b4-9d-e5-8f-b6-e6-96-af/index.html">
<meta property="og:site_name" content="kidozh">
<meta property="og:description" content="前言在机器学习之中，我们可以通过概率论来进行分类。最简单的就是朴素贝叶斯分类器了。 特点优点 可以处理多类别问题 在数据较少的情况依然有效  缺点对于输入数据的准备方式较为敏感 条件概率贝叶斯决策理论要求计算两个概率$$p1(c{1}|x,y)$$和$$p2(c{2}|x,y)$$：  当p1&amp;gt;p2时，那么这个事件属于1 当p1&amp;lt;p2时，那么这个事件属于2  过程 收集数据 准备数据">
<meta property="og:updated_time" content="2018-05-21T05:56:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朴素贝叶斯">
<meta name="twitter:description" content="前言在机器学习之中，我们可以通过概率论来进行分类。最简单的就是朴素贝叶斯分类器了。 特点优点 可以处理多类别问题 在数据较少的情况依然有效  缺点对于输入数据的准备方式较为敏感 条件概率贝叶斯决策理论要求计算两个概率$$p1(c{1}|x,y)$$和$$p2(c{2}|x,y)$$：  当p1&amp;gt;p2时，那么这个事件属于1 当p1&amp;lt;p2时，那么这个事件属于2  过程 收集数据 准备数据">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kidozh.github.io/2016/05/08/e6-9c-b4-e7-b4-a0-e8-b4-9d-e5-8f-b6-e6-96-af/"/>





  <title>朴素贝叶斯 | kidozh</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kidozh</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">某不科学的kidozh</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2016/05/08/e6-9c-b4-e7-b4-a0-e8-b4-9d-e5-8f-b6-e6-96-af/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/11661760?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">朴素贝叶斯</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-08T17:17:23+08:00">
                2016-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在机器学习之中，我们可以通过概率论来进行分类。最简单的就是朴素贝叶斯分类器了。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>可以处理多类别问题</li>
<li>在数据较少的情况依然有效</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>对于输入数据的准备方式较为敏感</p>
<h1 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h1><p>贝叶斯决策理论要求计算两个概率$$p1(c<em>{1}|x,y)$$和$$p2(c</em>{2}|x,y)$$：</p>
<ul>
<li>当p1&gt;p2时，那么这个事件属于1</li>
<li>当p1&lt;p2时，那么这个事件属于2</li>
</ul>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol>
<li>收集数据</li>
<li>准备数据</li>
<li>分析数据：特征大的时候适用直方图效果更好</li>
<li>训练算法：计算不同独立特征下的条件概率</li>
<li>测试算法：计算错误率</li>
<li>适用算法</li>
</ol>
<p>假定每个特征需要$$N$$个样本，当我们需要研究$$M$$的时候，此时样本数提升到$$N^{M}$$个了。而当特征之间互相独立的时候，也就是一个特征或者单词出现的可能性和其他临近的单词没有关系的时候，样本数就从$$N^{M}$$降低到$$M*N$$个。</p>
<p>但是我们知道，这样的假设并不正确，因为”青菜”这个单词常出现在”难吃”附近但是很少出现在“垃圾食品”。并且贝叶斯的另一个假设就是，每种特征等值重要。当然这也是很Navie的。</p>
<h1 id="使用Python进行文本分类"><a href="#使用Python进行文本分类" class="headerlink" title="使用Python进行文本分类"></a>使用Python进行文本分类</h1><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>我们简述一下这个准备数据的过程。我们需要把文本看成是一个单词的向量。我们需要考虑出现再所有文档之中的所有的单词，然后考虑哪些词应该被纳入词汇表，这就是我们的数据准备方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></div><div class="line">    postingList = [</div><div class="line">        [<span class="string">'my'</span>,<span class="string">'dog'</span>,<span class="string">'has'</span>,<span class="string">'been'</span>,<span class="string">'lost'</span>],</div><div class="line">        [<span class="string">'you'</span>,<span class="string">'are'</span>,<span class="string">'to'</span>,<span class="string">'raped'</span>],</div><div class="line">    ]</div><div class="line">    classVec = [<span class="number">0</span>,<span class="number">1</span>] <span class="comment"># 1 代表侮辱词汇</span></div><div class="line">    <span class="keyword">return</span> postingList,classVec</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></div><div class="line">    vocabSet = set([])</div><div class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</div><div class="line">        vocabSet = vocabSet|set(document)</div><div class="line">        <span class="keyword">return</span> list(vocabSet)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList,inputSet)</span>:</span></div><div class="line">    <span class="comment"># vocabList: 词汇表</span></div><div class="line">    <span class="comment"># inputSet: 测试文档</span></div><div class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</div><div class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"word %s is not in my vocabulary"</span> %word</div><div class="line">    <span class="keyword">return</span> returnVec</div></pre></td></tr></table></figure></p>
<p> 第一个函数<code>loadDataSet()</code>创建了一个实验样本。该函数返回的第一个变量是进行词条切分后的文档集合，而第二个函数则是返回该词条向量是否有侮辱性的留言。</p>
<p>下一个函数<code>createVocabList()</code>则是会创建一个包含在所有文档中出现的不重复的列表，这里还使用了Python中的<code>set</code>。县创建一个空集合，然后将每篇文档返回的新词集合添加到该集合中，操作符|适用于求两个集合的并集。</p>
<p>获得词汇表之后，就可以使用函数<code>setOfWords2Vec()</code>。函数输入参数是词汇表以及某个文档，输出的是文档向量，函数首先会创建一个和词汇表等长的向量，并将其中的元素都设置为0.接着遍历文档中所有的词汇，若出现了词汇表之中的词汇则将输出的文档中的对应的值设置为1。</p>
<h1 id="训练算法"><a href="#训练算法" class="headerlink" title="训练算法"></a>训练算法</h1><p>这里训练主要使用的就是贝叶斯算法了，这里我们给上条件概率公式，这里w值得就是一个向量，由多个之组成：</p>
<p>[p(c<em>{i}|w) = \frac{p(w|c</em>{i})*p(c_{i})}{p(w)}]</p>
<p>我们是用这个公式计算每个类的值，并且比较这两个概率之的大小。在这里使用朴素贝叶斯假设，将$$w$$展开成一个个独立的特征，进而使用连乘的方式计算上述概率，这样救能够简化计算的过程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCategory)</span>:</span></div><div class="line">    numTrainDocs = len(trainMatrix)</div><div class="line">    numWords = len(trainMatrix[<span class="number">0</span>])</div><div class="line">    pAbusive = sum(trainCategory)/float(numTrainDocs)</div><div class="line">    <span class="comment"># init ratio</span></div><div class="line">    p0Num = zeros(numWords)</div><div class="line">    p1Num = zeros(numWords)</div><div class="line">    p0Denom = <span class="number">0.0</span></div><div class="line">    p1Denom = <span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</div><div class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</div><div class="line">            <span class="comment"># if this sentence bingo , then increase every words' value</span></div><div class="line">            p1Num += trainMatrix[i]</div><div class="line">            p1Denom +=sum(trainMatrix[i])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            p0Num += trainMatrix[i]</div><div class="line">            p0Denom +=sum(trainMatrix[i])</div><div class="line">    <span class="comment"># divide each element</span></div><div class="line">    p1Vect = p1Num/p1Denom</div><div class="line">    p0Vect = p0Num/p0Denom</div><div class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</div></pre></td></tr></table></figure></p>
<p> 这里还使用了<code>numpy</code>的<code>zeros</code>这个函数。</p>
<p>代码之中输入的参数就是文档矩阵<code>trainMatrix</code>，以及每片文档类别所构成的向量<code>trainCategory</code>。首先计算文档属于侮辱性文档的概率，也就是$$P(1)$$。因为这是一个对立问题，所以$$P(0) = 1-P(1)$$。<strong>对于其他分类问题则需要稍加修改</strong>。</p>
<p>计算$$p(w<em>{i}|c</em>{1})$$和$$p(w<em>{i}|c</em>{0})$$，需要初始化程序之中的分子和分母变量。由于w中元素很多，所以使用NumPy数组快速计算这些值。在for循环之中需要遍历训练集<code>trainMatrix</code>中的所有文档。一单某个词汇在某一文档中出现，则对应的个数（p1Num或者p0Num）就加1，而且在所有的文档之中，该文档的总次数也相应+1.</p>
<p>最后，对每一个元素除以该类别的总次数。利用NumPy可以很好实现，用一个数组除以浮点数即可。</p>
<h1 id="训练算法-1"><a href="#训练算法-1" class="headerlink" title="训练算法"></a>训练算法</h1><p>利用贝叶斯分类器对文档进行分类的时候，当连乘出现的时候，如果其中的一个概率值为0，那么最终的成绩也是0，为了降低这种影响，可以把所有的词出现数初始化为1，并将分母初始化为2。</p>
<p>这里需要把<code>trainNB0()</code>修改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># update alogrithm</span></div><div class="line">    p0Num = ones(numWords)</div><div class="line">    p1Num = ones(numWords)</div><div class="line">    p0Denom = <span class="number">2.0</span></div><div class="line">    p1Denom = <span class="number">2.0</span></div></pre></td></tr></table></figure></p>
<p> 另一个问题就是向下溢出，这是由于太多很小的数想乘造成的，当计算连乘的时候，由于大部分的因子都太小，只是Python有可能发生四舍五入为0的情况，所以可以通过球自然对数来避免下溢出或者浮点数舍入所造成的误差。而且自然对数也不会造成精度上的缺失。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># divide each element</span></div><div class="line">    p1Vect = log(p1Num/p1Denom)</div><div class="line">    p0Vect = log(p0Num/p0Denom)</div></pre></td></tr></table></figure></p>
<p> 所以简单的贝叶斯分类函数就是这样的了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span><span class="params">(vec2Classify,p0Vec,p1Vec,pClass1)</span>:</span></div><div class="line">    p1 = sum(vec2Classify*p1Vec)+log(pClass1)</div><div class="line">    p0 = sum(vec2Classify*p0Vec)+log(<span class="number">1.0</span>-pClass1)</div><div class="line">    <span class="keyword">if</span> p1&gt;p0:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<h1 id="准备数据-1"><a href="#准备数据-1" class="headerlink" title="准备数据"></a>准备数据</h1><p>也就是文档词袋模型了。也就是如果一个词在文档之中不止出现一次，这可能意味着这个词是否出现在文档不能表达某种信息。</p>
<p>与之前的setOfWords2Vec()不同的是，每当遇到一个单词，他就会增加词向量中的对应值，而只是把对应的值设为1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList,inputSet)</span>:</span></div><div class="line">    <span class="comment"># navie bags of words model</span></div><div class="line">    <span class="comment"># in this model each words can display many times while set of words can turn up once</span></div><div class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</div><div class="line">            <span class="comment"># when words show ,it will increase the value of vector's words rather than set value as 1</span></div><div class="line">            returnVec[vocabList.index(word)] +=<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> returnVec</div></pre></td></tr></table></figure></p>
<h1 id="实例：使用朴素贝叶斯过滤垃圾邮件"><a href="#实例：使用朴素贝叶斯过滤垃圾邮件" class="headerlink" title="实例：使用朴素贝叶斯过滤垃圾邮件"></a>实例：使用朴素贝叶斯过滤垃圾邮件</h1><p>朴素贝叶斯分类器最著名的应用及时电子邮件垃圾过滤了，首先我们来看一下如何使用通用框架来解决这个问题。</p>
<h2 id="准备数据：切分文本"><a href="#准备数据：切分文本" class="headerlink" title="准备数据：切分文本"></a>准备数据：切分文本</h2><p>对于一个文本字符串，可以使用Python的string.split() 的方法来对其进行切分。这里由于标点符号也是切分的词，所以分割符是除了单词、数字外的任意字符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">regEx = re.compile(<span class="string">'\\W*'</span>)</div></pre></td></tr></table></figure></p>
<p> 而在实际处理之中，文本往往含有空字符串，这一点我们需要去除掉。</p>
<p>其次，我们可以发现句子中的第一个单词往往是大写的。这对于我们查找句子是非常有用的，但是这里的文本是词袋，所以所有词的形式应该是统一的，所以可以使用<code>.lower()</code>转成小写或者<code>.upper()</code>转成大写。</p>
<p>但是这样毕竟也是非常理想的，在邮件之中我们往往会碰见很多词，比如解析URL的时候，Get的参数往往会被解析，从而导致出现非常多的碎片。</p>
<h1 id="测试算法：使用朴素贝叶斯进行交叉验证"><a href="#测试算法：使用朴素贝叶斯进行交叉验证" class="headerlink" title="测试算法：使用朴素贝叶斯进行交叉验证"></a>测试算法：使用朴素贝叶斯进行交叉验证</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span>    <span class="comment">#input is big string, #output is word list</span></div><div class="line">    <span class="keyword">import</span> re</div><div class="line">    listOfTokens = re.split(<span class="string">r'\W*'</span>, bigString)</div><div class="line">    <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">2</span>] </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></div><div class="line">    docList=[]; classList = []; fullText =[]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</div><div class="line">        wordList = textParse(open(<span class="string">'email/spam/%d.txt'</span> % i).read())</div><div class="line">        docList.append(wordList)</div><div class="line">        fullText.extend(wordList)</div><div class="line">        classList.append(<span class="number">1</span>)</div><div class="line">        wordList = textParse(open(<span class="string">'email/ham/%d.txt'</span> % i).read())</div><div class="line">        docList.append(wordList)</div><div class="line">        fullText.extend(wordList)</div><div class="line">        classList.append(<span class="number">0</span>)</div><div class="line">    vocabList = createVocabList(docList)<span class="comment">#create vocabulary</span></div><div class="line">    trainingSet = range(<span class="number">50</span>); testSet=[]           <span class="comment">#create test set</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        randIndex = int(random.uniform(<span class="number">0</span>,len(trainingSet)))</div><div class="line">        testSet.append(trainingSet[randIndex])</div><div class="line">        <span class="keyword">del</span>(trainingSet[randIndex])  </div><div class="line">    trainMat=[]; trainClasses = []</div><div class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:<span class="comment">#train the classifier (get probs) trainNB0</span></div><div class="line">        trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex]))</div><div class="line">        trainClasses.append(classList[docIndex])</div><div class="line">    p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses))</div><div class="line">    errorCount = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:        <span class="comment">#classify the remaining items</span></div><div class="line">        wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])</div><div class="line">        <span class="keyword">if</span> classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]:</div><div class="line">            errorCount += <span class="number">1</span></div><div class="line">            <span class="keyword">print</span> <span class="string">"classification error"</span>,docList[docIndex]</div><div class="line">    <span class="keyword">print</span> <span class="string">'the error rate is: '</span>,float(errorCount)/len(testSet)</div><div class="line">    <span class="comment">#return vocabList,fullText</span></div></pre></td></tr></table></figure>
<p> 第一个函数<code>textParse()</code>接受一个大写的字符串并且解析为字符串列表，其去除掉少于两个字符的字符串，并且把所有字符串都转成小写。</p>
<p>第二个<code>spamTest()</code>进行自动化处理。导入文件夹spam和ham下的文本文件并且将他们解析为词列表。接下来构建一个测试集和一个训练集，两个集合都是随机选出的。选出的数字所对应的文档被添加到测试集，并且也将其从训练集之中剔除，这种方式被称为<strong>留存交叉验证</strong>（hold-out cross validation）。</p>
<p><code>spamTest</code>会输出在10封邮件上的分类错误率。如果发现了错误的话，函数就会输出错分的词表，由此可以了解到究竟是哪些文档发生了错误。如果我们需要更好得估计错误率，那么就应该将上述过程重复多次，并且求出平均值。</p>
<p>这里一直出现的错误是将垃圾邮件误判为正常邮件，而反之效果会比较好一些。</p>
<h1 id="实例：使用朴素贝叶斯分类器从个人广告中获取区域倾向"><a href="#实例：使用朴素贝叶斯分类器从个人广告中获取区域倾向" class="headerlink" title="实例：使用朴素贝叶斯分类器从个人广告中获取区域倾向"></a>实例：使用朴素贝叶斯分类器从个人广告中获取区域倾向</h1><p>在这个例子之中，我们将会从美国两个城市选取一些人，通过分析征婚广告信息从而比较两个城市的人们在广告用词上是否不同。</p>
<h2 id="收集数据：导入RSS源"><a href="#收集数据：导入RSS源" class="headerlink" title="收集数据：导入RSS源"></a>收集数据：导入RSS源</h2><p>首先需要安装<code>feedparse</code>第三方包。</p>
<p>RSS源分类器以及高频去除函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcMostFreq</span><span class="params">(vocabList,fullText)</span>:</span></div><div class="line">    <span class="keyword">import</span> operator</div><div class="line">    freqDict = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> vocabList:</div><div class="line">        freqDict[token] = fullText.count(token)</div><div class="line">    sortedFreq = sorted(freqDict.iteritems(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">return</span> sortedFreq[:<span class="number">30</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">localWords</span><span class="params">(feed1,feed0)</span>:</span></div><div class="line">    <span class="keyword">import</span> feedparser</div><div class="line">    docList = []</div><div class="line">    classList = []</div><div class="line">    fullText = []</div><div class="line">    minLen = min(len(feed1[<span class="string">'entries'</span>]),len(feed0[<span class="string">'entries'</span>]))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(minLen):</div><div class="line">        wordList = textParse(feed1[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</div><div class="line">        docList.append(wordList)</div><div class="line">        fullText.extend(wordList)</div><div class="line">        classList.append(<span class="number">1</span>)</div><div class="line">        wordList = textParse(feed0[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</div><div class="line">        docList.append(wordList)</div><div class="line">        fullText.extend(wordList)</div><div class="line">        classList.append(<span class="number">0</span>)</div><div class="line">    vocabList = createVocabList(docList)</div><div class="line">    topWords = calcMostFreq(vocabList,fullText)</div><div class="line">    <span class="keyword">for</span> pairw <span class="keyword">in</span> topWords :</div><div class="line">        <span class="comment"># remove most frequent words</span></div><div class="line">        <span class="keyword">if</span> pairw[<span class="number">0</span>] <span class="keyword">in</span> vocabList:</div><div class="line">            vocabList.remove(pairw[<span class="number">0</span>])</div><div class="line">    trainingSet = range(<span class="number">2</span>*minLen)</div><div class="line">    testSet = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">        randIndex = int(random.uniform(<span class="number">0</span>,len(trainingSet)))</div><div class="line">        testSet.append(trainingSet[randIndex])</div><div class="line">        <span class="keyword">del</span>(trainingSet[randIndex])</div><div class="line">    trainMat = []</div><div class="line">    trainClasses = []</div><div class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</div><div class="line">        trainMat.append(bagOfWords2VecMN(vocabList,docList[docIndex]))</div><div class="line">        trainClasses.append(classList[docIndex])</div><div class="line">    p0v,p1v,pSpam = trainNB0(array(trainMat),array(trainClasses))</div><div class="line">    errorCount = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</div><div class="line">        wordVector = bagOfWords2VecMN(vocabList,docList[docIndex])</div><div class="line">        <span class="keyword">if</span> classifyNB(array(wordVector),p0v,p1v,pSpam)!= classList[docIndex]:</div><div class="line">            errorCount+=<span class="number">1</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'the error rate is : '</span>,float(errorCount)/len(testSet)</div><div class="line">    <span class="keyword">return</span> vocabList,p0v,p1v</div></pre></td></tr></table></figure></p>
<p> 上述代码引入了辅助函数<code>calcMostFreq</code>，该函数遍历词汇表中的每个词并且统计他们在文本中出现的次数，并且根据出现次数的高低对字典排序。</p>
<p>下一个函数<code>localWords</code>使用两个RSS源作为参数，然后调用<code>clacMostFreq</code>并且移除排序最高的30个词汇。需要指出的事，往往词汇表中的一小部分单词占据了所有文本用词的已大部分，这种现象产生的原因就是语言中大部分都是冗余和结构辅助性词汇，另一种常用的方式不仅是移除高频词，并且从某个预定词表之中语出结构上的辅助词，这个词表被称为<strong>停用词表</strong>（stop word list）。</p>
<p>为了得到错误率的精准估计，一个多次进行上述的实验，并且求平均值，这里的错误率远远高于垃圾邮件的错误率。这里可以通过移除函数<code>calcMostFreq()</code>来改变需要移除的单词数目，来观察错误率的变化。</p>
<h2 id="分析数据：显示地域相关的用词"><a href="#分析数据：显示地域相关的用词" class="headerlink" title="分析数据：显示地域相关的用词"></a>分析数据：显示地域相关的用词</h2><p>可以先对向量pSF和pNY进行排序，然后按照排序把词打出来，这里需要写入一个最具表征性的词汇显示函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTopWords</span><span class="params">(ny,sf)</span>:</span></div><div class="line">    <span class="keyword">import</span> operator</div><div class="line">    vocabList,p0V,p1V=localWords(ny,sf)</div><div class="line">    topNY=[]; topSF=[]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p0V)):</div><div class="line">        <span class="keyword">if</span> p0V[i] &gt; <span class="number">-6.0</span> : topSF.append((vocabList[i],p0V[i]))</div><div class="line">        <span class="keyword">if</span> p1V[i] &gt; <span class="number">-6.0</span> : topNY.append((vocabList[i],p1V[i]))</div><div class="line">    sortedSF = sorted(topSF, key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">"-----------------This is SF--------------------------"</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sortedSF:</div><div class="line">        <span class="keyword">print</span> item[<span class="number">0</span>]</div><div class="line">    sortedNY = sorted(topNY, key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">"-----------------This is NY--------------------------"</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sortedNY:</div><div class="line">        <span class="keyword">print</span> item[<span class="number">0</span>]</div></pre></td></tr></table></figure></p>
<p> 最后输出的单词包含了大量的停用词，移除固定的词看看结果也是十分有趣的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于分类而言，使用概率有时候比使用应规则更为有效。</p>
<p>我们可以通过特征质检的条件独立假设来降低对于数据量的需求，独立性假设是指一个词的出现概率并不依赖其他的词，当然这个假设实在是<em>Too Young Too Navie</em>了，但是朴素贝叶斯分类器仍然是一种非常有效的分类器。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    kido zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kidozh.github.io/2016/05/08/e6-9c-b4-e7-b4-a0-e8-b4-9d-e5-8f-b6-e6-96-af/" title="朴素贝叶斯">https://kidozh.github.io/2016/05/08/e6-9c-b4-e7-b4-a0-e8-b4-9d-e5-8f-b6-e6-96-af/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
            <a href="/tags/朴素贝叶斯/" rel="tag"># 朴素贝叶斯</a>
          
            <a href="/tags/机器学习/" rel="tag"># 机器学习</a>
          
            <a href="/tags/概率/" rel="tag"># 概率</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/08/abc-e7-ae-80-e5-8d-95-e8-af-81-e6-98-8e-e5-85-b6-e6-9c-80-e5-a4-a7-e5-80-bc/" rel="next" title="[A^B%C]简单证明其最大值">
                <i class="fa fa-chevron-left"></i> [A^B%C]简单证明其最大值
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/09/numpy-e5-85-a5-e9-97-a8/" rel="prev" title="Numpy入门">
                Numpy入门 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/11661760?s=460&v=4"
               alt="kido zhang" />
          <p class="site-author-name" itemprop="name">kido zhang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">113</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">78</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kidozh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/331837926Ji" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kidozh" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/kidozh" target="_blank" title="douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      douban
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/kidozh" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特点"><span class="nav-number">2.</span> <span class="nav-text">特点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#优点"><span class="nav-number">2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缺点"><span class="nav-number">2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#条件概率"><span class="nav-number">3.</span> <span class="nav-text">条件概率</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#过程"><span class="nav-number">4.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Python进行文本分类"><span class="nav-number">5.</span> <span class="nav-text">使用Python进行文本分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备数据"><span class="nav-number">5.1.</span> <span class="nav-text">准备数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#训练算法"><span class="nav-number">6.</span> <span class="nav-text">训练算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#训练算法-1"><span class="nav-number">7.</span> <span class="nav-text">训练算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#准备数据-1"><span class="nav-number">8.</span> <span class="nav-text">准备数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例：使用朴素贝叶斯过滤垃圾邮件"><span class="nav-number">9.</span> <span class="nav-text">实例：使用朴素贝叶斯过滤垃圾邮件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备数据：切分文本"><span class="nav-number">9.1.</span> <span class="nav-text">准备数据：切分文本</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试算法：使用朴素贝叶斯进行交叉验证"><span class="nav-number">10.</span> <span class="nav-text">测试算法：使用朴素贝叶斯进行交叉验证</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例：使用朴素贝叶斯分类器从个人广告中获取区域倾向"><span class="nav-number">11.</span> <span class="nav-text">实例：使用朴素贝叶斯分类器从个人广告中获取区域倾向</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#收集数据：导入RSS源"><span class="nav-number">11.1.</span> <span class="nav-text">收集数据：导入RSS源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析数据：显示地域相关的用词"><span class="nav-number">11.2.</span> <span class="nav-text">分析数据：显示地域相关的用词</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">12.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 &mdash; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kido zhang</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Pisces
    </a>
  </div>


        







        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
