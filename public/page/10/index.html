<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="kidozh的一些想法和随手笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="kidozh">
<meta property="og:url" content="https://kidozh.github.io/page/10/index.html">
<meta property="og:site_name" content="kidozh">
<meta property="og:description" content="kidozh的一些想法和随手笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kidozh">
<meta name="twitter:description" content="kidozh的一些想法和随手笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kidozh.github.io/page/10/"/>





  <title>kidozh</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kidozh</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">某不科学的kidozh</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/05/03/python-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab-ef-bc-884-ef-bc-89-e5-9b-be-e5-bd-a2-e7-b3-bb-e7-bb-9f-e7-ae-80-e4-bb-8b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/03/python-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab-ef-bc-884-ef-bc-89-e5-9b-be-e5-bd-a2-e7-b3-bb-e7-bb-9f-e7-ae-80-e4-bb-8b/" itemprop="url">[Python] 科学计算：Python VS. MATLAB（4）----图形系统简介</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-03T14:43:03+08:00">
                2015-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>一般概念</strong></p>
<p>图形系统就是用来实现所谓的可视化的。在学习具体的命令之前，先了解一个可视化的图形具有哪些特征，以及这些特征具有什么关系。有了一个宏观的了解之后，记住几个核心的命令，等遇到具体问题时候查询相关文档或者查看类似图形别人的代码即可。就以我们在纸上作图作为比拟：</p>
<p>首先，我们需要一张白纸。这张白纸，就是一个所谓的figure。我们可以给这个figure取一个名字，写在这张纸的正中间。如果这是一系列纸中的一张，可能还会给它一个标号，比如第1页、第2页。</p>
<p>然后，我们在这张纸上确定把图画在什么位置，即确定坐标轴（axes）这一张纸有几个坐标轴？坐标轴的刻度范围？线性的还是对数的？是方形的？双侧坐标轴的？等等。在画线区域，还可以考虑加网格。</p>
<p>下面，我们可以在已有的坐标中画上我们需要的功能曲线了，也就是由一个个点连成的线。连线的方式有很多选择，比如直角坐标系、极坐标、饼状图、箭头图等。对于这些点或者线，我们可以控制它的风格：比如颜色、比如宽度等等。</p>
<p>最后，要给图线添加一些说明文字，比如坐标轴的物理意义、图中曲线、符号的图例、这个图整体的标题、图中某些点的含义等等。</p>
<p><strong>二、MATLAB的实现</strong></p>
<p>以一个简单的例子，大致给出MATLAB绘图的一般方法。</p>
<p>t1=0:0.1:4<br>t2=0:0.05:4    %准备一些数据</p>
<p>figure()    %准备那张白纸<br>subplot(211)    %子图绘图<br>plot(t1,sin(2<em>pi</em>t1),’–g*’)    %线形、颜色、点的表示法<br>title(‘sine function demo’)    %标题文字<br>xlabel(‘time(s)’)<br>ylabel(‘votage(mV)’)    %XY轴的文字<br>xlim([0.0,5.0])<br>ylim([-1.2,1.2])    %XY轴的区间范围<br>grid on    %加网格</p>
<p>subplot(212)<br>plot(t2,exp(-t2),’:r’)<br>hold on   %保持上一条线</p>
<p>plot(t2,cos(2<em>pi</em>t2),’–b’)</p>
<p>xlabel(‘time’)<br>ylabel(‘amplitude’)</p>
<p>效果如图：</p>
<p><a href="http://s10.sinaimg.cn/middle/5f234d474b963d6917899&amp;690" target="_blank" rel="external"><img src="/wp-content/uploads/2015/05/050315_0642_PythonP1.png" alt=""></a></p>
<p><strong>三、Python的实现</strong></p>
<p>实现上面相同的例子。</p>
<p>Python用来绘图的工具包是matplotlib。翻译一段matplotlib主页上的话：”matplotlib是一个Python 2D绘图库，提供多种可跨平台的硬拷贝格式的出版质量的图形及交互环境。”、”matplotlib努力让容易的事情继续容易，让难的事情尽量容易。”</p>
<p>网址（<a href="http://matplotlib.sourceforge.net/gallery.html" target="_blank" rel="external">http://matplotlib.sourceforge.net/gallery.html</a>）给出了各种常见的和一些不常见的图形实例，都有源码。在使用的时候，看到自己需要的图形，找到源码，填入自己的数据以及说明文字，一个漂亮的图就产生了！另外，对于3D作图，尽管matplotlib本身不提供，但是强有力的add-ons已经加入，完全可以胜任常规3D作图。</p>
<p>初级用户建议使用pylab模式，pylab中包括了matplotlib.pyplot的所有绘图命令，以及numpy和matplotlib.mlab中的函数，在这个模式下，和MATLAB的绘图命令和套路几乎是完全一样的；高级用户建议使用matplotlib，可以进行更多的细节控制。</p>
<p>方式一：</p>
<p>from pylab import *    #引入兼容MATLAB包：pylab</p>
<p>t1=arange(0.0,4.0,0.1)<br>t2=arange(0.0,4.0,0.05)    #准备一些数据，注意和MATLAB的不同</p>
<p>figure()<br>subplot(211)<br>plot(t1,sin(2<em>pi</em>t1),’–g*’)</p>
<p>title(‘sine function demo’)<br>xlabel(‘time(s)’)<br>ylabel(‘votage(mV)’)   </p>
<p>xlim([0.0,5.0])<br>ylim([-1.2,1.2])<br>grid(‘on’)    #控制网格显示和grid(True)效果一样。不带参数的grid()起到toggle的作用。</p>
<p>subplot(212)<br>plot(t2,exp(-t2),’:r’)<br>hold(‘on’)    #前一条线保持。用法和grid类似。<br>plot(t2,cos(2<em>pi</em>t2),’–b’)</p>
<p>xlabel(‘time’)<br>ylabel(‘amplitude’)<br>show()    #这是和MATLAB很大的不同，这个命令用完，图形才会出来。</p>
<p>效果如图：</p>
<p><a href="http://s8.sinaimg.cn/middle/5f234d474b963d74770e7&amp;690" target="_blank" rel="external"><img src="/wp-content/uploads/2015/05/050315_0642_PythonP2.png" alt=""></a></p>
<p>方式二:</p>
<p>import matplotlib.pyplot as plt<br>import numpy as np    #导入包</p>
<p>t1=np.arange(0.0,4.0,0.1)<br>t2=np.arange(0.0,4.0,0.05)     #准备一些数据</p>
<p>fig = plt.figure()    #准备好这张纸，并把句柄传给fig<br>ax1 = fig.add_subplot(211)    #使用句柄fig添加一个子图<br>line1, = plt.plot(t1,np.sin(2<em>np.pi</em>t1),’–*’)   #绘图，将句柄返给line1<br>plt.title(‘sine function demo’)<br>plt.xlabel(‘time(s)’)<br>plt.ylabel(‘votage(mV)’)<br>plt.xlim([0.0,5.0])<br>plt.ylim([-1.2,1.2])<br>plt.grid(‘on’)    #以上语句不难理解</p>
<p>##这种方式的优势和不同在以下语句体现。因为句柄的引入，让我们更加的面向对象，思路也更加清晰。代码的</p>
<p>##可读性也更高了。</p>
<p>plt.setp(line1,lw=2,c=’g’)    #通过setp函数，设置句柄为line1的线的属性，c是color的简写<br>line1.set<em>antialiased(False)    #通过line1句柄的set</em>*属性设置line1的属性<br>plt.text(4,0,’$\mu=100,\sigma=15$’)    #添加text，注意，它能接受LaTeX哟！</p>
<p>ax2=fig.add_subplot(212)<br>plt.plot(t2,np.exp(-t2),’:r’)<br>plt.hold(‘on’)<br>plt.plot(t2,np.cos(2<em>np.pi</em>t2),’–b’)</p>
<p>plt.xlabel(‘time’)<br>plt.ylabel(‘amplitude’)<br>plt.show()</p>
<p>效果如图：</p>
<p><a href="http://s16.sinaimg.cn/middle/5f234d474b963d7e139af&amp;690" target="_blank" rel="external"><img src="/wp-content/uploads/2015/05/050315_0642_PythonP3.png" alt=""></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/05/03/python-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab3-e7-ba-bf-e6-80-a7-e4-bb-a3-e6-95-b0-e5-9f-ba-e7-a1-80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/03/python-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab3-e7-ba-bf-e6-80-a7-e4-bb-a3-e6-95-b0-e5-9f-ba-e7-a1-80/" itemprop="url">[Python] 科学计算：Python VS. MATLAB(3)----线性代数基础</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-03T14:40:53+08:00">
                2015-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按：在介绍工具之前先对理论基础进行必要的回顾是很必要的。没有理论的基础，讲再多的应用都是空中楼阁。本文主要设涉及线性代数和矩阵论的基本内容。先回顾这部分理论基础，然后给出MATLAB，继而给出Python的处理。个人感觉，因为Python是面向对象的，操纵起来会更接近人的正常思维；而MATLAB大多是以函数实现的，是向对象施加的一个操作。比如，A是一个矩阵，它有一个属性attr。用Python更可能是A.attr，而用MATLAB更可能是attr(A)。</p>
<p><strong>一、线形代数理论基础</strong></p>
<pre><code>线形代数（linear algebra）是数学的一个分支，研究矩阵理论、向量空间、线性变换和有限维线形方程组等内容。


比较重要的思想有：1.线性代数的核心内容是研究有限维线性空间的结构和线性空间的线性变换；2.向量的线性相关性是研究线性空间结构与线性变换理论的基础；3.矩阵是有限维线性空间的线性变换的表示形式；4.线性方程组的求解问题是n维空间到m维空间线性映射求核和全体原象的问题；5.行列式是研究这些问题的一个工具。


主要内容有：1.矩阵运算：加减乘除、转置、逆矩阵、行列式、矩阵的幂、伴随矩阵；2.矩阵分块、秩、迹；3.解方程；4.线性相关；5.向量空间；6.特征值和特征向量；7.对称、相似；8.二次标准型；9.线性空间和基变换；10.正交空间；11.矩阵对角化；13.矩阵分解；14.重要数字特征。
</code></pre><p><strong>二、MATLAB的处理</strong></p>
<p><strong>1.建立矩阵</strong></p>
<p>MATLAB中，矩阵是默认的数据类型。它把向量看做1×N或者N×1的矩阵。</p>
<p>%建立了一个行向量，不同元素之间使用空格或者逗号分开都是可以的。</p>
<p>A=[1,2,3]   或者  A=[1 2 3]</p>
<p>%建立一个矩阵，使用分号隔开不同的行。</p>
<p>A=[1,2,3;4,5,6]</p>
<p>%那么，建立一个列向量就好办了。每行一个元素，分号分开即可。当然也可以使用行向量的转置（一个撇号表示转置）。</p>
<p>A=[1;2;3]   或者   A=[1,2,3]’</p>
<p>MATLAB内置了很多特殊的矩阵生成函数，建立特殊矩阵十分方便。</p>
<p><strong>i)第一组用来生成特殊规则的矩阵。如全零、全一、随机、等步长等形式。</strong></p>
<p><strong>X=zeros(m,n)</strong>   </p>
<p>%生成一个m<em>n的全0矩阵。同理，<strong>ones(m,n)</strong>生成一个全1矩阵；<em>*eye(m,n)</em></em>生成一个单位阵。它们的重要作用在于预先分配矩阵空间，所以，在预知矩阵规模但是不知道矩阵具体数据的情况下，先用这几个函数生成一个矩阵，对提高运算速度十分有用。</p>
<p><strong>X=rand(m,n)</strong>  </p>
<p>%生成一个平均分布的随机矩阵，数值区间[0,1]。同理，<strong>randn(m,n)</strong>生成一个服从正态分布的随机矩阵。注意，这些所谓的随机实际上都是伪随机。</p>
<p><strong>v=linspace(a,b,n)</strong>   </p>
<p>%产生线性空间矢量。a和b分别是起点和终点，n是本区间内的点数，默认100个点。同理，<strong>logspace(a,b,n)</strong>产生对数空间矢量。不过它默认点数是50个。</p>
<p><strong>v=1:0.1:10</strong>   </p>
<p>%产生一个线性的矢量。规格是—起点：步长值：终点</p>
<p>ii)第二组用来在原有矩阵基础上获得一个具有某些特征的矩阵。</p>
<p><strong>X=diag(v,k)</strong>和<strong>v=diag(X,k)</strong> </p>
<p>%前者用矢量v中的元素生成一个对角矩阵，k是对角移位因子，默认为0，即主对角。k&gt;0，对角线右移。后者返回矩阵X的对角元素，存在矢量v中。k的意义相同。</p>
<p><strong>X1=triu(X,k)和X1=tril(X,k)</strong>  </p>
<p> %分别产生矩阵X的上三角矩阵和下三角矩阵。</p>
<p><strong>fliplr(X)/flipud(X)/rot90(X)</strong>   </p>
<p>%这都是对矩阵的翻转操作，获得新的矩阵。分别是左右翻转（left-right）、上下翻转（up-down）和逆时针旋转90°操作。</p>
<p>iii)第三组用来生成一些具有理论价值的，往往是以数学家命名的矩阵。</p>
<p><strong>magic(n)</strong>生成行列相加均为同一个数字的方阵。<strong>pascal(n)</strong>生成帕斯卡尔矩阵。<strong>hilb(n)</strong>生成希尔伯特矩阵。<strong>vander(v)</strong>生成范德蒙德矩阵。等等。</p>
<p>这些矩阵一般都有相应的学术背景，用到的时候，可以用命令help elmat在最后一个栏目中看看有没有自己要找的特殊矩阵，如果有，点进去进一步研究即可。</p>
<p><strong>2.矩阵的特征信息</strong></p>
<p><strong>size(X)</strong>  %获得矩阵X的行、列数。比如，X是一个3*5的矩阵，p=size(X)返回p=[3 5]</p>
<p><strong>length()</strong>   %对于矢量，返回的是矢量的长度；对数组，返回的是数组最长的那一个维度的长度。</p>
<p><strong>ndims()</strong>   %相当于length(size(x))。</p>
<p><strong>numel()</strong>   %数组中元素的个数。</p>
<p><strong>isempty()</strong>和<strong>isequal()</strong>等<strong>is*</strong>型函数    %测试矩阵是否满足某些条件</p>
<p><strong>[V,D] = eig(A)</strong>  %矩阵A的特征值D和特征向量V。</p>
<p><strong>k = rank(A)</strong>   %矩阵A的秩</p>
<p><strong>b = trace(A)</strong>  %矩阵A的迹，即对角线元素之和</p>
<p><strong>d = det(X)</strong>    %方阵A的行列式</p>
<p><strong>Y = inv(X)</strong>   %矩阵X的逆矩阵</p>
<p><strong>n = norm(X,option)</strong>   %矩阵或者向量的范数，具体使用用到再说</p>
<p><strong>c = cond(X)</strong>    %矩阵X的条件数</p>
<p><strong>3.矩阵分解</strong></p>
<p>矩阵分解是矩阵论的重要内容。常用的分解形式在MATLAB中都有函数予以实现，并且有些分解考虑了多种情况。常见的如：eig()、qr()、schur()、svd()、chol()、lu()等。具体使用的时候</p>
<p><strong>4.矩阵运算</strong></p>
<p>MATLAB默认的是矩阵运算，所以如果想要按元素依次计算，在原来运算符前加一个.号。比如.*表示按元素相乘。</p>
<p>每一个运算符都有一个对应的函数。如：</p>
<p><strong>A+B=plus(A,B)、A-B=minus(A,B)</strong></p>
<p><strong>A<em>B=mtimes(A,B)、A.</em>B=times(A,B)</strong></p>
<p><strong>A/B=mrdivide(A,B)、A./B=rdivide(A,B)、A\B=mldivide(A,B)、A.\B=ldivide(A,B)</strong></p>
<p><strong>A^B=mpower(A,B)、A.^B=power(A,B)</strong></p>
<p><strong>A’=ctranspose(A)、A.’=transpose(A)</strong></p>
<p>其中的前缀m自然是表示matrix的意思。没有m前缀的就是按元素进行的意思。最后那个转置操作，c前缀表示的是按照复数操作进行转置。</p>
<p>此外，还有一些比较常用的运算：</p>
<p><strong>C=cross(A,B)</strong>  </p>
<p>%矢量叉乘。类似的，C=dot(A,B)  是矢量点乘<br><strong>B = prod(A,dim)</strong>   </p>
<p>%数组元素的乘积，默认按列计算。dim=1是列，dim=2是按行。这个概念很重要！！<br>类似的，B = sum(A,dim)   求数组元素的和。dim意义和以上同。<br><strong>expm()</strong>   </p>
<p>%矩阵指数运算。与此类似的<strong>logm(), sqrtm()。</strong>其中，<strong>funm(A,fun)</strong>用来计算矩阵A对通用函数fun的函数值。</p>
<p><strong>5.矩阵索引</strong></p>
<p>选择使用矩阵中的某些元素，就是所谓的矩阵索引了。</p>
<p>A(:,j)   %选取矩阵A的所有行，第j列，同理，A(i,:)是第i行，所有列</p>
<p>A(:,j:k)    %所有行，第j列至第k列（起点和终点均含）</p>
<p><strong>三、Python的处理</strong></p>
<p>Python使用NumPy包完成了对N-维数组的快速便捷操作。使用这个包，需要导入numpy。SciPy包以NumPy包为基础，大大的扩展了numpy的能力。为了使用的方便，scipy包在最外层名字空间中包括了所有的numpy内容，因此只要导入了scipy，不必在单独导入numpy了！但是为了明确哪些是numpy中实现的，哪些是scipy中实现的，本文还是进行了区分。以下默认已经：import numpy as np 以及 impor scipy as sp</p>
<p>下面简要介绍Python和MATLAB处理数学问题的几个不同点。1.MATLAB的基本是矩阵，而numpy的基本类型是多为数组，把matrix看做是array的子类。2.MATLAB的索引从1开始，而numpy从0开始。</p>
<p><strong>1.建立矩阵</strong></p>
<p>a1=np.array([1,2,3],dtype=int)   #建立一个一维数组，数据类型是int。也可以不指定数据类型，使用默认。几乎所有的数组建立函数都可以指定数据类型，即dtype的取值。</p>
<p>a2=np.array([[1,2,3],[2,3,4]])   #建立一个二维数组。此处和MATLAB的二维数组（矩阵）的建立有很大差别。</p>
<p>同样，numpy中也有很多内置的特殊矩阵：</p>
<p>b1=np.zeros((2,3))    #生成一个2行3列的全0矩阵。注意，参数是一个tuple：(2,3)，所以有两个括号。完整的形式为：zeros(shape,dtype=)。相同的结构，有<strong>ones()</strong>建立全1矩阵。<strong>empty()</strong>建立一个空矩阵，使用内存中的随机值来填充这个矩阵。</p>
<p>b2=identity(n)   #建立n*n的单位阵，这只能是一个方阵。</p>
<p>b3=eye(N,M=None,k=0)    #建立一个对角线是1其余值为0的矩阵，用k指定对角线的位置。M默认None。</p>
<p>此外，numpy中还提供了几个like函数，即按照某一个已知的数组的规模（几行几列）建立同样规模的特殊数组。这样的函数有<strong>zeros_like()、empty_like()、ones_like()，</strong>它们的参数均为如此形式：zeros_like(a,dtype=)，其中，a是一个已知的数组。</p>
<p>c1=np.arange(2,3,0.1)   #起点，终点，步长值。含起点值，不含终点值。</p>
<p>c2=np.linspace(1,4,10)    #起点，终点，区间内点数。起点终点均包括在内。同理，有logspace()函数</p>
<p>d1=np.linalg.companion(a)    #伴随矩阵</p>
<p>d2=np.linalg.triu()/tril()   #作用同MATLAB中的同名函数</p>
<p>e1=np.random.rand(3,2)    #产生一个3行2列的随机数组。同一空间下，有randn()/randint()等多个随机函数</p>
<p>fliplr()/flipud()/rot90()    #功能类似MATLAB同名函数。</p>
<p>xx=np.roll(x,2)   #roll()是循环移位函数。此调用表示向右循环移动2位。</p>
<p><strong>2.数组的特征信息</strong></p>
<p>先假设已经存在一个N维数组X了，那么可以得到X的一些属性，这些属性可以在输入X和一个.之后，按tab键查看提示。这里明显看到了Python面向对象的特征。</p>
<p>X.flags    #数组的存储情况信息。</p>
<p>X.shape    #结果是一个tuple，返回本数组的行数、列数、……</p>
<p>X.ndim   #数组的维数，结果是一个数</p>
<p>X.size    #数组中元素的数量</p>
<p>X.itemsize    #数组中的数据项的所占内存空间大小</p>
<p>X.dtype    #数据类型</p>
<p>X.T   #如果X是矩阵，发挥的是X的转置矩阵</p>
<p>X.trace()    #计算X的迹</p>
<p>np.linalg.det(a)   #返回的是矩阵a的行列式</p>
<p>np.linalg.norm(a,ord=None)    #计算矩阵a的范数</p>
<p>np.linalg.eig(a)    #矩阵a的特征值和特征向量</p>
<p>np.linalg.cond(a,p=None)    #矩阵a的条件数</p>
<p>np.linalg.inv(a)    #矩阵a的逆矩阵</p>
<p><strong>3.矩阵分解</strong></p>
<p>常见的矩阵分解函数，numpy.linalg均已经提供。比如cholesky()/qr()/svd()/lu()/schur()等。某些算法为了方便计算或者针对不同的特殊情况，还给出了多种调用形式，以便得到最佳结果。</p>
<p><strong>4.矩阵运算</strong></p>
<p>np.dot(a,b)用来计算数组的点积；vdot(a,b)专门计算矢量的点积，和dot()的区别在于对complex数据类型的处理不一样；innner(a,b)用来计算内积；outer(a,b)计算外积。</p>
<p>专门处理矩阵的数学函数在numpy的子包linalg中定义。比如np.linalg.logm(A)计算矩阵A的对数。可见，这个处理和MATLAB是类似的，使用一个m后缀表示是矩阵的运算。在这个空间内可以使用的有cosm()/sinm()/signm()/sqrtm()等。其中常规exp()对应有三种矩阵形式：expm()使用Pade近似算法、expm2()使用特征值分析算法、expm3()使用泰勒级数算法。在numpy中，也有一个计算矩阵的函数：funm(A,func)。</p>
<p><strong>5.索引</strong></p>
<p>numpy中的数组索引形式和Python是一致的。如：</p>
<p>x=np.arange(10)</p>
<p>print x[2]    #单个元素，从前往后正向索引。注意下标是从0开始的。</p>
<p>print x[-2]    #从后往前索引。最后一个元素的下标是-1</p>
<p>print x[2:5]    #多个元素，左闭右开，默认步长值是1</p>
<p>print x[:-7]    #多个元素，从后向前，制定了结束的位置，使用默认步长值</p>
<p>print x[1:7:2]   #指定步长值</p>
<p>x.shape=(2,5)    #x的<strong>shape</strong>属性被重新赋值，要求就是元素个数不变。2*5=10</p>
<p>print x[1,3]    #二维数组索引单个元素，第2行第4列的那个元素</p>
<p>print x[0]   #第一行所有的元素</p>
<p>y=np.arange(35).reshape(5,7)    #<strong>reshape()</strong>函数用于改变数组的维度</p>
<p>print y[1:5:2,::2]    #选择二维数组中的某些符合条件的元素</p>
<p>————————————————-分割线————————————————-</p>
<p>作为第一篇正式的介绍技术操作的文章，终于写完了，很费劲。恰恰就是在这个费劲的过程中，让我能更好的认识两者的区别和联系，同时梳理了展开的思路，摸索出了进一步学习的方法。</p>
<p>我们可以看到，MATLAB中实现了的函数或者功能，在numpy中都有了对应，并且有些实现的更好。当然，这只是冰山一角。如果你不愿意通读文档（很枯燥，谁也不愿意干！）也应该有理由相信，Python有能胜任工作的实现已经存在。后面的内容，将不再这样列出各种函数和功能，而是以某一个实际问题为核心，进行专题式的研究。至于全方位的了解，请自己查阅文档。有个经验之谈，就是，应该充分的利用文档中的【see also】功能，依此追踪下去，必然会获得关于某主题的全方位的认识。比如，在查阅ones()的时候，MATLAB的【see also】就给出了complex|eye|true|zeros四个链接。这就说明，这几个函数其实是有关联的，点进去进行简单的学习，找到共性，那么，可能很多人都遇到过的最大的困惑——那么多函数怎么记住呀？——就已经解决了。因为，我们不需要记住所有的函数，我们只需要记住有那么回事，只需要记住一个类似的函数，就可以很轻易的在用的时候顺藤摸瓜找出需要的函数。</p>
<p>下面简单的给出MATLAB和Python的自查自学方法吧！</p>
<p><strong>1.MATLAB</strong></p>
<p>help 函数名  </p>
<p>%在控制台给出某函数或者主题的帮助信息</p>
<p>doc  函数名 </p>
<p>%在帮助浏览器中给出帮助信息，这个界面更友好。在help browser中既有MATLAB整个产品的浏览左窗口，也有一个搜索框。同时还有大量存在的超链接。就一个感兴趣的主题，点下去，全面学习。不过要记住:别分神哦~~点到最后都忘了自己究竟要做什么！</p>
<p>lookfor 关键词   </p>
<p>%这是一个模糊寻找，含有关键词的词条入口都会给出来</p>
<p><strong>2.Python</strong></p>
<p>help(np.array)    #查看关于array的帮助信息</p>
<p>help(np.add)  #查看关于add的帮助信息</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/05/03/python-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab-2-e5-87-86-e5-a4-87-e4-b8-8e-e5-89-8d-e6-8f-90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/03/python-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab-2-e5-87-86-e5-a4-87-e4-b8-8e-e5-89-8d-e6-8f-90/" itemprop="url">[Python] 科学计算：Python VS. MATLAB (2)----准备与前提</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-03T14:39:14+08:00">
                2015-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>一、搭建平台环境</strong></p>
<pre><code>自己动手搭建Python科学计算平台，逐个下载安装各个模块毕竟是一个麻烦的事情。Python(x,y)项目想我们之所想，急我们之所急，将科学计算常用的工具进行打包，组成一个发行版。（在Python(x,y)的项目主页有项目介绍、入门指导和下载入口。网址：http://code.google.com/p/pythonxy/）


Python(x,y)主要特征：1）集合了用于科学计算的Python库和开发环境工具。2）集合了几乎所有的相关的自由文档。3）提供了Python/Qt/Spyder快速入门教程。4）提供了一键装/卸程序，只需一次点击即可安装或卸载所有包和工具。


在Window$下，在上述网址下载Python(x,y)的最新版本，安装十分简单。安装后，打开Python(x,y)程序。可以看到，第一个标签Shortcuts有启动各个独立程序的入口以及选项。第二个标签Documentation是各个模块或者程序的文档入口，有本地版也要web版。本地版的文档十分丰富，基本能满足需求。所以，即使不联网，使用Python(x,y)进行Python科学计算的学习也是没有问题的。


推荐一款Python的IDE，PyCharm，简直是开发神器！百度即可，PyCharm Community Edition是免费的哟~
</code></pre><p>——————–俺是花钱的分割线——————————————</p>
<pre><code>对于MATLAB，更是简单，下载安装程序，我用的MATLAB2014a有7.2GB大小，相比Python(x,y)的400MB，只能感叹。安装的时候使用crack的序列号和license文件，等上半个小时，就装好了。这个版本安装后并不生成快捷方式，在&quot;开始→所有程序&quot;中也没有。启动它的两种方式：1）到安装路径X:\Program Files\MATLAB\R2014a\bin中找到名为MATLAB的应用程序，双击之；最好发送快捷方式到桌面，方便下次使用。2）先使用Win+R呼出运行，然后输入MATLAB（不区分大小写），回车或者用鼠标点确定。
</code></pre><p><strong> 二、简单预备工作</strong></p>
<pre><code>交互式控制台（Interactive consoles）一般用IPython，相比IDLE具有自动补全等加强功能。编写脚本，它自己带的SciTE或者IDLE都可以用，当然，我们也可以使用Notepad++、Eclipse+Pydev、VIM、UltraEdit等编辑器或者集成环境。不管使用什么编辑器或者集成环境，先进行一下个性化设置：代码折叠、代码高亮、行号显示、自己喜欢的字体字号、一些快捷键等等。这些，对于有一点程序设计基础的人来讲，都不陌生。
</code></pre><p>———————— 俺是花钱的分割线 ————————————</p>
<pre><code>MATLAB完全类似，敲入preferences，呼出个性化设置界面，按照自己的喜好进行设置。
</code></pre><p><strong>三、作者计算机配置</strong></p>
<pre><code>科学计算很讲究时间效率，后面肯定会不断的向时间宣战。所以，未免误会，在此给出我的计算机的配置很有必要：


 联想G500商务台式机，安装Windows 7专业版64位系统。Intel core i7-3240 CPU@3.10GHz，8GB RAM。


MATLAB 2014a，64位版本。


Python(x,y) 2.7.2.0版本。
</code></pre><hr>
<pre><code>有了这些工作，从下篇文章开始真正的科学计算研究。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/05/03/python-e8-bd-ac-e8-bd-bd-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab-1-e7-bb-99-e6-88-91-e4-b8-80-e4-b8-aa-e7-90-86-e7-94-b1-e5-85-88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/03/python-e8-bd-ac-e8-bd-bd-e7-a7-91-e5-ad-a6-e8-ae-a1-e7-ae-97-ef-bc-9apython-vs-matlab-1-e7-bb-99-e6-88-91-e4-b8-80-e4-b8-aa-e7-90-86-e7-94-b1-e5-85-88/" itemprop="url">[Python][转载] 科学计算：Python VS. MATLAB (1)----给我一个理由先</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-03T14:31:14+08:00">
                2015-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MATLAB 是一种用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境。使用 MATLAB，您可以较使用传统的编程语言（如 C、C++ 和 Fortran）更快地解决技术计算问题。（官网：<a href="http://www.mathworks.com/matlabcentral/linkexchange/links/1573-matlab-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E8%AF%AD%E8%A8%80" target="_blank" rel="external">http://www.mathworks.com/matlabcentral/linkexchange/links/1573-matlab-科学计算语言</a>）</p>
<pre><code> 随着MATLAB工具箱的不断添加和完善，M语言也逐渐成为工程界的准通用标准语言，官网称：MATLAB - The Language Of Technical Computing。大学理工科专业一般都开设了或选修或必修的MATLAB相关课程。很多新出版的教材，计算机辅助教学的工具软件开始选用MATLAB。MATLAB以其简洁易学的语法、友好的界面和完善的文档系统逐渐深入人心并将继续扩大它的控制领地。


 然而，MATLAB也有着很大的局限性。**首先，是价格。**作为一款商业软件，获得正版授权，价格不菲。就说最便宜的学生版，核心组件单个授权要花99刀，想使用额外工具箱，则是每个工具箱29刀。（[http://www.mathworks.com/store/platformReleaseStuSubmit.do](http://www.mathworks.com/store/platformReleaseStuSubmit.do)） 正如你能想到的，商业版本更贵。**其次，是版权。**mathworks论坛活跃着很多用户，也有很多有价值的代码，但是，版权归mathworks公司，要想使用必须获得它的授权。**再次，是语言完善性。**MATLAB进行数学计算的表现无可置疑，但是实际的科学计算还有文件操作、界面设计等任务。MATLAB在这些领域功能较弱或者很麻烦。应该可以说，MATLAB不是一种完善的语言。


 穷则思变。这时，我们发现了Python。MATLAB的以上不足，恰是Python的优势。


**首先，Python完全免费**（[http://python.org/](http://python.org/)），绝大多数科学计算相关扩展库也都是免费的，大多也都是是开源的，所以金钱问题完全不用考虑。版权问题也基本不用考虑，众多的实例程序可以让你拿去就用。（有时候也需要考虑，因为有些授权，如GPL授权，具有&quot;传染性&quot;）。考虑控制版权更严格的诸如美国之类的国家，有着众多的研究人员和大学生使用Python，并有很多网络提供了交流平台，在这个平台可以获得更多的交流学习机会。**其次，Python是一门更易学更严谨的面向对象的程序设计语言。**作为通用程序设计语言的Python，有更为严格清晰的语法，可以轻易完成界面、文件、封装等高阶需求。**最后，不得不提的就是性能。**MATLAB作为科学计算工具，经过了近乎苛刻的优化，Python呢？实话说，纯Python的速度确实不怎么地，但是使用Python的科学计算扩展库numpy、scipy等之后，速度和MATLAB不相上下。（[http://www.scipy.org/PerformancePython#head-a73fa06d3c4f3bda71b3526d30d51c492d8f80df](http://www.scipy.org/PerformancePython)）


 以上理由似乎足以让我们割爱MATLAB，选择使用&quot;Python+扩展&quot;来完成科学计算问题。然而，我想起班固的名言&quot;爱而知其恶&quot;，Python进行科学计算是不是完美？又有哪些劣势呢？Google了一阵子，发现大致是这样：第一，因为沉浸在开源的环境下，想私藏代码似乎不是那么容易了，甚至不好意思了。第二，文档系统不是很完善，中文的更是少之又少，这就要求一定的英语文档阅读功底。不过MATLAB至今也没有提供过中文的文档。第三，MATLAB中的有些生僻的专用工具箱没有Python环境下的对应模块功能实现。第四，貌似没有第四了。


 以上对比不敢说写的就对，后续有关具体技术和代码的文章更是可能会有重大错误甚至误导。之所以还敢写出来，放到这里，权当借此平台和同道中人进行交流、切磋。文章假设您有初级的Python基础，这样就可以把重心放到科学计算而不是纯粹的语言上来；也假设您有一定的MATLAB基础，因为文中经常拿两者来对比并给出两者的各自实现。欢迎批评！
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/05/02/linuxlinux-e4-b8-8b-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-9a-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/02/linuxlinux-e4-b8-8b-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-9a-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1/" itemprop="url">[linux]Linux下的多线程多进程通信</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-02T17:33:40+08:00">
                2015-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>进程（fork）</li>
</ol>
<ol>
<li>什么是一个进程？进程这个概念是针对系统而不是针对用户的，对用户来说，他面对的概念是程序。当用户敲入命令执行一个程序的时候，对系统而言，它将启动一个进程。但和程序不同的是，在这个进程中，系统可能需要再启动一个或多个进程来完成独立的多个任务。多进程编程的主要内容包括进程控制和进程间通信，在了解这些之前，我们先要简单知道进程的结构。</li>
</ol>
<p>1-2.  Linux下进程的结构<br>Linux下一个进程在内存里有三部分的数据，就是”代码段”、”堆栈段”和”数据段”。其实学过汇编语言的人一定知道，一般的CPU都有上述三种段寄存器，以方便操作系统的运行。这三个部分也是构成一个完整的执行序列的必要的部分。<br>“代码段”，顾名思义，就是存放了程序代码的数据，假如机器中有数个进程运行相同的一个程序，那么它们就可以使用相同的代码段。”堆栈段”存放的就是子程序的返回地址、子程序的参数以及程序的局部变量。而数据段则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用malloc之类的函数取得的空间）。这其中有许多细节问题，这里限于篇幅就不多介绍了。系统如果同时运行数个相同的程序，它们之间就不能使用同一个堆栈段和数据段。</p>
<ol>
<li>Linux下的进程控制在传统的Unix环境下，有两个基本的操作用于创建和修改进程：函数fork( )用来创建一个新的进程，该进程几乎是当前进程的一个完全拷贝；函数族exec( )用来启动另外的进程以取代当前运行的进程。Linux的进程控制和传统的Unix进程控制基本一致，只在一些细节的地方有些区别，例如在Linux系统中调用vfork和fork完全相同，而在有些版本的Unix系统中，vfork调用有不同的功能。由于这些差别几乎不影响我们大多数的编程，在这里我们不予考虑。</li>
</ol>
<p>1-2.1 fork( )<br>fork在英文中是”分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork，就产生了另一个进程，于是进程就”分叉”了，所以这个名字取得很形象。下面就看看如何具体使用fork，这段程序演示了使用fork的基本框架：</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li><strong>void</strong> main(){   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    if</strong> ( fork() == 0 ) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 子进程程序 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    for</strong> ( i = 1; i &lt;1000; i ++ ) printf(“This is child process/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    else</strong> {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 父进程程序</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>        for</strong> ( i = 1; i &lt;1000; i ++ ) printf(“This is process process/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p> 程序运行后，你就能看到屏幕上交替出现子进程与父进程各打印出的一千条信息了。如果程序还在运行中，你用ps命令就能看到系统中有两个它在运行了。<br>　　 那么调用这个fork函数时发生了什么呢？fork函数启动一个新的进程，前面我们说过，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现，这将是我们下面的内容。既然它们如此相象，系统如何来区分它们呢？这是由函数的返回值来决定的。对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps函数就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能，正如我们上面举的例子一样。我们看到，上面例子执行时两条信息是交互无规则的打印出来的，这是父子进程独立执行的结果，虽然我们的代码似乎和串行的代码没有什么区别。<br>　　 读者也许会问，如果一个大程序在运行中，它的数据段和堆栈都很大，一次fork就要复制一次，那么fork的系统开销不是很大吗？其实UNIX自有其解决的办法，大家知道，一般CPU都是以”页”为单位来分配内存空间的，每一个页都是实际物理内存的一个映像，比如INTEL的CPU，其一页在通常情况下是4086字节大小，而无论是数据段还是堆栈段都是由许多”页”构成的，fork函数复制这两个段，只是”逻辑”上的，并非”物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的”页”从物理上也分开。系统在空间上的开销就可以达到最小。</p>
<p>1.2-2 exec( )函数族<br>　　 下面我们来看看一个进程如何来启动另一个程序的执行。在Linux中要使用exec函数族。系统调用execve（）对当前进程进行替换，替换者为一个指定的程序，其参数包括文件名（filename）、参数列表（argv）以及环境变量（envp）。exec函数族当然不止一个，但它们大致相同，在Linux中，它们分别是：execl，execlp，execle，execv，execve和execvp，下面我只以execlp为例，其它函数究竟与execlp有何区别，请通过manexec命令来了解它们的具体情况。<br>　　 一个进程一旦调用exec类函数，它本身就”死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。（不过exec类函数中有的还允许继承环境变量之类的信息。）<br>　　 那么如果我的程序想启动另一程序的执行但自己仍想继续运行的话，怎么办呢？那就是结合fork与exec的使用。下面一段代码显示如何启动运行其它程序：</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li><strong>char</strong> command[256];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main()   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    int</strong> rtn; /<em>子进程的返回数值</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>    while</strong>(1) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 从终端读取要执行的命令 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “&gt;” );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fgets( command, 256, stdin );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>command[strlen(command)-1] = 0;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>        if</strong> ( fork() == 0 ) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 子进程执行此命令 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>execlp( command, command );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 如果exec函数返回，表明没有正常执行命令，打印错误信息</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>perror( command );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit( errorno );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>        else</strong> {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 父进程， 等待子进程结束，并打印子进程的返回值 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>wait ( &amp;rtn );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “ child process return %d/n”,. rtn );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<p>此程序从终端读入命令并执行之，执行完成后，父进程继续等待从终端读入命令。熟悉DOS和WINDOWS系统调用的朋友一定知道DOS/WINDOWS也有exec类函数，其使用方法是类似的，但DOS/WINDOWS还有spawn类函数，因为DOS是单任务的系统，它只能将”父进程”驻留在机器内再执行”子进程”，这就是spawn类的函数。WIN32已经是多任务的系统了，但还保留了spawn类函数，WIN32中实现spawn函数的方法同前述UNIX中的方法差不多，开设子进程后父进程等待子进程结束后才继续运行。UNIX在其一开始就是多任务的系统，所以从核心角度上讲不需要spawn类函数。<br>　　 在这一节里，我们还要讲讲system（）和popen（）函数。system（）函数先调用fork（），然后再调用exec（）来执行用户的登录shell，通过它来查找可执行文件的命令并分析参数，最后它么使用wait（）函数族之一来等待子进程的结束。函数popen（）和函数system（）相似，不同的是它调用pipe（）函数创建一个管道，通过它来完成程序的标准输入和标准输出。这两个函数是为那些不太勤快的程序员设计的，在效率和安全方面都有相当的缺陷，在可能的情况下，应该尽量避免。</p>
<pre><code>1-3 Linux下的进程间通信 




    首先，进程间通信至少可以通过传送打开文件来实现，不同的进程通过一个或多个文件来传递信息，事实上，在很多应用系统里，都使用了这种方法。但一般说来，进程间通信      （IPC：InterProcess Communication）不包括这种似乎比较低级的通信方法。Unix系统中实现进程间通信的方法很多，而且不幸的是，极少方法能在所有的Unix系统中进行移植       （唯一一种是半双工的管道，这也是最原始的一种通信方式）。而Linux作为一种新兴的操作系统，几乎支持所有的Unix下常用的进程间通信方法：管道、消息队列、共享内存、信        号量、套接口等等。下面我们将逐一介绍。




    2.3.1 管道
</code></pre><p>　　            管道是进程间通信中最古老的方式，它包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者用于运行于同一台机器上的任意两个进程间的通信。<br>　　            无名管道由pipe（）函数创建：<br>　　             #include <unistd.h><br>　　            int pipe(int filedis[2])；<br>　　            参数filedis返回两个文件描述符：filedes[0]为读而打开，filedes[1]为写而打开。filedes[1]的输出是filedes[0]的输入。下面的例子示范了如何在父进程和子进程间实现通信。</unistd.h></p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>#define INPUT 0   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#define OUTPUT 1   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> file_descriptors[2];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>定义子进程号 </em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>pid_t pid;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>char</strong> buf[256];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> returned_count;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>创建无名管道</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>pipe(file_descriptors);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>创建子进程</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     if</strong>((pid = fork()) == -1) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“Error in fork/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>执行子进程</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     if</strong>(pid == 0) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“in the spawned (child) process…/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>子进程向父进程写数据，关闭管道的读端</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>close(file_descriptors[INPUT]);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>write(file_descriptors[OUTPUT], “test data”, strlen(“test data”));   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}</li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>else</strong> {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>执行父进程</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“in the spawning (parent) process…/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>父进程从管道读取子进程写的数据，关闭管道的写端</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>close(file_descriptors[OUTPUT]);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>returned_count = read(file_descriptors[INPUT], buf, <strong>sizeof</strong>(buf));   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“%d bytes of data received from spawned process: %s/n”,   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>returned_count, buf);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<pre><code>在Linux系统下，有名管道可由两种方式创建：命令行方式mknod系统调用和函数mkfifo。下面的两种途径都在当前目录下生成了一个名为myfifo的有名管道：
</code></pre><p>　　　　      方式一：mkfifo(“myfifo”,”rw”);<br>　　　　      方式二：mknod myfifo p<br>　　       生成了有名管道后，就可以使用一般的文件I/O函数如open、close、read、write等来对它进行操作。下面即是一个简单的例子，假设我们已经创建了一个名为myfifo的有名管道。</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>/<em> 进程一：读有名管道</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <unistd.h>   </unistd.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>FILE</strong> * in_file;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> count = 1;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>char</strong> buf[80];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>in_file = fopen(“mypipe”, “r”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>if</strong> (in_file == NULL) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“Error in fdopen./n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     while</strong> ((count = fread(buf, 1, 80, in_file)) &gt; 0)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“received from pipe: %s/n”, buf);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fclose(in_file);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　 /<em> 进程二：写有名管道</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <unistd.h>   </unistd.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     FILE</strong> * out_file;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     int</strong> count = 1;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     char</strong> buf[80];   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>out_file = fopen(“mypipe”, “w”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>     if</strong> (out_file == NULL) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“Error opening pipe.”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>sprintf(buf,”this is test data for the named pipe example/n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fwrite(buf, 1, 80, out_file);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>fclose(out_file);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<pre><code>the following is self-study &gt;&gt;




2.3.2 消息队列
</code></pre><p>　　      消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，事实上，它是一种正逐渐被淘汰的通信方式，我们可以用流管道或者套接口的方式来取代它，所以，我们对此方式也不再解释，也建议读者忽略这种方式。</p>
<p>　　      2.3.3 共享内存<br>　　      共享内存是运行在同一台机器上的进程间通信最快的方式，因为数据不需要在不同的进程间复制。通常由一个进程创建一块共享内存区，其余进程对这块内存区进行读写。得到共享内存有两种方式：映射/dev/mem设备和内存映像文件。前一种方式不给系统带来额外的开销，但在现实中并不常用，因为它控制存取的将是实际的物理内存，在Linux系统下，这只有通过限制Linux系统存取的内存才可以做到，这当然不太实际。常用的方式是通过shmXXX函数族来实现利用共享内存进行存储的。<br>　　      首先要用的函数是shmget，它获得一个共享存储标识符。<br>　　　　     #include <sys types.h=""><br>　　　　     #include <sys ipc.h=""><br>　　　　     #include <sys shm.h=""><br>　　　　　int shmget(key_t key, int size, int flag);<br>　　      这个函数有点类似大家熟悉的malloc函数，系统按照请求分配size大小的内存用作共享内存。Linux系统内核中每个IPC结构都有的一个非负整数的标识符，这样对一个消息队列发送消息时只要引用标识符就可以了。这个标识符是内核由IPC结构的关键字得到的，这个关键字，就是上面第一个函数的key。数据类型key_t是在头文件sys/types.h中定义的，它是一个长整形的数据。在我们后面的章节中，还会碰到这个关键字。<br>　　      当共享内存创建后，其余进程可以调用shmat（）将其连接到自身的地址空间中。<br>　　      void <em>shmat(int shmid, void </em>addr, int flag);<br>　　      shmid为shmget函数返回的共享存储标识符，addr和flag参数决定了以什么方式来确定连接的地址，函数的返回值即是该进程数据段所连接的实际地址，进程可以对此进程进行读写操作。<br>　　        使用共享存储来实现进程间通信的注意点是对数据存取的同步，必须确保当一个进程去读取数据时，它所想要的数据已经写好了。通常，信号量被要来实现对共享存储数据存取的同步，另外，可以通过使用shmctl函数设置共享存储内存的某些标志位如SHM_LOCK、SHM_UNLOCK等来实现。</sys></sys></sys></p>
<p>　　         2.3.4 信号量<br>　　      信号量又称为信号灯，它是用来协调不同进程间的数据对象的，而最主要的应用是前一节的共享内存方式的进程间通信。本质上，信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作：<br>　　      （1） 测试控制该资源的信号量。<br>　　      （2） 若此信号量的值为正，则允许进行使用该资源。进程将进号量减1。<br>　　      （3） 若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤（1）。<br>　　      （4） 当进程不再使用一个信号量控制的资源时，信号量值加1。如果此时有进程正在睡眠等待此信号量，则唤醒此进程。<br>　　      维护信号量状态的是Linux内核操作系统而不是用户进程。我们可以从头文件/usr/src/linux/include　/linux　/sem.h中看到内核用来维护信号量状态的各个结构的定义。信号量是一个数据集合，用户可以单独使用这一集合的每个元素。要调用的第一个函数是semget，用以获得一个信号量ID。
　　</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>#include <sys types.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　 #include <sys ipc.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　 #include <sys sem.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　 <strong>int</strong> semget(key_t key, <strong>int</strong> nsems, <strong>int</strong> flag);   </li>
</ol>
</li>
</ol>
<p>　　         key是前面讲过的IPC结构的关键字，它将来决定是创建新的信号量集合，还是引用一个现有的信号量集合。nsems是该集合中的信号量数。如果是创建新集合（一般在服务器中），则必须指定nsems；如果是引用一个现有的信号量集合（一般在客户机中）则将nsems指定为0。<br>　　         semctl函数用来对信号量进行操作。<br>　　      int semctl(int semid, int semnum, int cmd, union semun arg);<br>　　      不同的操作是通过cmd参数来实现的，在头文件sem.h中定义了7种不同的操作，实际编程时可以参照使用。<br>　　      semop函数自动执行信号量集合上的操作数组。<br>　　      int semop(int semid, struct sembuf semoparray[], size_t nops);<br>　　         semoparray是一个指针，它指向一个信号量操作数组。nops规定该数组中操作的数量。<br>　　        下面，我们看一个具体的例子，它创建一个特定的IPC结构的关键字和一个信号量，建立此信号量的索引，修改索引指向的信号量的值，最后我们清除信号量。在下面的代码中，函数ftok生成我们上文所说的唯一的IPC关键字。</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li>#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <sys types.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <sys sem.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>#include <sys ipc.h="">   </sys></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main() {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>key_t unique_key; /<em> 定义一个IPC关键字</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> id;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>struct</strong> sembuf lock_it;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>union</strong> semun options;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>unique_key = ftok(“.”, ‘a’); /<em> 生成关键字，字符’a’是一个随机种子</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em> 创建一个新的信号量集合</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>id = semget(unique_key, 1, IPC_CREAT | IPC_EXCL | 0666);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“semaphore id=%d/n”, id);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>options.val = 1; /<em>设置变量值</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>semctl(id, 0, SETVAL, options); /<em>设置索引0的信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>打印出信号量的值</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>i = semctl(id, 0, GETVAL, 0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“value of semaphore at index 0 is %d/n”, i);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>下面重新设置信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>lock_it.sem_num = 0; /<em>设置哪个信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>lock_it.sem_op = -1; /<em>定义操作</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>lock_it.sem_flg = IPC_NOWAIT; /<em>操作方式</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>if</strong> (semop(id, &amp;lock_it, 1) == -1) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“can not lock semaphore./n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>exit(1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>i = semctl(id, 0, GETVAL, 0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf(“value of semaphore at index 0 is %d/n”, i);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>/<em>清除信号量</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>semctl(id, 0, IPC_RMID, 0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<p>　　       2.3.5 套接口<br>　　      套接口（socket）编程是实现Linux系统和其他大多数操作系统中进程间通信的主要方式之一。我们熟知的WWW服务、FTP服务、TELNET服务等都是基于套接口编程来实现的。除了在异地的计算机进程间以外，套接口同样适用于本地同一台计算机内部的进程间通信。关于套接口的经典教材同样是Richard Stevens编著的《Unix网络编程：联网的API和套接字》，清华大学出版社出版了该书的影印版。它同样是Linux程序员的必备书籍之一。<br>　　      关于这一部分的内容，可以参照本文作者的另一篇文章《设计自己的网络蚂蚁》，那里由常用的几个套接口函数的介绍和示例程序。这一部分或许是Linux进程间通信编程中最须关注和最吸引人的一部分，毕竟，Internet 正在我们身边以不可思议的速度发展着，如果一个程序员在设计编写他下一个程序的时候，根本没有考虑到网络，考虑到Internet，那么，可以说，他的设计很难成功。</p>
<p>3 Linux的进程和Win32的进程/线程比较<br>　　      熟悉WIN32编程的人一定知道，WIN32的进程管理方式与Linux上有着很大区别，在UNIX里，只有进程的概念，但在WIN32里却还有一个”线程”的概念，那么Linux和WIN32在这里究竟有着什么区别呢？<br>　　      WIN32里的进程/线程是继承自OS/2的。在WIN32里，”进程”是指一个程序，而”线程”是一个”进程”里的一个执行”线索”。从核心上讲，WIN32的多进程与Linux并无多大的区别，在WIN32里的线程才相当于Linux的进程，是一个实际正在执行的代码。但是，WIN32里同一个进程里各个线程之间是共享数据段的。这才是与Linux的进程最大的不同。<br>　　      下面这段程序显示了WIN32下一个进程如何启动一个线程。</p>
<p>[cpp][/cpp]</p>
<p> <a href="http://blog.csdn.net/wallwind/article/details/6899330" title="view plain" target="_blank" rel="external">view plain</a><a href="http://blog.csdn.net/wallwind/article/details/6899330" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><ol>
<li><strong>int</strong> g;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>DWORD</strong> WINAPI ChildProcess( <strong>LPVOID</strong> lpParameter ){   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>for</strong> ( i = 1; i &lt;1000; i ++) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>g ++;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “This is Child Thread: %d/n”, g );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>ExitThread( 0 );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>};   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>void</strong> main()   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> threadID;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>g = 0;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>CreateThread( NULL, 0, ChildProcess, NULL, 0, &amp;threadID );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li><strong>for</strong> ( i = 1; i &lt;1000; i ++) {   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>g ++;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>printf( “This is Parent Thread: %d/n”, g );   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>}   </li>
</ol>
</li>
</ol>
<p>　　       在WIN32下，使用CreateThread函数创建线程，与Linux下创建进程不同，WIN32线程不是从创建处开始运行的，而是由CreateThread指定一个函数，线程就从那个函数处开始运行。此程序同前面的UNIX程序一样，由两个线程各打印1000条信息。threadID是子线程的线程号，另外，全局变量g是子线程与父线程共享的，这就是与Linux最大的不同之处。大家可以看出，WIN32的进程/线程要比Linux复杂，在Linux要实现类似WIN32的线程并不难，只要fork以后，让子进程调用ThreadProc函数，并且为全局变量开设共享数据区就行了，但在WIN32下就无法实现类似fork的功能了。所以现在WIN32下的C语言编译器所提供的库函数虽然已经能兼容大多数Linux/UNIX的库函数，但却仍无法实现fork。<br>　　        对于多任务系统，共享数据区是必要的，但也是一个容易引起混乱的问题，在WIN32下，一个程序员很容易忘记线程之间的数据是共享的这一情况，一个线程修改过一个变量后，另一个线程却又修改了它，结果引起程序出问题。但在Linux下，由于变量本来并不共享，而由程序员来显式地指定要共享的数据，使程序变得更清晰与安全。<br>至于WIN32的”进程”概念，其含义则是”应用程序”，也就是相当于UNIX下的exec了。<br>　　         Linux也有自己的多线程函数pthread，它既不同于Linux的进程，也不同于WIN32下的进程，关于pthread的介绍和如何在Linux环境下编写多线程程序我们将在另一篇文章《Linux下的多线程编程》中讲述。</p>
<pre><code>4 鸣谢
</code></pre><p>　　       本文部分内容参照<a href="http://www.lisoleg.org/" target="_blank" rel="external">www.lisoleg.org</a>内的《Linux下的多进程编程》，原作者俞磊。</p>
<pre><code>The part ends in there.&lt;&lt;
</code></pre><ol>
<li>线程（thread）2-1 介绍</li>
</ol>
<p>线程（thread）技术早在60年代就被提出，但真正应用多线程到操作系统中去，是在80年代中期，solaris是这方面的佼佼者。传统的Unix也支持线程的概念，但是在一个进程（process）中只允许有一个线程，这样多线程就意味着多进程。现在，多线程技术已经被许多操作系统所支持，包括Windows/NT，当然，也包括Linux。<br>为什么有了进程的概念后，还要再引入线程呢？使用多线程到底有哪些好处？什么的系统应该选用多线程？我们首先必须回答这些问题。<br>使用多线程的理由之一是和进程相比，它是一种非常”节俭”的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。<br>使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。<br>除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：<br>1) 提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。<br>2) 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。<br>3) 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。<br>下面我们先来尝试编写一个简单的多线程程序。<br>2 简单的多线程编程<br>Linux系统下的多线程遵循POSIX线程接口，称为pthread。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。顺便说一下，Linux下pthread的实现是通过系统调用clone（）来实现的。clone（）是Linux所特有的系统调用，它的使用方式类似fork，关于clone（）的详细情况，有兴趣的读者可以去查看有关文档说明。下面我们展示一个最简单的多线程程序</p>
<ol>
<li><ol>
<li>/<em> example.c</em>/   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　#include <stdio.h>   </stdio.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　#include <stdlib.h>   </stdlib.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　#include <pthread.h>   </pthread.h></li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　<strong>void</strong> <strong>thread</strong>(<strong>void</strong>)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　    <strong>int</strong> i;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　    <strong>for</strong>(i=0;i&lt;3;i++)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　    printf(“This is a pthread.\n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　}   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　<strong>int</strong> main(<strong>void</strong>)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　{   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   pthread_t id;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>int</strong> i,ret;   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   ret=pthread_create(&amp;id,NULL,(<strong>void</strong> <em>) <em>*thread</em></em>,NULL);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>if</strong>(ret!=0){   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   printf (“Create pthread error!\n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   exit (1);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   }   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>for</strong>(i=0;i&lt;3;i++)   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   printf(“This is the main process.\n”);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   pthread_join(id,NULL);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　   <strong>return</strong> (0);   </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li>　　} </li>
</ol>
</li>
</ol>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p>我们编译此程序：<br>　　gcc example1.c -lpthread -o example1<br>　　运行example1，我们得到如下结果：<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is the main process.<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is a pthread.<br>　　再次运行，我们可能得到如下结果：<br>　　This is a pthread.<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is the main process.<br>　　This is a pthread.<br>　　This is the main process.<br>　　前后两次结果不一样，这是两个线程争夺CPU资源的结果。上面的示例中，我们使用到了两个函数，　pthread_create和pthread_join，并声明了一个pthread_t型的变量。<br>　　pthread_t在头文件/usr/include/bits/pthreadtypes.h中定义：<br>　　typedef unsigned long int pthread_t;<br>　　它是一个线程的标识符。函数pthread_create用来创建一个线程，它的原型为：<br>　　   extern int pthread_create <strong>P ((pthread_t *</strong>thread, <strong>const pthread_attr_t *</strong>attr,<br>　　   void <em>(</em><strong>start_routine) (void <em>), void </em></strong>arg));<br>　　第一个参数为指向线程标识符的指针，第二个参数用来设置线程属性，第三个参数是线程运行函数的起始地址，最后一个参数是运行函数的参数。这里，我们的函数thread不需要参数，所以最后一个参数设为空指针。第二个参数我们也设为空指针，这样将生成默认属性的线程。对线程属性的设定和修改我们将在下一节阐述。当创建线程成功时，函数返回0，若不为0则说明创建线程失败，常见的错误返回代码为EAGAIN和EINVAL。前者表示系统限制创建新的线程，例如线程数目过多了；后者表示第二个参数代表的线程属性值非法。创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。<br>　　函数pthread_join用来等待一个线程的结束。函数原型为：<br>　　   extern int pthread_join <strong>P ((pthread_t </strong>th, void <em>*<strong>thread_return));<br>　　第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，它可以用来存储被等待线程的返回值。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。一个线程的结束有两种途径，一种是象我们上面的例子一样，函数结束了，调用它的线程也就结束了；另一种方式是通过函数pthread_exit来实现。它的函数原型为：<br>　　   extern void pthread_exit </strong>P ((void </em><strong>retval)) </strong>attribute<strong> ((</strong>noreturn__));<br>　　唯一的参数是函数的返回代码，只要pthread_join中的第二个参数thread_return不是NULL，这个值将被传递给thread_return。最后要说明的是，一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread_join的线程则返回错误代码ESRCH。<br>　　在这一节里，我们编写了一个最简单的线程，并掌握了最常用的三个函数pthread_create，pthread_join和pthread_exit。下面，我们来了解线程的一些常用属性以及如何设置这些属性。<br>　　3 修改线程的属性<br>　　在上一节的例子里，我们用pthread_create函数创建了一个线程，在这个线程中，我们使用了默认参数，即将该函数的第二个参数设为NULL。的确，对大多数程序来说，使用默认属性就够了，但我们还是有必要来了解一下线程的有关属性。<br>　　属性结构为pthread_attr_t，它同样在头文件/usr/include/pthread.h中定义，喜欢追根问底的人可以自己去查看。属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。属性对象主要包括是否绑定、是否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。<br>　　关于线程的绑定，牵涉到另外一个概念：轻进程（LWP：Light Weight Process）。轻进程可以理解为内核线程，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状况下，则顾名思义，即某个线程固定的”绑”在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。<br>　　设置线程绑定状态的函数为pthread_attr_setscope，它有两个参数，第一个是指向属性结构的指针，第二个是绑定类型，它有两个取值：PTHREAD_SCOPE_SYSTEM（绑定的）和PTHREAD_SCOPE_PROCESS（非绑定的）。下面的代码即创建了一个绑定的线程。</p>
<p>　　#include <pthread.h><br>　　pthread_attr_t attr;<br>　　pthread_t tid;<br>　　/<em>初始化属性值，均设为默认值</em>/<br>　　pthread_attr_init(&amp;attr);<br>　　pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);<br>　　pthread_create(&amp;tid, &amp;attr, (void *) my_function, NULL); </pthread.h></p>
<p>　　线程的分离状态决定一个线程以什么样的方式来终止自己。在上面的例子中，我们采用了线程的默认属性，即为非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。设置线程分离状态的函数为pthread_attr_setdetachstate（pthread_attr_t *attr, int detachstate）。第二个参数可选为PTHREAD_CREATE_DETACHED（分离线程）和 PTHREAD _CREATE_JOINABLE（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。<br>　　另外一个可能常用的属性是线程的优先级，它存放在结构sched_param中。用函数pthread_attr_getschedparam和函数pthread_attr_setschedparam进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。下面即是一段简单的例子。</p>
<p>　    #include <pthread.h><br>　　#include <sched.h><br>　　pthread_attr_t attr;<br>　　pthread_t tid;<br>　　sched_param param;<br>　　int newprio=20;<br>　　pthread_attr_init(&amp;attr);<br>　　pthread_attr_getschedparam(&amp;attr, &amp;param);<br>　　param.sched_priority=newprio;<br>　　pthread_attr_setschedparam(&amp;attr, &amp;param);<br>　　pthread_create(&amp;tid, &amp;attr, (void <em>)myfunction, myarg);<br>　　4 线程的数据处理<br>　　和进程相比，线程的最大优点之一是数据的共享性，各个进程共享父进程处沿袭的数据段，可以方便的获得、修改数据。但这也给多线程编程带来了许多问题。我们必须当心有多个不同的进程访问相同的变量。许多函数是不可重入的，即同时不能运行一个函数的多个拷贝（除非使用不同的数据段）。在函数中声明的静态变量常常带来问题，函数的返回值也会有问题。因为如果返回的是函数内部静态声明的空间的地址，则在一个线程调用该函数得到地址后使用该地址指向的数据时，别的线程可能调用此函数并修改了这一段数据。在进程中共享的变量必须用关键字volatile来定义，这是为了防止编译器在优化时（如gcc中使用-OX参数）改变它们的使用方式。为了保护变量，我们必须使用信号量、互斥等方法来保证我们对变量的正确使用。下面，我们就逐步介绍处理线程数据时的有关知识。<br>　　4.1 线程数据<br>　　在单线程的程序里，有两种基本的数据：全局变量和局部变量。但在多线程程序里，还有第三种数据类型：线程数据（TSD: Thread-Specific Data）。它和全局变量很象，在线程内部，各个函数可以象使用全局变量一样调用它，但它对线程外部的其它线程是不可见的。这种数据的必要性是显而易见的。例如我们常见的变量errno，它返回标准的出错信息。它显然不能是一个局部变量，几乎每个函数都应该可以调用它；但它又不能是一个全局变量，否则在A线程里输出的很可能是B线程的出错信息。要实现诸如此类的变量，我们就必须使用线程数据。我们为每个线程数据创建一个键，它和这个键相关联，在各个线程里，都使用这个键来指代线程数据，但在不同的线程里，这个键代表的数据是不同的，在同一个线程里，它代表同样的数据内容。<br>　　和线程数据相关的函数主要有4个：创建一个键；为一个键指定线程数据；从一个键读取线程数据；删除键。<br>　　创建键的函数原型为：<br>　　extern int pthread_key_create __P ((pthread_key_t </em><strong>key,<br>　　void (*</strong>destr_function) (void <em>)));<br>　　第一个参数为指向一个键值的指针，第二个参数指明了一个destructor函数，如果这个参数不为空，那么当每个线程结束时，系统将调用这个函数来释放绑定在这个键上的内存块。这个函数常和函数pthread_once ((pthread_once_t</em>once_control, void (<em>initroutine) (void)))一起使用，为了让这个键只被创建一次。函数pthread_once声明一个初始化函数，第一次调用pthread_once时它执行这个函数，以后的调用将被它忽略。<br>　　在下面的例子中，我们创建一个键，并将它和某个数据相关联。我们要定义一个函数createWindow，这个函数定义一个图形窗口（数据类型为Fl_Window </em>，这是图形界面开发工具FLTK中的数据类型）。由于各个线程都会调用这个函数，所以我们使用线程数据。<br>　　/<em> 声明一个键</em>/<br>　　pthread_key_t myWinKey;<br>　　/<em> 函数 createWindow </em>/<br>　　void createWindow ( void ) {<br>　　Fl_Window <em> win;<br>　　static pthread_once_t once= PTHREAD_ONCE_INIT;<br>　　/</em> 调用函数createMyKey，创建键<em>/<br>　　pthread_once ( &amp; once, createMyKey) ;<br>　　/</em>win指向一个新建立的窗口<em>/<br>　　win=new Fl_Window( 0, 0, 100, 100, “MyWindow”);<br>　　/</em> 对此窗口作一些可能的设置工作，如大小、位置、名称等<em>/<br>　　setWindow(win);<br>　　/</em> 将窗口指针值绑定在键myWinKey上<em>/<br>　　pthread_setspecific ( myWinKey, win);<br>　　}<br>　　/</em> 函数 createMyKey，创建一个键，并指定了destructor <em>/<br>　　void createMyKey ( void ) {<br>　　pthread_key_create(&amp;myWinKey, freeWinKey);<br>　　}<br>　　/</em> 函数 freeWinKey，释放空间<em>/<br>　　void freeWinKey ( Fl_Window </em> win){<br>　　delete win;<br>　　}<br>　　这样，在不同的线程中调用函数createMyWin，都可以得到在线程内部均可见的窗口变量，这个变量通过函数pthread_getspecific得到。在上面的例子中，我们已经使用了函数pthread_setspecific来将线程数据和一个键绑定在一起。这两个函数的原型如下：<br>　　extern int pthread_setspecific <strong>P ((pthread_key_t </strong>key,<strong>const void *</strong>pointer));<br>　　extern void <em>pthread_getspecific <strong>P ((pthread_key_t </strong>key));<br>　　这两个函数的参数意义和使用方法是显而易见的。要注意的是，用pthread_setspecific为一个键指定新的线程数据时，必须自己释放原有的线程数据以回收空间。这个过程函数pthread_key_delete用来删除一个键，这个键占用的内存将被释放，但同样要注意的是，它只释放键占用的内存，并不释放该键关联的线程数据所占用的内存资源，而且它也不会触发函数pthread_key_create中定义的destructor函数。线程数据的释放必须在释放键之前完成。<br>　　4.2 互斥锁<br>　　互斥锁用来保证一段时间内只有一个线程在执行一段代码。必要性显而易见：假设各个线程向同一个文件顺序写入数据，最后得到的结果一定是灾难性的。<br>　　我们先看下面一段代码。这是一个读/写程序，它们公用一个缓冲区，并且我们假定一个缓冲区只能保存一条信息。即缓冲区只有两个状态：有信息或没有信息。<br>　　void reader_function ( void );<br>　　void writer_function ( void );<br>　　char buffer;<br>　　int buffer_has_item=0;<br>　　pthread_mutex_t mutex;<br>　　struct timespec delay;<br>　　void main ( void ){<br>　　pthread_t reader;<br>　　/</em> 定义延迟时间<em>/<br>　　delay./</em> <em>/tv_sec = 2;<br>　　delay../</em> <em>/tv_nec = 0;<br>　　/</em> 用默认属性初始化一个互斥锁对象<em>/<br>　　pthread_mutex_init (&amp;mutex,NULL);<br>　　pthread_create(&amp;reader, pthread_attr_default, (void </em>)&amp;reader_function), NULL);<br>　　writer_function( );<br>　　}<br>　　void writer_function (void){<br>　　while(1){<br>　　/<em> 锁定互斥锁</em>/<br>　　pthread_mutex_lock (&amp;mutex);<br>　　if (buffer_has_item==0){<br>　　buffer=make_new_item( );<br>　　buffer_has_item=1;<br>　　}<br>　　/<em> 打开互斥锁</em>/<br>　　pthread_mutex_unlock(&amp;mutex);<br>　　pthread_delay_np(&amp;delay);<br>　　}<br>　　}<br>　　void reader_function(void){<br>　　while(1){<br>　　pthread_mutex_lock(&amp;mutex);<br>　　if(buffer_has_item==1){<br>　　consume_item(buffer);<br>　　buffer_has_item=0;<br>　　}<br>　　pthread_mutex_unlock(&amp;mutex);<br>　　pthread_delay_np(&amp;delay);<br>　　}<br>　　}<br>　　这里声明了互斥锁变量mutex，结构pthread_mutex_t为不公开的数据类型，其中包含一个系统分配的属性对象。函数pthread_mutex_init用来生成一个互斥锁。NULL参数表明使用默认属性。如果需要声明特定属性的互斥锁，须调用函数pthread_mutexattr_init。函数pthread_mutexattr_setpshared和函数pthread_mutexattr_settype用来设置互斥锁属性。前一个函数设置属性pshared，它有两个取值，PTHREAD_PROCESS_PRIVATE和PTHREAD_PROCESS_SHARED。前者用来不同进程中的线程同步，后者用于同步本进程的不同线程。在上面的例子中，我们使用的是默认属性PTHREAD<em>PROCESS</em> PRIVATE。后者用来设置互斥锁类型，可选的类型有PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE和PTHREAD _MUTEX_DEFAULT。它们分别定义了不同的上所、解锁机制，一般情况下，选用最后一个默认属性。<br>　　pthread_mutex_lock声明开始用互斥锁上锁，此后的代码直至调用pthread_mutex_unlock为止，均被上锁，即同一时间只能被一个线程调用执行。当一个线程执行到pthread_mutex_lock处时，如果该锁此时被另一个线程使用，那此线程被阻塞，即程序将等待到另一个线程释放此互斥锁。在上面的例子中，我们使用了pthread_delay_np函数，让线程睡眠一段时间，就是为了防止一个线程始终占据此函数。<br>　　上面的例子非常简单，就不再介绍了，需要提出的是在使用互斥锁的过程中很有可能会出现死锁：两个线程试图同时占用两个资源，并按不同的次序锁定相应的互斥锁，例如两个线程都需要锁定互斥锁1和互斥锁2，a线程先锁定互斥锁1，b线程先锁定互斥锁2，这时就出现了死锁。此时我们可以使用函数pthread_mutex_trylock，它是函数pthread_mutex_lock的非阻塞版本，当它发现死锁不可避免时，它会返回相应的信息，程序员可以针对死锁做出相应的处理。另外不同的互斥锁类型对死锁的处理不一样，但最主要的还是要程序员自己在程序设计注意这一点。<br>　　4.3 条件变量<br>　　前一节中我们讲述了如何使用互斥锁来实现线程间数据的共享和通信，互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。<br>　　条件变量的结构为pthread_cond_t，函数pthread_cond_init（）被用来初始化一个条件变量。它的原型为：<br>　　extern int pthread_cond_init <strong>P ((pthread_cond_t *</strong>cond,<strong>const pthread_condattr_t *</strong>cond_attr));<br>　　其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构pthread_condattr<em>t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用，默认值是PTHREAD</em> PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread<em>cond</em> destroy（pthread_cond_t cond）。　<br>　　函数pthread_cond_wait（）使线程阻塞在一个条件变量上。它的函数原型为：<br>　　extern int pthread_cond_wait <strong>P ((pthread_cond_t *</strong>cond,<br>　　pthread_mutex_t <em><strong>mutex));<br>　　线程解开mutex指向的锁并被条件变量cond阻塞。线程可以被函数pthread_cond_signal和函数pthread_cond_broadcast唤醒，但是要注意的是，条件变量只是起阻塞和唤醒线程的作用，具体的判断条件还需用户给出，例如一个变量是否为0等等，这一点我们从后面的例子中可以看到。线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，一般说来线程应该仍阻塞在这里，被等待被下一次唤醒。这个过程一般用while语句实现。<br>　　另一个用来阻塞线程的函数是pthread_cond_timedwait（），它的原型为：<br>　　extern int pthread_cond_timedwait </strong>P ((pthread_cond_t </em><strong>cond,<br>　　pthread_mutex_t *</strong>mutex, <strong>const struct timespec *</strong>abstime));<br>　　它比函数pthread_cond_wait（）多了一个时间参数，经历abstime段时间后，即使条件变量不满足，阻塞也被解除。<br>　　函数pthread_cond_signal（）的原型为：<br>　　extern int pthread_cond_signal <strong>P ((pthread_cond_t *</strong>cond));<br>　　它用来释放被阻塞在条件变量cond上的一个线程。多个线程阻塞在此条件变量上时，哪一个线程被唤醒是由线程的调度策略所决定的。要注意的是，必须用保护条件变量的互斥锁来保护这个函数，否则条件满足信号又可能在测试条件和调用pthread_cond_wait函数之间被发出，从而造成无限制的等待。下面是使用函数pthread_cond_wait（）和函数pthread_cond_signal（）的一个简单的例子。<br>　　pthread_mutex_t count_lock;<br>　　pthread_cond_t count_nonzero;<br>　　unsigned count;<br>　　decrement_count　() {<br>　　pthread_mutex_lock (&amp;count_lock);<br>　　while(count==0)<br>　　pthread_cond_wait( &amp;count_nonzero, &amp;count_lock);<br>　　count=count -1;<br>　　pthread_mutex_unlock (&amp;count_lock);<br>　　}<br>　　increment_count(){<br>　　pthread_mutex_lock(&amp;count_lock);<br>　　if(count==0)<br>　　pthread_cond_signal(&amp;count_nonzero);<br>　　count=count+1;<br>　　pthread_mutex_unlock(&amp;count_lock);<br>　　}<br>　　count值为0时，decrement函数在pthread_cond_wait处被阻塞，并打开互斥锁count_lock。此时，当调用到函数increment_count时，pthread_cond_signal（）函数改变条件变量，告知decrement_count（）停止阻塞。读者可以试着让两个线程分别运行这两个函数，看看会出现什么样的结果。<br>　　函数pthread_cond_broadcast（pthread_cond_t <em>cond）用来唤醒所有被阻塞在条件变量cond上的线程。这些线程被唤醒后将再次竞争相应的互斥锁，所以必须小心使用这个函数。<br>　　4.4 信号量<br>　　信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。当公共资源增加时，调用函数sem_post（）增加信号量。只有当信号量值大于０时，才能使用公共资源，使用后，函数sem_wait（）减少信号量。函数sem<em>trywait（）和函数pthread</em> mutex_trylock（）起同样的作用，它是函数sem_wait（）的非阻塞版本。下面我们逐个介绍和信号量有关的一些函数，它们都在头文件/usr/include/semaphore.h中定义。<br>　　信号量的数据类型为结构sem_t，它本质上是一个长整型的数。函数sem_init（）用来初始化一个信号量。它的原型为：<br>　　extern int sem_init __P ((sem_t </em><strong>sem, int </strong>pshared, unsigned int __value));<br>　　sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。<br>　　函数sem_post( sem_t <em>sem )用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。<br>　　函数sem_wait( sem_t </em>sem )被用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem_trywait ( sem_t <em>sem )是函数sem_wait（）的非阻塞版本，它直接将信号量sem的值减一。<br>　　函数sem_destroy(sem_t </em>sem)用来释放信号量sem。<br>　　下面我们来看一个使用信号量的例子。在这个例子中，一共有4个线程，其中两个线程负责从文件读取数据到公共的缓冲区，另两个线程从缓冲区读取数据作不同的处理（加和乘运算）。<br>　　/<em> File sem.c </em>/<br>　　#include <stdio.h><br>　　#include <pthread.h><br>　　#include <semaphore.h><br>　　#define MAXSTACK 100<br>　　int stack[MAXSTACK][2];<br>　　int size=0;<br>　　sem_t sem;<br>　　/<em> 从文件1.dat读取数据，每读一次，信号量加一</em>/<br>　　void ReadData1(void){<br>　　FILE <em>fp=fopen(“1.dat”,”r”);<br>　　while(!feof(fp)){<br>　　fscanf(fp,”%d %d”,&amp;stack[0],&amp;stack[1]);<br>　　sem_post(&amp;sem);<br>　　++size;<br>　　}<br>　　fclose(fp);<br>　　}<br>　　/</em>从文件2.dat读取数据<em>/<br>　　void ReadData2(void){<br>　　FILE </em>fp=fopen(“2.dat”,”r”);<br>　　while(!feof(fp)){<br>　　fscanf(fp,”%d %d”,&amp;stack[0],&amp;stack[1]);<br>　　sem_post(&amp;sem);<br>　　++size;<br>　　}<br>　　fclose(fp);<br>　　}<br>　　/<em>阻塞等待缓冲区有数据，读取数据后，释放空间，继续等待</em>/<br>　　void HandleData1(void){<br>　　while(1){<br>　　sem_wait(&amp;sem);<br>　　printf(“Plus:%d+%d=%d\n”,stack[0],stack[1],<br>　　stack[0]+stack[1]);<br>　　–size;<br>　　}<br>　　}<br>　　void HandleData2(void){<br>　　while(1){<br>　　sem_wait(&amp;sem);<br>　　printf(“Multiply:%d<em>%d=%d\n”,stack[0],stack[1],<br>　　stack[0]</em>stack[1]);<br>　　–size;<br>　　}<br>　　}<br>　　int main(void){<br>　　pthread_t t1,t2,t3,t4;<br>　　sem_init(&amp;sem,0,0);<br>　　pthread_create(&amp;t1,NULL,(void <em>)HandleData1,NULL);<br>　　pthread_create(&amp;t2,NULL,(void </em>)HandleData2,NULL);<br>　　pthread_create(&amp;t3,NULL,(void <em>)ReadData1,NULL);<br>　　pthread_create(&amp;t4,NULL,(void </em>)ReadData2,NULL);<br>　　/<em> 防止程序过早退出，让它在此无限期等待</em>/<br>　　pthread_join(t1,NULL);<br>　　}<br>　　在Linux下，我们用命令gcc -lpthread sem.c -o sem生成可执行文件sem。 我们事先编辑好数据文件1.dat和2.dat，假设它们的内容分别为1 2 3 4 5 6 7 8 9 10和 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 ，我们运行sem，得到如下的结果：<br>　　Multiply:-1<em>-2=2<br>　　Plus:-1+-2=-3<br>　　Multiply:9</em>10=90<br>　　Plus:-9+-10=-19<br>　　Multiply:-7<em>-8=56<br>　　Plus:-5+-6=-11<br>　　Multiply:-3</em>-4=12<br>　　Plus:9+10=19<br>　　Plus:7+8=15<br>　　Plus:5+6=11<br>　　从中我们可以看出各个线程间的竞争关系。而数值并未按我们原先的顺序显示出来这是由于size这个数值被各个线程任意修改的缘故。这也往往是多线程编程要注意的问题。<br>　　5 小结<br>　　多线程编程是一个很有意思也很有用的技术，使用多线程技术的网络蚂蚁是目前最常用的下载工具之一，使用多线程技术的grep比单线程的grep要快上几倍，类似的例子还有很多。希望大家能用多线程技术写出高效实用的好程序来。</semaphore.h></pthread.h></stdio.h></sched.h></pthread.h></p>
<p>Last!!!!!!!!!Linux内核对多进程和多线程的支持方式：</p>
<pre><code>线程机制支持并发程序设计技术，在多处理器上能真正保证并行处理。而在linux实现线程很特别，linux把所有的线程都当作进程实现。linux下线程看起来就像普通进程(只是该进程和其他进程共享资源，如地址空间)。上述机制与Microsoft windows或是Sun Solaris实现差异很大。




Linux的线程实现是在核外进行的，核内提供的是创建进程的接口do_fork()。内核提供了两个系统调用__clone()和fork()，最终都用不同的参数调用do_fork()核内API。 do_fork() 提供了很多参数，包括CLONE_VM（共享内存空间）、CLONE_FS（共享文件系统信息）、CLONE_FILES（共享文件描述符表）、CLONE_SIGHAND（共享信号句柄表）和CLONE_PID（共享进程ID，仅对核内进程，即0号进程有效）。当使用fork系统调用产生多进程时，内核调用do_fork()不使用任何共享属性，进程拥有独立的运行环境。当使用pthread_create()来创建线程时，则最终设置了所有这些属性来调用__clone()，而这些参数又全部传给核内的do_fork()，从而创建的”进程”拥有共享的运行环境，只有栈是独立的，由 __clone()传入。




 即：Linux下**不管是多线程编程还是多进程编程，最终都是用do_fork实现**的多进程编程，只是进程创建时的参数不同，从而导致有不同的共享环境。Linux线程在核内是以轻量级进程的形式存在的，拥有独立的进程表项，而所有的创建、同步、删除等操作都在核外pthread库中进行。pthread 库使用一个管理线程（__pthread_manager() ，每个进程独立且唯一）来管理线程的创建和终止，为线程分配线程ID，发送线程相关的信号，而主线程pthread_create()） 的调用者则通过管道将请求信息传给管理线程。
</code></pre><p>很多朋友都说使用多线程的好处是资源占用少，其隐含之意就是说进程占用资源比线程多，对吧？但实际上Linux下多进程是否就真的点用很多资源呢？暂且不说进程是否比线程占用资源多，就进程占用资源的多少情况而言，Linux确实是做得相当节省的。产生一个多进程时肯定是要产生的一点内存是要复制进程表项，即一个task_struct结构，但这个结构本身做得相当小巧。其它对于一个进程来说必须有的数据段、代码段、堆栈段是不是全盘复制呢？对于多进程来说，代码段是肯定不用复制的，因为父进程和各子进程的代码段是相同的，数据段和堆栈段呢？也不一定，因为在Linux里广泛使用的一个技术叫copy-on-write，即写时拷贝。copy-on-write意味着什么呢？意味着资源节省，假设有一个变量x在父进程里存在，当这个父进程创建一个子进程或多个子进程时这个变量x是否复制到了子进程的内存空间呢？不会的，子进程和父进程使用同一个内存空间的变量，但当子进程或父进程要改变变量x的值时就会复制该变量，从而导致父子进程里的变量值不同。<strong>父子进程变量是互不影响的，由于父子进程地址空间是完全隔开的，变量的地址可以是完全相同的</strong>。</p>
<pre><code> Linux的”线程”和”进程”实际上处于一个调度层次，共享一个进程标识符空间，这种限制使得不可能在Linux上实现完全意义上的POSIX线程机制，因此众多的Linux线程库实现尝试都只能尽可能实现POSIX的绝大部分语义，并在功能上尽可能逼近。Linux进程的创建是非常迅速的。内核设计与实现一书中甚至指出Linux创建进程的速度和其他针对线程优化的操作系统（Windows,Solaris）创建线程的速度相比，测试结果非常的好，也就是说创建速度很快。由于异步信号是内核以进程为单位分发的，而LinuxThreads的每个线程对内核来说都是一个进程，且没有实现”线程组”，因此，某些语义不符合POSIX标准，比如没有实现向进程中所有线程发送信号，README对此作了说明。LinuxThreads中的线程同步很大程度上是建立在信号基础上的，这种通过内核复杂的信号处理机制的同步方式，效率一直是个问题。LinuxThreads 的问题，特别是兼容性上的问题，严重阻碍了Linux上的跨平台应用（如Apache）采用多线程设计，从而使得Linux上的线程应用一直保持在比较低的水平。在Linux社区中，已经有很多人在为改进线程性能而努力，其中既包括用户级线程库，也包括核心级和用户级配合改进的线程库。目前最为人看好的有两个项目，一个是RedHat公司牵头研发的NPTL（Native Posix Thread Library），另一个则是IBM投资开发的NGPT（Next Generation Posix Threading），二者都是围绕完全兼容POSIX 1003.1c，同时在核内和核外做工作以而实现多对多线程模型。这两种模型都在一定程度上弥补了LinuxThreads的缺点，且都是重起炉灶全新设计的。




 综上所述的**结论是在Linux下编程多用多进程编程少用多线程编程**。




IBM有个家伙做了个测试，发现切换线程context的时候，windows比linux快一倍多。进出最快的锁（windows2k的 critical section和linux的pthread_mutex），windows比linux的要快五倍左右。当然这并不是说linux不好，而且在经过实际编程之后，综合来看我觉得linux更适合做high performance server，不过在多线程这个具体的领域内，linux还是稍逊windows一点。这应该是情有可原的，毕竟unix家族都是从多进程过来的，而 windows从头就是多线程的。
</code></pre><p>如果是UNIX/linux环境，采用多线程没必要。</p>
<p>多线程比多进程性能高？误导！</p>
<p>应该说，<strong>多线程比多进程成本低，但性能更低</strong>。</p>
<p>在UNIX环境，多进程调度开销比多线程调度开销，没有显著区别，就是说，UNIX进程调度效率是很高的。内存消耗方面，二者只差全局数据区，现在内存都很便宜，服务器内存动辄若干G，根本不是问题。</p>
<p><strong>多进程是立体交通系统，虽然造价高，上坡下坡多耗点油，但是不堵车。</strong></p>
<p><strong>多线程是平面交通系统，造价低，但红绿灯太多，老堵车。</strong></p>
<p>我们现在都开跑车，油（主频）有的是，不怕上坡下坡，就怕堵车。</p>
<p>高性能交易服务器中间件，如TUXEDO，都是主张多进程的。实际测试表明，TUXEDO性能和并发效率是非常高的。TUXEDO是贝尔实验室的，与UNIX同宗，应该是对UNIX理解最为深刻的，他们的意见应该具有很大的参考意义。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/05/01/ug-e4-ba-8c-e6-ac-a1-e5-bc-80-e5-8f-91ugvs2013-e7-9a-84-e9-85-8d-e7-bd-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/01/ug-e4-ba-8c-e6-ac-a1-e5-bc-80-e5-8f-91ugvs2013-e7-9a-84-e9-85-8d-e7-bd-ae/" itemprop="url">[UG二次开发]UG+VS2013 的配置</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-01T23:36:43+08:00">
                2015-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机械/" itemprop="url" rel="index">
                    <span itemprop="name">机械</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>手工搭建Win32项目文件？？（测试VS2005可行，VS2013可行）</p>
<ol>
<li>在工程属性的 C/C++ → General常规 → Additional Include Directories附加包含目录中添加NXOpen链接库路径$(UGII_BASE_DIR)\ugopen </li>
</ol>
<pre><code>![](/wp-content/uploads/2015/05/050115_1536_UGUGVS201.png)
</code></pre><ol>
<li>Linker连接器→ General常规→Additional Include Directories附加包含目录中添加NXOpen链接库路径$(UGII_BASE_DIR)\ugopen </li>
</ol>
<pre><code>![](/wp-content/uploads/2015/05/050115_1536_UGUGVS202.png)
</code></pre><ol>
<li>添加预编译宏_SECURE_SCL=0; 到工程属性C/C++→ Preprocessor预处理器→ Preprocessor Definitions预处理器定义 </li>
</ol>
<pre><code>![](/wp-content/uploads/2015/05/050115_1536_UGUGVS203.png)
</code></pre><ol>
<li>在工程属性的 Linker链接器→ Input输入→ Additional Dependencies附加依赖项 根据需要添加以下链接库 </li>
</ol>
<pre><code>libufun.lib  支持 UFUNC API 函数库 
</code></pre><p>libugopenint.lib  支持 UFUNC对话框 API 函数库 </p>
<p>libnxopencpp.lib  支持 NXOpenAPI函数库 </p>
<p>libnxopenuicpp.lib  支持 NXOpen对话框即Block UI Styler API 函数库 </p>
<p><img src="/wp-content/uploads/2015/05/050115_1536_UGUGVS204.png" alt=""></p>
<p>注意：在调试时使用多线程调试 </p>
<p><img src="/wp-content/uploads/2015/05/050115_1536_UGUGVS205.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/04/30/282/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/30/282/" itemprop="url">[UG]基于C++的UG自动尺寸标注</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-30T11:30:57+08:00">
                2015-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机械/" itemprop="url" rel="index">
                    <span itemprop="name">机械</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写了那么多参考的，现在终于要开始填UG的大坑了。。。</p>
<pre><code>首先，对于自动标注尺寸而言，我觉得可以对下面的几种情况进行标注：
</code></pre><ul>
<li><p>圆柱或者孔的直径</p>
</li>
<li><p>两个互相平行的平面的距离（通常情况下是板厚、零件的长度（要注意误差的问题））</p>
</li>
<li><p>倒角、倒圆、圆角（大部分情况下可以全局设定）</p>
</li>
<li><p>模锻斜度，模锻圆角</p>
</li>
<li><p>表面粗糙度（这个C++不好判定，只能给一个全局的设定）</p>
</li>
<li><p>球的直径</p>
</li>
<li><p>起模斜度（这个默认是1°，感觉不需要考虑了）</p>
</li>
</ul>
<p>其次，我采用Microsoft Visual Studio Ultimate 2012 和 NX8.5来对UG进行二次开发，在这里，我调用了UG的Open API接口进行C语言的编程，具体的配置方法，请查看：<a href="http://www.cnblogs.com/hachi/p/3190689.html" target="_blank" rel="external">VS2010和UG7.0的联合配置</a>，这里我查阅了NX8.5的Open API接口（还在研读= =、、、英语的API好XXXX啊）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/04/23/e6-9c-ba-e6-a2-b0-e5-8e-9f-e7-90-86python-e5-b9-b3-e9-9d-a2-e8-bf-9e-e6-9d-86-e6-9c-ba-e6-9e-84-e7-9a-84-e8-bf-90-e5-8a-a8-e5-88-86-e6-9e-90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/23/e6-9c-ba-e6-a2-b0-e5-8e-9f-e7-90-86python-e5-b9-b3-e9-9d-a2-e8-bf-9e-e6-9d-86-e6-9c-ba-e6-9e-84-e7-9a-84-e8-bf-90-e5-8a-a8-e5-88-86-e6-9e-90/" itemprop="url">[机械原理][Python]平面连杆机构的运动分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-23T17:30:24+08:00">
                2015-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/机械/" itemprop="url" rel="index">
                    <span itemprop="name">机械</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PDF文章下载（严禁将本文章包括但不限于用于作弊、抄袭的用途上，欢迎指出问题！）：<a href="http://pan.baidu.com/s/1hqxRhju" target="_blank" rel="external">http://pan.baidu.com/s/1hqxRhju</a><br><strong><img src="/wp-content/uploads/2015/04/042315_0932_Python1.png" alt="">    如图所示为一个牛头刨床（III级机构），假设各个构件尺寸如图表所示，原动件1以等角速度ω=1 rad/s沿逆时针方向回转，试求各从动件的角位移，角速度以及角加速度以及刨头C点的位移、速度以及角加速度的变化情况。
</strong></p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python2.png" alt=""></p>
<p>首先，我们由AEDB和EDC的两个四边形中，获得几何关系(由于本弱还不知道怎么往网页里面插入Latex，所以只能拿Source Code Pro来凑数了)</p>
<p>l4<em>coso4 + s3</em>coso3 = h2 + l1*coso1</p>
<p>l4<em>sino4 + s3</em>sino3 = h1 + l1*sino1</p>
<p>l4<em>coso4 + l3</em>coso3 – s5 = 0</p>
<p>l4<em>sino4 + l3</em>sino3 = h</p>
<p>直接使用最小二次迭代法求出o3,o4,s5,s3</p>
<p>由于此时求出了o3,o4,s5,s3，对上面这个方程求导即可</p>
<p>2.速度求解：</p>
<p>-l4<em>sino4</em>w4 + s3’<em>coso3 – s3</em>sino3<em>w3 = -l1</em>sino1*w1</p>
<p>l4<em>coso4</em>w4 + s3’<em>sino3 + s3</em>coso3<em>w3 = l1</em>coso1*w1</p>
<p>-l4<em>sino4</em>w4 – l3<em>sino3</em>w3 – s5’ = 0</p>
<p>l4<em>coso4</em>w4 + l3<em>coso3</em>w3 = 0</p>
<p>给出矩阵式：</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python3.png" alt=""></p>
<p>利用高斯消元（解线性方程组）可以得到角速度w3，w4</p>
<p>3.加速度求解</p>
<p>继续对线性方程组进行微分可得：</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python4.png" alt=""></p>
<p>角加速度a3和a4就被解出来了</p>
<p>下面附上第一组的python解法…</p>
<p>机构的位置：</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python5.png" alt=""></p>
<p>速度的解：</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python6.png" alt=""></p>
<p>角速度的解</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python7.png" alt=""></p>
<p>A3的角加速度（好像有个峰值= =、、、）</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python8.png" alt=""></p>
<p>A4的角加速度（小多啦= =、、）</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python9.png" alt=""></p>
<p>由于这个是周期性的 表示本弱画了一张极坐标图片！</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python10.png" alt=""></p>
<p>A3和A5的加速度分析</p>
<p><img src="/wp-content/uploads/2015/04/042315_0932_Python11.png" alt=""></p>
<p>最后附上Python源码（python写的略挫不要介意= =、、、）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">__author__ = &apos;kido&apos;</div><div class="line">import numpy</div><div class="line">from numpy import dot</div><div class="line">from scipy.optimize import fsolve</div><div class="line">from matplotlib.ticker import MultipleLocator</div><div class="line">from math import cos</div><div class="line">from math import sin</div><div class="line">from math import asin</div><div class="line">from math import sqrt  # using hudu!</div><div class="line">import math</div><div class="line">import matplotlib.pylab as plt</div><div class="line">import threading</div><div class="line">def draw1():</div><div class="line">    plt.figure(1)  # location</div><div class="line">    plt.plot(lio1, lis3, label=&quot;s3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">    plt.plot(lio1, lis5, &quot;b--&quot;, label=&quot;s5&quot;)</div><div class="line">    plt.xlabel(&quot;angle&quot;)</div><div class="line">    plt.ylabel(&quot;length&quot;)</div><div class="line">    plt.title(&quot;length of data&quot;)</div><div class="line"></div><div class="line">    plt.legend()</div><div class="line">    plt.show()</div><div class="line"></div><div class="line">def draw2():</div><div class="line">    plt.figure(2)  # linear speed</div><div class="line">    plt.plot(lio1, liv3, label=&quot;v3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">    plt.plot(lio1, liv5, &quot;b--&quot;, label=&quot;v5&quot;)</div><div class="line"></div><div class="line">    plt.xlabel(&quot;angle&quot;)</div><div class="line">    plt.ylabel(&quot;linear speed&quot;)</div><div class="line">    plt.title(&quot;Graph B&quot;)</div><div class="line"></div><div class="line">    plt.legend()</div><div class="line">    plt.show()</div><div class="line"></div><div class="line">def draw3():</div><div class="line">    plt.figure(3)  # radius speed</div><div class="line">    plt.plot(lio1, liw3, label=&quot;w3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">    plt.plot(lio1, liw4, &quot;b--&quot;, label=&quot;w4&quot;)</div><div class="line"></div><div class="line">    plt.xlabel(&quot;angle&quot;)</div><div class="line">    plt.ylabel(&quot;Radius speed&quot;)</div><div class="line">    plt.title(&quot;Graph B&quot;)</div><div class="line"></div><div class="line">    plt.legend()</div><div class="line">    plt.show()</div><div class="line"></div><div class="line">def draw4():</div><div class="line">    plt.figure(4)  # radius accerlation</div><div class="line">    plt.plot(lio1, lia3, label=&quot;a3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">    plt.plot(lio1, lia4, &quot;b--&quot;, label=&quot;a4&quot;)</div><div class="line"></div><div class="line">    plt.xlabel(&quot;angle&quot;)</div><div class="line">    plt.ylabel(&quot;accleration&quot;)</div><div class="line">    plt.title(&quot;Graph B&quot;)</div><div class="line"></div><div class="line">    plt.legend()</div><div class="line">    plt.show()</div><div class="line"></div><div class="line">def gauss(a, b):</div><div class="line">    n = len(b)</div><div class="line">    for i in range(0, n - 1):</div><div class="line">        for j in range(i + 1, n):</div><div class="line">            # print a[j,i]</div><div class="line">            if a[j, i] != 0.0:</div><div class="line">                lam = float(a[j, i]) / a[i, i]</div><div class="line">                a[j, (i + 1):n] = a[j, (i + 1):n] - lam * a[i, (i + 1):n]</div><div class="line">                b[j] = b[j] - lam * b[i]</div><div class="line">    for k in range(n - 1, -1, -1):</div><div class="line">        b[k] = (b[k] - dot(a[k, (k + 1):n], b[(k + 1):n])) / a[k, k]</div><div class="line">    result = b</div><div class="line">    return result</div><div class="line"></div><div class="line">def foo(x):</div><div class="line">    # s3,s5,o3,o4 =x.tolist()</div><div class="line">    s3 = float(x[0])</div><div class="line">    s5 = float(x[1])</div><div class="line">    o3 = float(x[2])</div><div class="line">    o4 = float(x[3])</div><div class="line">    return [</div><div class="line">        l4 * cos(o4) + s3 * cos(o3) - h2 - l1 * cos(o1),</div><div class="line">        l4 * sin(o4) + s3 * sin(o3) - h1 - l1 * sin(o1),</div><div class="line">        l4 * cos(o4) + l3 * cos(o3) - s5,</div><div class="line">        l4 * sin(o4) + l3 * sin(o3) - h</div><div class="line">    ]</div><div class="line"></div><div class="line"># -----main function-----</div><div class="line">print &apos;Now please input your number,indivivually AB,CD,DE,h,h1,h2 :)\nattention : use , under English Input type!&apos;</div><div class="line">lis3 =[]</div><div class="line">liw3 =[]</div><div class="line">liw4 =[]</div><div class="line">liv3 =[]</div><div class="line">lis5 =[]</div><div class="line">liv5 =[]</div><div class="line">lia3 =[]</div><div class="line">lia4 =[]</div><div class="line">lio1 =[]</div><div class="line">lia5 =[]</div><div class="line">liap3 =[]</div><div class="line">il1, il3, il4, ih, ih1, ih2 = input()</div><div class="line">l1 = float(il1)</div><div class="line">l3 = float(il3)</div><div class="line">l4 = float(il4)</div><div class="line">h = float(ih)</div><div class="line">h1 = float(ih1)</div><div class="line">h2 = float(ih2)</div><div class="line">o1 = 0</div><div class="line">w1 = 1</div><div class="line">print &apos;# Make Sure : &apos;, l1, l3, l4, h, h1, h2</div><div class="line">print &apos;# Radius rate is : &apos;, w1, &apos;rad/s&apos;</div><div class="line">print &apos;# Guessing matrix : &apos;, [l3 * h1 / h, l4 + sqrt(l3 * l3 - h * h), asin(h / l3), 0]</div><div class="line">while (o1     lio1.append(o1)</div><div class="line">    result = fsolve(foo, [l3 * h1 / h, l4 + sqrt(l3 * l3 - h * h), asin(h / l3), 0])</div><div class="line">    #print &apos;# Bais : &apos;, max(foo(result))</div><div class="line">    s3, s5, o3, o4 = result  #get !</div><div class="line">    #print &quot;result&quot;, result</div><div class="line">    #-----------storage data------------</div><div class="line">    lis3.append(s3)</div><div class="line">    lis5.append(s5)</div><div class="line"></div><div class="line">    #-----------calcualte Rate----------</div><div class="line">    x = numpy.matrix([[cos(o3), 0 - s3 * sin(o3), 0 - l4 * sin(o4), 0], [sin(o3), s3 * cos(o3), l4 * cos(o4), 0],</div><div class="line">                      [0, 0 - l3 * sin(o3), 0 - l4 * sin(o4), -1], [0, l3 * cos(o3), l4 * cos(o4), 0]],</div><div class="line">                     dtype=numpy.float)</div><div class="line">    #print x</div><div class="line">    aa = numpy.matrix([[cos(o3), 0 - s3 * sin(o3), 0 - l4 * sin(o4), 0], [sin(o3), s3 * cos(o3), l4 * cos(o4), 0],</div><div class="line">                       [0, 0 - l3 * sin(o3), 0 - l4 * sin(o4), -1], [0, l3 * cos(o3), l4 * cos(o4), 0]],</div><div class="line">                      dtype=numpy.float)</div><div class="line">    y = numpy.array([0 - l1 * sin(o1), l1 * cos(o1), 0, 0], dtype=numpy.float)</div><div class="line">    #print y</div><div class="line">    rad = gauss(x, y)</div><div class="line">    ds3 = numpy.float64(rad[0])</div><div class="line">    w3 = numpy.float64(rad[1])</div><div class="line">    w4 = numpy.float64(rad[2])</div><div class="line">    ds5 = numpy.float64(rad[3])</div><div class="line">    #----storage the data------</div><div class="line">    liw3.append(w3)</div><div class="line">    liw4.append(w4)</div><div class="line">    liv3.append(ds3)</div><div class="line">    liv5.append(ds5)</div><div class="line"></div><div class="line">    #print &quot;at this point &quot; + &quot;w3 :&quot;, w3, &quot;w4&quot;, w4</div><div class="line">    #------calculating accleration-------</div><div class="line">    poi = numpy.matrix([[0 - w3 * sin(o3), 0 - ds3 * sin(o3) - s3 * w3 * cos(o3), 0 - l4 * w4 * cos(o4), 0],</div><div class="line">                        [0 - w3 * cos(o3), 0 - ds3 * cos(o3) - s3 * w3 * sin(o3), 0 - l4 * w4 * sin(o4), 0],</div><div class="line">                        [0, 0 - l3 * w3 * cos(o3), 0 - l4 * w4 * cos(o4), 0],</div><div class="line">                        [0, 0 - l3 * w3 * sin(o3), 0 - l4 * w4 * sin(o4), 0]], dtype=numpy.float)</div><div class="line">    new = dot(poi, rad)*(-1) + numpy.matrix([0 - l1 * w1 * cos(o1), 0 - l1 * w1 * sin(o1), 0, 0], dtype=numpy.float)</div><div class="line">    #print new</div><div class="line">    aspe = gauss(aa, new)</div><div class="line">    #print &quot;gauss : &quot;, aspe</div><div class="line">    #-------------storage data-------</div><div class="line">    a3 = float(aspe[0, 1])</div><div class="line">    a4 = float(aspe[0, 2])</div><div class="line">    lia3.append(a3)</div><div class="line">    lia4.append(a4)</div><div class="line">    liap3.append(float(aspe[0,0]))</div><div class="line">    lia5.append(float(aspe[0,3]))</div><div class="line">    #---spin a new round!----</div><div class="line">    o1 += math.pi / 500</div><div class="line">    #lio1.append(o1)</div><div class="line"></div><div class="line">#--------draw a picture?</div><div class="line">print &quot;lis5&quot;, lis5</div><div class="line">print &quot;lis3&quot;, lis3</div><div class="line">print &quot;lio1&quot;, lio1</div><div class="line">plt.figure(6)</div><div class="line">plt.subplot(111,polar=True)</div><div class="line">plt.plot(lio1, liap3, label=&quot;a3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, lia5, &quot;b--&quot;, label=&quot;a5&quot;)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;length&quot;)</div><div class="line">plt.title(&quot;A5&apos;s acceleration&quot;)</div><div class="line"></div><div class="line">#plt.thetagrids([0,45])</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line"></div><div class="line">plt.figure(5,figsize=(8,8))</div><div class="line">plt.subplot(221,polar=True)</div><div class="line">plt.plot(lio1, lis3, label=&quot;s3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, lis5, &quot;b--&quot;, label=&quot;s5&quot;)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;length&quot;)</div><div class="line">plt.title(&quot;location&quot;)</div><div class="line">maxn=numpy.max(lis3)</div><div class="line">minn=numpy.min(lis3)</div><div class="line">plt.rgrids(numpy.arange(minn,maxn,100),angle=45)</div><div class="line">#plt.thetagrids([0,45])</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line"></div><div class="line">plt.subplot(222,polar=True)</div><div class="line">plt.plot(lio1, liv3, label=&quot;v3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, liv5, &quot;b--&quot;, label=&quot;v5&quot;)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;speed&quot;)</div><div class="line">plt.title(&quot;speed&quot;)</div><div class="line">maxn=numpy.max(liv3)</div><div class="line">minn=0-numpy.min(liv3)</div><div class="line">#plt.rgrids(numpy.arange(minn,maxn,100),angle=45)</div><div class="line">#plt.thetagrids([0,45])</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line"></div><div class="line">plt.subplot(223,polar=True)</div><div class="line">plt.plot(lio1, liw4, label=&quot;w4&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, liw3, &quot;b--&quot;, label=&quot;w3&quot;)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;length&quot;)</div><div class="line">plt.title(&quot;radius speed&quot;)</div><div class="line">maxn=numpy.max(liw3)</div><div class="line">minn=numpy.min(liw3)</div><div class="line">#plt.rgrids(numpy.arange(minn,maxn,100),angle=45)</div><div class="line">#plt.thetagrids([0,45])</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line"></div><div class="line">plt.subplot(224,polar=True)</div><div class="line">plt.plot(lio1, lia4, label=&quot;a4&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, lia3, &quot;b--&quot;, label=&quot;a3&quot;)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;length&quot;)</div><div class="line">plt.title(&quot;acceleration&quot;)</div><div class="line"></div><div class="line">#plt.rgrids(numpy.arange(minn,maxn,100),angle=45)</div><div class="line">#plt.thetagrids([0,45])</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line">plt.legend()</div><div class="line"></div><div class="line">plt.figure(1)  # location</div><div class="line">plt.plot(lio1, lis3, label=&quot;s3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, lis5, &quot;b--&quot;, label=&quot;s5&quot;)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;length&quot;)</div><div class="line">plt.title(&quot;length of data&quot;)</div><div class="line">plt.grid()</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line"></div><div class="line">plt.legend()</div><div class="line">#plt.show()</div><div class="line"></div><div class="line">plt.figure(2)  # linear speed</div><div class="line">plt.plot(lio1, liv3, label=&quot;v3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, liv5, &quot;b--&quot;, label=&quot;v5&quot;)</div><div class="line"></div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;linear speed&quot;)</div><div class="line">plt.title(&quot;Graph B&quot;)</div><div class="line">plt.grid()</div><div class="line"></div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line"></div><div class="line">plt.legend()</div><div class="line">#plt.show()</div><div class="line"></div><div class="line">plt.figure(3)  # radius speed</div><div class="line">plt.plot(lio1, liw3, label=&quot;w3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.plot(lio1, liw4, &quot;b--&quot;, label=&quot;w4&quot;)</div><div class="line"></div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;Radius speed&quot;)</div><div class="line">plt.title(&quot;Graph B&quot;)</div><div class="line">plt.grid()</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line">plt.legend()</div><div class="line">#plt.show()</div><div class="line"></div><div class="line">plt.figure(4)  # radius accerlation</div><div class="line">plt.plot(lio1, lia3, label=&quot;a3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">print &quot;lio1 :&quot;,lio1</div><div class="line">print &quot;lia3 :&quot;,lia3</div><div class="line">print &quot;lia4 :&quot;,lia4</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;accleration&quot;)</div><div class="line">plt.title(&quot;Graph B&quot;)</div><div class="line">plt.grid()</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line">plt.legend()</div><div class="line"></div><div class="line">plt.figure(7)  # radius accerlation</div><div class="line"></div><div class="line">plt.plot(lio1, lia4, &quot;b--&quot;, label=&quot;a4&quot;)</div><div class="line"></div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot;accleration&quot;)</div><div class="line">plt.title(&quot;Graph B&quot;)</div><div class="line">plt.grid()</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line">plt.legend()</div><div class="line"></div><div class="line">plt.figure(10)  # radius accerlation</div><div class="line">plt.subplot(121)</div><div class="line">plt.plot(lio1, lia5, label=&quot;a3&quot;, color=&quot;red&quot;, linewidth=2)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot; accleration&quot;)</div><div class="line">plt.title(&quot;A3&quot;)</div><div class="line">plt.grid()</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line">plt.subplot(122)</div><div class="line">plt.plot(lio1, liap3, &quot;b--&quot;, label=&quot;a4&quot;)</div><div class="line">plt.xlabel(&quot;angle&quot;)</div><div class="line">plt.ylabel(&quot; accleration&quot;)</div><div class="line">plt.title(&quot;A5&quot;)</div><div class="line"></div><div class="line">plt.grid()</div><div class="line">ax=plt.gca()</div><div class="line">ax.xaxis.set_major_locator(MultipleLocator(numpy.pi/4))</div><div class="line">plt.legend()</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/04/18/e6-9c-ba-e6-a2-b0-e6-9c-ba-e6-a2-b0-e7-9a-84-e6-a0-87-e6-b3-a8-e6-96-b9-e6-b3-95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/18/e6-9c-ba-e6-a2-b0-e6-9c-ba-e6-a2-b0-e7-9a-84-e6-a0-87-e6-b3-a8-e6-96-b9-e6-b3-95/" itemprop="url">[机械]机械的标注方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-18T14:27:11+08:00">
                2015-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机械/" itemprop="url" rel="index">
                    <span itemprop="name">机械</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>零件图尺寸的标注</li>
</ol>
<pre><code>1.  技术要求：
</code></pre><p>使用规定的符号或者汉子来说明零件在制造检验或者装配的时候应该达到的各项要求。</p>
<pre><code>2.  尺寸标注的清晰


        1.  内外分注


将零件内部的结构的尺寸和外部形体的尺寸尽量分别标注在视图的两侧，而且使同一方向的连续几个尺寸尽量放在一条线上。零件的轴向尺寸中，凡事位于外部尺寸的均注于视图的上方，反之则标注于视图的下方。零件的径向尺寸，由于零件的结构特点所致，其内外直径尺寸就近向两端标注。


        1.  集中与分散


为了便于加工、检验时查找尺寸。


        1.  合理选择尺寸基准
</code></pre><p>任何一个零件都有长、宽、高三个方向（或轴向、径向两方向）的尺寸，每个尺寸都有基准，因此每个方向至少要有一个基准。同一方向上有多个基准时，其中必定有一个基准是主要的，称为主要基准；其余的其基准则为辅助基准。主要基准与辅助基准之间应有尺寸联系。</p>
<ul>
<li>设计基准</li>
</ul>
<p>根据机器的结构和设计要求，用以确定零件的机器中位置的一些面、线、点，称为设计基准。其目的是反应对零件的设计要求，保证零件在机器中的工作性能。</p>
<ul>
<li>工艺基准</li>
</ul>
<p>零件在加工过程中，用来确定机床的装卡位置的基准和测定零件尺寸时所用的基准。目的是反应对零件的工艺要求，便于零件的加工、制造和测量、检验。例如圆柱段都需要保证在同一条轴线上，使得齿轮转动平稳，从而选择<strong>轴线</strong>作为设计基准。应该指出，在机器的结构要求以及装配要求决定之后，零件的设计基准是比较容易确定的。</p>
<p><img src="/wp-content/uploads/2015/04/041815_0626_1.png" alt=""></p>
<ol>
<li>尺寸的合理标注</li>
</ol>
<p>主要尺寸：保证零件在机器中的正确位置和装配精度的尺寸。由于这类尺寸将直接影响到机器的工作性能，一般标注主要尺寸时应该直接注出，并且在尺寸数字之后注出极限偏差值，以保证尺寸的精度要求。</p>
<p>零件之中常见的主要尺寸：</p>
<ul>
<li><p>齿轮轴的中心距尺寸</p>
</li>
<li><p>孔与轴之间的配合尺寸</p>
</li>
</ul>
<ol>
<li>避免尺寸的封闭</li>
</ol>
<p>在一个尺寸链之中，总是有一个尺寸是在加工最后自然得到的，这个尺寸称之为封闭环。在实际标注尺寸是应该留有一个不影响工作性能和要求的尺寸段作为封闭段，并且将零件加工时所产生的<strong>误差</strong>集中到该环之上。封闭的尺寸链是首尾相接，形成一个封闭圈一组尺寸。图2a中，已汪出各段尺寸a、b、c，如再注出总长e，这四个尺寸就构成了封闭尺寸链，每个尺寸为尺寸链中的组成环。根据尺寸标注形式对尺寸误差的分析，尺寸链中任一环的尺寸误差，都等于其他各环的尺寸误差之和。因此，如注成封闭尺寸链，欲同时满足各组成环的尺寸精度是办不到的。<br>因此，标注尺寸时应在尺寸链中选一个不重要的环不注尺寸，该环称为开口环，例如长度方向的未注尺寸段。开口环的尺寸误差等于其他各环尺寸误差之和，因为它不重要，在加工中最后形成，使误差积累到这个开口环上去（加工时不测量），该环尺寸精度不予保证对零件设计要求没有影响，从面保证了其他各组成环的尺寸精度。<br>图5所示的小轴，其长度方向尺寸一般注法如图a所示。但出于某种需要有时也可注出开口环尺寸，但必须括号，称为参考尺寸，加工时不作测量和检验，如图b中的（N）。</p>
<p><img src="/wp-content/uploads/2015/04/041815_0626_2.png" alt=""></p>
<p>零件间相关尺寸的标注方法</p>
<p><img src="/wp-content/uploads/2015/04/041815_0626_3.png" alt=""></p>
<ol>
<li>符合加工的顺序</li>
</ol>
<p>零件上的同一方向上个表面的加工是有一定的先后顺序的，在标注尺寸的时候应该尽量与加工顺序一致，便于加工与测量。</p>
<ul>
<li>轴套类零件的一般尺寸或阶梯孔等都按加工顺序标注尺寸。根据齿轮轴在车床上的加工顺序，车削加工后还要铣削轴上键槽和加工轮齿。从加工顺序的分析中可以看出，图7对该齿轮轴的尺寸注法是符合加工要求的。图中除了轮齿宽度 这一功能尺寸从设计基准直接注出之外，其余轴向尺寸因结构上没有特殊要求，都按加工顺序标注。</li>
</ul>
<p><img src="/wp-content/uploads/2015/04/041815_0626_4.png" alt=""></p>
<ol>
<li><p>不同工种加工的尺寸应尽量分开标注<br>如图7齿轮轴上的键槽是在铣床上加工的，标注键槽尺寸应与其他的车削加工尺寸分配，有得看图。图中将键槽长度尺寸及其定位尺寸注在主视图上方，车削加工的各段长度尺寸注在下方，键槽的宽度和浓度集中标注在断面图上，这样配置尺寸，清晰易找，加工时看图方便。</p>
</li>
<li><p>标注尺寸应尽量方便测量<br>在没有结构图上或其他重要的要求时，标注尺寸应尽量考虑测量方便。如图8a所示的一些图例是由设计基准注出的中心至某面的尺寸，但不易测量；考虑到对设计要求影响不大，按图8b所示的注法则便于测量。在满足设计要求前提下，所注尺寸应尽量做到使用普通量具就能测量，以减少专用量具的设计和制造。</p>
</li>
<li><p>铸件尺寸按形体分析法标注<br>铸件制造过程是先制作木模及芯盒，再造出砂型并浇注金属液而铸成。木模是由基本形体接合（堆叠）成的，因此对铸件尺寸应按形体分析法标注基本形体的定型尺寸和定位尺寸，</p>
</li>
</ol>
<p><img src="/wp-content/uploads/2015/04/041815_0626_5.jpg" alt=""></p>
<p>图8 标注尺寸要便于测量<br>这样，既反映出设计意图，又方便制作木模。图b是木模形体分析的轴测分解图，按图9a标注尺寸，直接给出了各基本形体的定型尺寸和定位尺寸，是符合制作木模工艺要求的。</p>
<p><img src="/wp-content/uploads/2015/04/041815_0626_6.jpg" alt=""></p>
<p>图9 铸件的尺寸注法</p>
<ol>
<li>加工面与不加工面只能有一个尺寸相联系<br>因为铸件、锻件的不加工面（毛坯面）的尺寸精度只能由铸造、锻造时来保证，如果同一加工面与多个不加工面都有尺寸联系，既以同一加工耐烦基准来同时保证这些不加工面尺寸的保证的，（只有开始加工第一个加工面时，非以毛坯面为基准不可，以后的加工面都必须以另外加工面为基准）。所以零件在同一方向上的加工面与不加工面之间，一般只能有一个尺寸（称过度尺寸）相联系（凸台、凹槽和沉孔等除外），而其他不加工面只能与别名步加工面发生尺寸联系。这样，不仅加工面的尺寸精度要求容易保证，而且不加工面的尺寸精度也能从工艺上保证设计要求。如图10a中，同一加工面（底面）同时与不加工面A、B、C有尺寸10、28、34相联系，故不合理；图10b中该方向加工面（底面）无联系，故合理。’</li>
</ol>
<p><img src="/wp-content/uploads/2015/04/041815_0626_7.jpg" alt=""></p>
<p>图10 毛面与加工面的尺寸注法’</p>
<ol>
<li>标注尺寸应考虑加工方法和特点<br>如图11a所示轴承兽的关圆柱孔，是与轴承卒的半圆柱孔全在一起之后加工出来的，以保证装配后的同轴度。因此，应注直径不注半径，以方便加工和测量。又如图11b所示轴上的键槽，是用盘铣刀加工出来的，除应注出键槽的有关尺寸之外，由<a href="http://www.chinabaike.com/z/a/index_59_1.html" target="_blank" rel="external">刀具</a>保证的尺寸，即铣刀直径也应注出（铣刀用又双点画线画出），以便选用<a href="http://www.chinabaike.com/z/a/index_59_1.html" target="_blank" rel="external">刀具</a>。标注尺寸有时还要考虑检不测方法上的某些需要。</li>
</ol>
<p><img src="/wp-content/uploads/2015/04/041815_0626_8.jpg" alt=""></p>
<p>图11 考虑加工特点注尺寸</p>
<ol>
<li>零件上各处常见孔的尺寸注法<br>图12表示阶梯孔和不通孔（盲孔）的加工方法、画法和尺寸注法（简化前）。由于通常是用钻头加工，而钻头的端部是一个接近120o的锥角，所以当钻阶梯孔或通孔时，在孔的阶台处或孔的末端应画成120o的锥台或锥坑。<br>图13为螺栓连接用的沉孔的加工方法、画法和尺寸注法（简化前）；图14为螺钉连接用的沉孔的画法和尺寸注法（简化前）。</li>
</ol>
<p><img src="/wp-content/uploads/2015/04/041815_0626_9.jpg" alt=""></p>
<p>图12 阶梯孔和不通孔</p>
<p><img src="/wp-content/uploads/2015/04/041815_0626_10.jpg" alt=""></p>
<p>图13 螺栓联接用鱼眼坑</p>
<p><img src="/wp-content/uploads/2015/04/041815_0626_11.jpg" alt=""></p>
<p>图14 螺纹联接用的沉孔尺寸注法<br>各种孔的尺寸注法（简化前后）。<br>国家标准GB/T16675.1—1996中规定，各类孔可采用旁注和符号相结合的方法标注。</p>
<ol>
<li><p>零件标准结构调整素尺寸标注<br>零件标准结构图要素尺寸，应取标准值，并按规定形式标注。</p>
</li>
<li><p>零件尺寸标注的步骤及举例<br>[例1] 参照齿轮泵的轴测装配图（图1）和它的主动齿轮轴零件图（图2），试分析该零件尺寸的标注步骤。<br>如图15，其尺寸标步骤如下：<br>1）分析零件<br>按照题给的几个相关图，分析该主动齿轮轴的结构形状和作用，弄清它与其他他零件之间的联系及其加工方法。<br>2）选择基准<br>如图15a, 图中处设计基准，B和为工艺基准。<br>3）标注功能尺寸<br>如图15b,,将认定的功能尺寸优先注出<br>4）标注其余尺寸<br>如图15c，将其余的非功能尺寸注全。</p>
</li>
</ol>
<p><img src="/wp-content/uploads/2015/04/041815_0626_12.jpg" alt=""></p>
<p>图15 主动齿轮轴的标注步骤<br>[例2] 参照齿轮泵的轴测装配图和泵体表达方案），试分析泵体零件尺寸的标注步骤。<br>如图16，其尺寸标注步骤如下：<br>    1）分析零件<br>泵体是容纳传动零件（主、从动齿轮轴等）的箱体零件，泵体在主动齿轮轴的伸出端有填料盒，用压盖紧；另一端有泵盖等零件。泵体结构由内部空腔（啮合腔）、进出油口、支承及填表料盒、底板等腰三角形组成。并没有按结构在求、设计在求和制造工艺在求合理标注尺寸。<br>2）选择基准<br>如图16所示，长度方向的主在基准是泵体对称平面（基本对称），辅助基准是进、出油口处凸台端面；宽度方向的主在基准是泵体的前端面（与泵盖的结合面，辅助基准是后部填料盒端面；高度方向的主在基准是泵体的前端面（与泵盖的结合面），辅助基准是后部填表料盒端面；高度方向的主在基准是泵体底平面，辅基准是啮合腔两轴孔的轴线。<br>    3）标注功能尺寸<br>泵体的功能尺寸如图中已注出尺寸数值的尺寸，应从设计基准（主在基准）出发直接注出。<br>4）标注其余（非功能）尺寸<br>按工艺要求标注其余尺寸（如图中末注出尺寸数什的尺寸）。其中非加工尺寸按形体分析法标注。注意同一方向的主在基准与辅助基准之间联系尺寸应直接注出。<br>5)检查调整<br>检查调整, 补遗删多, 完成尺寸标注。</p>
<p><img src="/wp-content/uploads/2015/04/041815_0626_13.jpg" alt=""></p>
<p>图16 泵体的尺寸标注</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kidozh.github.io/2015/04/18/python-e8-bd-ac-e8-bd-bdnumpy-e7-9a-84-e5-9f-ba-e6-9c-ac-e7-94-a8-e6-b3-95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kido zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kidozh">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/18/python-e8-bd-ac-e8-bd-bdnumpy-e7-9a-84-e5-9f-ba-e6-9c-ac-e7-94-a8-e6-b3-95/" itemprop="url">[Python][转载]Numpy的基本用法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-18T01:17:27+08:00">
                2015-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址：<a href="http://blog.csdn.net/lsjseu/article/details/20359201?utm_source=tuicool" target="_blank" rel="external">http://blog.csdn.net/lsjseu/article/details/20359201</a></p>
<p>先决条件</p>
<p>在阅读这个教程之前，你多少需要知道点python。如果你想从新回忆下，请看看 <a href="http://docs.python.org/tut/" target="_blank" rel="external"><strong><em>Python Tutorial</em></strong></a> .</p>
<p>如果你想要运行教程中的示例，你至少需要在你的电脑上安装了以下一些软件:</p>
<ul>
<li><a href="http://www.python.org/" target="_blank" rel="external"><strong><em>Python</em></strong></a></li>
<li><p><a href="http://numpy.scipy.org/" target="_blank" rel="external"><strong><em>NumPy</em></strong></a><br>这些是可能对你有帮助的:</p>
</li>
<li><p><a href="http://ipython.scipy.org/" target="_blank" rel="external"><strong><em>ipython</em></strong></a> 是一个净强化的交互Python Shell，对探索NumPy的特性非常方便。</p>
</li>
<li><a href="http://matplotlib.sourceforge.net/" target="_blank" rel="external"><strong><em>matplotlib</em></strong></a> 将允许你绘图</li>
<li><a href="http://scipy.org/" target="_blank" rel="external"><strong><em>Scipy</em></strong></a> 在NumPy的基础上提供了很多科学模块<br>基础篇</li>
</ul>
<p>NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。</p>
<p>例如，在3D空间一个点的坐标 [1, 2, 3] 是一个秩为1的数组，因为它只有一个轴。那个轴长度为3.又例如，在以下例子中，数组的秩为2(它有两个维度).第一个维度长度为2,第二个维度长度为3.</p>
<p>[[ 1., 0., 0.],</p>
<p>[ 0., 1., 2.]]</p>
<p>NumPy的数组类被称作 ndarray 。通常被称作数组。注意numpy.array和标准Python库类array.array并不相同，后者只处理一维数组和提供少量功能。更多重要ndarray对象属性有：</p>
<ul>
<li><p>ndarray.ndim<br>数组轴的个数，在python的世界中，轴的个数被称作秩</p>
</li>
<li><p>ndarray.shape<br>数组的维度。这是一个指示数组在每个维度上大小的整数元组。例如一个n排m列的矩阵，它的shape属性将是(2,3),这个元组的长度显然是秩，即维度或者ndim属性</p>
</li>
<li><p>ndarray.size<br>数组元素的总个数，等于shape属性中元组元素的乘积。</p>
</li>
<li><p>ndarray.dtype<br>一个用来描述数组中元素类型的对象，可以通过创造或指定dtype使用标准Python类型。另外NumPy提供它自己的数据类型。</p>
</li>
<li><p>ndarray.itemsize<br>数组中每个元素的字节大小。例如，一个元素类型为float64的数组itemsiz属性值为8(=64/8),又如，一个元素类型为complex32的数组item属性为4(=32/8).</p>
</li>
<li><p>ndarray.data<br>包含实际数组元素的缓冲区，通常我们不需要使用这个属性，因为我们总是通过索引来使用数组中的元素。</p>
</li>
</ul>
<p>一个例子 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>1</sup></em></strong></a></p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy  import *<br>a = arange(15).reshape(3, 5)<br>a<br>array([[ 0,  1,  2,  3,  4],<br>       [ 5,  6,  7,  8,  9],<br>       [10, 11, 12, 13, 14]])<br>a.shape<br>(3, 5)<br>a.ndim<br>2<br>a.dtype.name<br>‘int32’<br>a.itemsize<br>4<br>a.size<br>15<br>type(a)<br>numpy.ndarray<br>b = array([6, 7, 8])<br>b<br>array([6, 7, 8])<br>type(b)<br>numpy.ndarray<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>创建数组</p>
<p>有好几种创建数组的方法。</p>
<p>例如，你可以使用 array 函数从常规的Python列表和元组创造数组。所创建的数组类型由原序列中的元素类型推导而来。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy  import *<br>a = array( [2,3,4] )<br>a<br>array([2, 3, 4])<br>a.dtype<br>dtype(‘int32’)<br>b = array([1.2, 3.5, 5.1])<br>b.dtype<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>dtype(‘float64’) 一个常见的错误包括用多个数值参数调用<code>array</code>而不是提供一个由数值组成的列表作为一个参数。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = array(1,2,3,4) # WRONG<br>a = array([1,2,3,4]) # RIGHT<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>数组将序列包含序列转化成二维的数组，序列包含序列包含序列转化成三维数组等等。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = array( [ (1.5,2,3), (4,5,6) ] )<br>b<br>array([[ 1.5, 2. , 3. ],<br>[ 4. , 5. , 6. ]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>数组类型可以在创建时显示指定</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = array( [ [1,2], [3,4] ], dtype=<strong>complex</strong> )<br>c</p>
</blockquote>
</blockquote>
</blockquote>
<p>array([[ 1.+0.j, 2.+0.j],<br>[ 3.+0.j, 4.+0.j]])<br>[/code]</p>
<p>通常，数组的元素开始都是未知的，但是它的大小已知。因此，NumPy提供了一些使用占位符创建数组的函数。这最小化了扩展数组的需要和高昂的运算代价。</p>
<p>函数 function 创建一个全是0的数组，函数 ones 创建一个全1的数组，函数 empty 创建一个内容随机并且依赖与内存状态的数组。默认创建的数组类型(dtype)都是float64。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>zeros( (3,4) )<br>array([[0., 0., 0., 0.],<br>[0., 0., 0., 0.],<br>[0., 0., 0., 0.]])<br>ones( (2,3,4), dtype=int16 ) <em># dtype can also be specified</em><br>array([[[ 1, 1, 1, 1],<br>[ 1, 1, 1, 1],<br>[ 1, 1, 1, 1]],<br>[[ 1, 1, 1, 1],<br>[ 1, 1, 1, 1],<br>[ 1, 1, 1, 1]]], dtype=int16)<br>empty( (2,3) )<br>array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260],<br>[ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>为了创建一个数列，NumPy提供一个类似arange的函数返回数组而不是列表:</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>arange( 10, 30, 5 )<br>array([10, 15, 20, 25])<br>arange( 0, 2, 0.3 ) <em># it accepts float arguments</em><br>array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>当 arange 使用浮点数参数时，由于有限的浮点数精度，通常无法预测获得的元素个数。因此，最好使用函数 linspace 去接收我们想要的元素个数来代替用range来指定步长。</p>
<p>其它函数array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, rand, randn, fromfunction, fromfile参考： <a href="http://scipy.org/Numpy_Example_List" target="_blank" rel="external"><strong><em>NumPy示例</em></strong></a></p>
<p>打印数组</p>
<p>当你打印一个数组，NumPy以类似嵌套列表的形式显示它，但是呈以下布局：</p>
<ul>
<li>最后的轴从左到右打印</li>
<li>次后的轴从顶向下打印</li>
<li>剩下的轴从顶向下打印，每个切片通过一个空行与下一个隔开<br>一维数组被打印成行，二维数组成矩阵，三维数组成矩阵列表。</li>
</ul>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(6) <em># 1d array</em><br>print a<br>[0 1 2 3 4 5]<br>b = arange(12).reshape(4,3) <em># 2d array</em><br>print b<br>[[ 0 1 2]<br>[ 3 4 5]<br>[ 6 7 8]<br>[ 9 10 11]]<br>c = arange(24).reshape(2,3,4) <em># 3d array</em><br>print c<br>[[[ 0 1 2 3]<br>[ 4 5 6 7]<br>[ 8 9 10 11]]<br>[[12 13 14 15]<br>[16 17 18 19]<br>[20 21 22 23]]]<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>查看形状操作一节获得有关reshape的更多细节</p>
<p>如果一个数组用来打印太大了，NumPy自动省略中间部分而只打印角落</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print arange(10000)<br>[ 0 1 2 …, 9997 9998 9999]</p>
<p>print arange(10000).reshape(100,100)<br>[[ 0 1 2 …, 97 98 99]<br>[ 100 101 102 …, 197 198 199]<br>[ 200 201 202 …, 297 298 299]<br>…,<br>[9700 9701 9702 …, 9797 9798 9799]<br>[9800 9801 9802 …, 9897 9898 9899]<br>[9900 9901 9902 …, 9997 9998 9999]]<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>禁用NumPy的这种行为并强制打印整个数组，你可以设置printoptions参数来更改打印选项。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>set_printoptions(threshold=’nan’)<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>基本运算</p>
<p>数组的算术运算是按元素的。新的数组被创建并且被结果填充。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = array( [20,30,40,50] )<br>b = arange( 4 )<br>b<br>array([0, 1, 2, 3])<br>c = a-b<br>c<br>array([20, 29, 38, 47])<br>b<em>*2<br>array([0, 1, 4, 9])<br>10</em>sin(a)<br>array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854])<br>a &lt; 35<br>array([True, True, False, False], dtype=bool)<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>不像许多矩阵语言，NumPy中的乘法运算符 * 指示按元素计算，矩阵乘法可以使用dot 函数或创建矩阵对象实现(参见教程中的矩阵章节)</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = array( [[1,1],<br>… [0,1]] )</p>
<p>B = array( [[2,0],<br>… [3,4]] )</p>
<p>A*B        # elementwise product<br>array([[2, 0],<br>[0, 4]])<br>dot(A,B)   # matrix product<br>array([[5, 4],<br>[3, 4]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>有些操作符像 += 和 *= 被用来更改已存在数组而不创建一个新的数组。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = ones((2,3), dtype=int)<br>b = random.random((2,3))<br>a *= 3<br>a<br>array([[3, 3, 3],<br>[3, 3, 3]])<br>b += a<br>b<br>array([[ 3.69092703, 3.8324276 , 3.0114541 ],<br>[ 3.18679111, 3.3039349 , 3.37600289]])<br>a += b # b is converted to integer type<br>a<br>array([[6, 6, 6],<br>[6, 6, 6]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>当运算的是不同类型的数组时，结果数组和更普遍和精确的已知(这种行为叫做upcast)。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = ones(3, dtype=int32)<br>b = linspace(0,pi,3)<br>b.dtype.name<br>‘float64’<br>c = a+b<br>c<br>array([ 1. , 2.57079633, 4.14159265])<br>c.dtype.name<br>‘float64’<br>d = exp(c*1j)<br>d<br>array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,<br>-0.54030231-0.84147098j])<br>d.dtype.name<br>‘complex128’</p>
<p>#许多非数组运算，如计算数组所有元素之和，被作为ndarray类的方法实现<br>a = random.random((2,3))<br>a<br>array([[ 0.6903007 , 0.39168346, 0.16524769],<br>[ 0.48819875, 0.77188505, 0.94792155]])<br>a.sum()<br>3.4552372100521485<br>a.min()<br>0.16524768654743593<br>a.max()<br>0.9479215542670073<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>这些运算默认应用到数组好像它就是一个数字组成的列表，无关数组的形状。然而，指定 axis 参数你可以吧运算应用到数组指定的轴上：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = arange(12).reshape(3,4)<br>b<br>array([[ 0, 1, 2, 3],<br>[ 4, 5, 6, 7],<br>[ 8, 9, 10, 11]])<br>b.sum(axis=0) # sum of each column<br>array([12, 15, 18, 21])<br>b.min(axis=1) # min of each row<br>array([0, 4, 8])<br>b.cumsum(axis=1) <em># cumulative sum along each row</em><br>array([[ 0, 1, 3, 6],<br>[ 4, 9, 15, 22],<br>[ 8, 17, 27, 38]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>通用函数(ufunc)</p>
<p>NumPy提供常见的数学函数如 sin , cos 和 exp 。在NumPy中，这些叫作”通用函数”(ufunc)。在NumPy里这些函数作用按数组的元素运算，产生一个数组作为输出。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>B = arange(3)<br>B<br>array([0, 1, 2])<br>exp(B)<br>array([ 1. , 2.71828183, 7.3890561 ])<br>sqrt(B)<br>array([ 0. , 1. , 1.41421356])<br>C = array([2., -1., 4.])<br>add(B, C)<br>array([ 2., 0., 6.])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>更多函数all, alltrue, any, apply along axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sometrue, sort, std, sum, trace, transpose, var, vdot, vectorize, where 参见: <a href="http://scipy.org/Numpy_Example_List" target="_blank" rel="external"><strong><em>NumPy示例</em></strong></a></p>
<p>索引，切片和迭代</p>
<p>一维 数组可以被索引、切片和迭代，就像 <a href="http://docs.python.org/tutorial/introduction.html" target="_blank" rel="external"><strong><em>列表</em></strong></a> 和其它Python序列。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(10)<strong>3<br>a<br>array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729])<br>a[2]<br>8<br>a[2:5]<br>array([ 8, 27, 64])<br>a[:6:2] = -1000 # equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000<br>a<br>array([-1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729])<br>a[ : :-1] <em># reversed a</em><br>array([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000])<br>for i in a:<br>print i</strong>(1/3.),<br>nan 1.0 nan 3.0 nan 5.0 6.0 7.0 8.0 9.0<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>多维 数组可以每个轴有一个索引。这些索引由一个逗号分割的元组给出。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]<br>def f (x,y):<br>    return 10*x+y</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = fromfunction(f,(5,4),dtype=int)<br>b<br>array([[ 0, 1, 2, 3],<br>[10, 11, 12, 13],<br>[20, 21, 22, 23],<br>[30, 31, 32, 33],<br>[40, 41, 42, 43]])<br>b[2,3]<br>23<br>b[0:5, 1] # each row in the second column of b<br>array([ 1, 11, 21, 31, 41])<br>b[ : ,1] # equivalent to the previous example<br>array([ 1, 11, 21, 31, 41])<br>b[1:3, : ] # each column in the second and third row of b<br>array([[10, 11, 12, 13],<br>[20, 21, 22, 23]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>当少于轴数的索引被提供时，确失的索引被认为是整个切片：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>b[-1] # the last row. Equivalent to b[-1,:]<br>array([40, 41, 42, 43])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>b[i] 中括号中的表达式被当作 i 和一系列 : ，来代表剩下的轴。NumPy也允许你使用”点”像 b[i,…] 。</p>
<p>点 (…)代表许多产生一个完整的索引元组必要的分号。如果x是秩为5的数组(即它有5个轴)，那么:</p>
<ul>
<li>x[1,2,…] 等同于 x[1,2,:,:,:],</li>
<li>x[…,3] 等同于 x[:,:,:,:,3]</li>
<li>x[4,…,5,:] 等同 x[4,:,:,5,:].<br>[code lang=”python” light=”0” toolbar=”1”]<blockquote>
<blockquote>
<blockquote>
<p>c = array( [ [[ 0, 1, 2], # a 3D array (two stacked 2D arrays) …<br>[ 10, 12, 13]], … …<br>[[100,101,102], … [110,112,113]] ] )<br>c.shape (2, 2, 3)<br>c[1,…] # same as c[1,:,:] or c[1] array([[100, 101, 102], [110, 112, 113]])<br>c[…,2] # same as c[:,:,2] array([[ 2, 13], [102, 113]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<p>迭代 多维数组是就第一个轴而言的: <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>2</sup></em></strong></a></p>
<p>[code lang=”python” light=”0” toolbar=”1”]<br>for row in b:<br>    print row</p>
<p>[0 1 2 3]<br>[10 11 12 13]<br>[20 21 22 23]<br>[30 31 32 33]<br>[40 41 42 43]<br>[/code]</p>
<p>然而，如果一个人想对每个数组中元素进行运算，我们可以使用flat属性，该属性是数组元素的一个迭代器:</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>for element in b.flat:<br>        print element,</p>
</blockquote>
</blockquote>
</blockquote>
<p>0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43<br>[/code]</p>
<p>更多[], …, newaxis, ndenumerate, indices, index exp 参考 <a href="http://scipy.org/Numpy_Example_List" target="_blank" rel="external"><strong><em>NumPy示例</em></strong></a></p>
<p>形状操作</p>
<p>更改数组的形状</p>
<p>一个数组的形状由它每个轴上的元素个数给出：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = floor(10*random.random((3,4)))<br>a<br>array([[ 7., 5., 9., 3.],<br>[ 7., 2., 7., 8.],<br>[ 6., 8., 3., 2.]])<br>a.shape<br>(3, 4)<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>一个数组的形状可以被多种命令修改：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a.ravel() # flatten the array<br>array([ 7., 5., 9., 3., 7., 2., 7., 8., 6., 8., 3., 2.])<br>a.shape = (6, 2)<br>a.transpose()<br>array([[ 7., 9., 7., 7., 6., 3.],<br>[ 5., 3., 2., 8., 8., 2.]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>由 ravel() 展平的数组元素的顺序通常是”C风格”的，就是说，最右边的索引变化得最快，所以元素a[0,0]之后是a[0,1]。如果数组被改变形状(reshape)成其它形状，数组仍然是”C风格”的。NumPy通常创建一个以这个顺序保存数据的数组，所以 ravel() 将总是不需要复制它的参数 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>3</sup></em></strong></a><sup> </sup>。但是如果数组是通过切片其它数组或有不同寻常的选项时，它可能需要被复制。函数 reshape() 和 ravel() 还可以被同过一些可选参数构建成FORTRAN风格的数组，即最左边的索引变化最快。</p>
<p>reshape 函数改变参数形状并返回它，而 resize 函数改变数组自身。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a<br>array([[ 7., 5.],<br>[ 9., 3.],<br>[ 7., 2.],<br>[ 7., 8.],<br>[ 6., 8.],<br>[ 3., 2.]])<br>a.resize((2,6))<br>a<br>array([[ 7., 5., 9., 3., 7., 2.],<br>[ 7., 8., 6., 8., 3., 2.]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果在改变形状操作中一个维度被给做-1，其维度将自动被计算</p>
<p>更多 shape, reshape, resize, ravel 参考 <a href="http://scipy.org/Numpy_Example_List" target="_blank" rel="external"><strong><em>NumPy示例</em></strong></a></p>
<p>组合(stack)不同的数组</p>
<p>几种方法可以沿不同轴将数组堆叠在一起：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = floor(10<em>random.random((2,2)))<br>a<br>array([[ 1., 1.],<br>[ 5., 8.]])<br>b = floor(10</em>random.random((2,2)))<br>b<br>array([[ 3., 3.],<br>[ 6., 0.]])<br>vstack((a,b))<br>array([[ 1., 1.],<br>[ 5., 8.],<br>[ 3., 3.],<br>[ 6., 0.]])<br>hstack((a,b))<br>array([[ 1., 1., 3., 3.],<br>[ 5., 8., 6., 0.]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>函数 column_stack 以列将一维数组合成二维数组，它等同与 vstack 对一维数组。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>column_stack((a,b)) # With 2D arrays<br>array([[ 1., 1., 3., 3.],<br>[ 5., 8., 6., 0.]])<br>a=<strong>array</strong>([4.,2.])<br>b=<strong>array</strong>([2.,8.])<br>a[:,newaxis] # This allows to have a 2D columns vector<br>array([[ 4.],<br>[ 2.]])<br>column<em>stack((a[:,newaxis],b[:,newaxis]))<br>array([[ 4., 2.],<br>[ 2., 8.]])<br>vstack((a[:,newaxis],b[:,newaxis])) </em># The behavior of vstack is different_<br>array([[ 4.],<br>[ 2.],<br>[ 2.],<br>[ 8.]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>row_stack 函数，另一方面，将一维数组以行组合成二维数组。</p>
<p>对那些维度比二维更高的数组， hstack 沿着第二个轴组合， vstack 沿着第一个轴组合, concatenate 允许可选参数给出组合时沿着的轴。</p>
<p>Note</p>
<p>在复杂情况下， r<em>[] 和 c</em>[] 对创建沿着一个方向组合的数很有用，它们允许范围符号(“:”):</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>r_[1:4,0,4]<br>array([1, 2, 3, 0, 4])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>当使用数组作为参数时， r<em> 和 c</em> 的默认行为和 vstack 和 hstack 很像，但是允许可选的参数给出组合所沿着的轴的代号。</p>
<p>更多函数hstack , vstack, column_stack , row<em>stack , concatenate , c</em> , r_ 参见 <a href="http://scipy.org/Numpy_Example_List" target="_blank" rel="external"><strong><em>NumPy示例</em></strong></a> .</p>
<p>将一个数组分割(split)成几个小数组</p>
<p>使用 hsplit 你能将数组沿着它的水平轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割:</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = floor(10*random.random((2,12)))<br>a<br>array([[ 8., 8., 3., 9., 0., 4., 3., 0., 0., 6., 4., 4.],<br>[ 0., 3., 2., 9., 6., 0., 4., 5., 7., 5., 1., 4.]])<br>hsplit(a,3) # Split a into 3<br>[array([[ 8., 8., 3., 9.],<br>[ 0., 3., 2., 9.]]), array([[ 0., 4., 3., 0.],<br>[ 6., 0., 4., 5.]]), array([[ 0., 6., 4., 4.],<br>[ 7., 5., 1., 4.]])]<br>hsplit(a,(3,4)) <em># Split a after the third and the fourth column</em><br>[array([[ 8., 8., 3.],<br>[ 0., 3., 2.]]), array([[ 9.],<br>[ 9.]]), array([[ 0., 4., 3., 0., 0., 6., 4., 4.],<br>[ 6., 0., 4., 5., 7., 5., 1., 4.]])]<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>vsplit 沿着纵向的轴分割， array split 允许指定沿哪个轴分割。</p>
<p>复制和视图</p>
<p>当运算和处理数组时，它们的数据有时被拷贝到新的数组有时不是。这通常是新手的困惑之源。这有三种情况:</p>
<p>完全不拷贝</p>
<p>简单的赋值不拷贝数组对象或它们的数据。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(12)<br>b = a # no new object is created<br>b is a # a and b are two names for the same ndarray object<br>True<br>b.shape = 3,4 # changes the shape of a<br>a.shape<br>(3, 4)<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Python 传递不定对象作为参考 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>4</sup></em></strong></a><sup> </sup>，所以函数调用不拷贝数组。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):<br>    print id(x)<br>id(a) # id is a unique identifier of an object<br>148293216<br>f(a)<br>148293216<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>视图(view)和浅复制<br>不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = a.view()<br>c is a<br>False<br>c.base is a # c is a view of the data owned by a<br>True<br>c.flags.owndata<br>False<br>c.shape = 2,6 <em># a’s shape doesn’t change</em><br>a.shape<br>(3, 4)<br>c[0,4] = 1234 <em># a’s data changes</em><br>a<br>array([[ 0, 1, 2, 3],<br>[1234, 5, 6, 7],<br>[ 8, 9, 10, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>切片数组返回它的一个视图：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = a[ : , 1:3] # spaces added for clarity; could also be written “s = a[:,1:3]”<br>s[:] = 10 <em># s[:] is a view of s. Note the difference between s=10 and s[:]=10</em><br>a<br>array([[ 0, 10, 10, 3],<br>[1234, 10, 10, 7],<br>[ 8, 10, 10, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>深复制</p>
<p>这个复制方法完全复制数组和它的数据。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>d = a.copy() <em># a new array object with new data is created</em><br>d is a<br>False<br>d.base <strong>is</strong> a <em># d doesn’t share anything with a</em><br>False<br>d[0,0] = 9999<br>a<br>array([[ 0, 10, 10, 3],<br>[1234, 10, 10, 7],<br>[ 8, 10, 10, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>函数和方法(method)总览</p>
<p>这是个NumPy函数和方法分类排列目录。这些名字链接到 <a href="http://scipy.org/Numpy_Example_List" target="_blank" rel="external"><strong><em>NumPy示例</em></strong></a> ,你可以看到这些函数起作用。[^5]</p>
<p>创建数组</p>
<p>arange, <strong>array</strong>, copy, <strong>empty</strong>, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like</p>
<p>转化</p>
<p>astype, atleast 1d, atleast 2d, atleast 3d, mat</p>
<p>操作</p>
<p>array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</p>
<p>询问</p>
<p>all, any, nonzero, <strong>where</strong></p>
<p>排序</p>
<p>argmax, argmin, argsort, max, min, ptp, searchsorted, <strong>sort</strong></p>
<p>运算</p>
<p>choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum</p>
<p>基本统计</p>
<p>cov, mean, std, <strong>var</strong></p>
<p>基本线性代数</p>
<p>cross, dot, outer, svd, vdot</p>
<p>进阶</p>
<p>广播法则(rule)</p>
<p>广播法则能使通用函数有意义地处理不具有相同形状的输入。</p>
<p>广播第一法则是，如果所有的输入数组维度不都相同，一个”1”将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。</p>
<p>广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。</p>
<p>应用广播法则之后，所有数组的大小必须匹配。更多细节可以从这个 <a href="http://scipy.org/EricsBroadcastingDoc" target="_blank" rel="external"><strong><em>文档</em></strong></a> 找到。</p>
<p>花哨的索引和索引技巧</p>
<p>NumPy比普通Python序列提供更多的索引功能。除了索引整数和切片，正如我们之前看到的，数组可以被整数数组和布尔数组索引。</p>
<p>通过数组索引</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(12)**2 <em># the first 12 square numbers</em><br>i = array( [ 1,1,3,8,5 ] ) <em># an array of indices</em><br>a[i] <em># the elements of a at the positions i</em><br>array([ 1, 1, 9, 64, 25])<br>j = array( [ [ 3, 4], [ 9, 7 ] ] ) <em># a bidimensional array of indices</em><br>a[j] <em># the same shape as j</em><br>array([[ 9, 16],<br>[81, 49]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>当被索引数组a是多维的时，每一个唯一的索引数列指向a的第一维 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>5</sup></em></strong></a><sup> </sup>。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>palette = array( [ [0,0,0], # black<br>… [255,0,0], # red<br>… [0,255,0], # green<br>… [0,0,255], # blue<br>… [255,255,255] ] ) # white<br>image = array( [ [ 0, 1, 2, 0 ], # each value corresponds to a color in the palette<br>… [ 0, 3, 4, 0 ] ] )<br>palette[image] <em># the (2,4,3) color image</em><br>array([[[ 0, 0, 0],<br>[255, 0, 0],<br>[ 0, 255, 0],<br>[ 0, 0, 0]],<br>[[ 0, 0, 0],<br>[ 0, 0, 255],<br>[255, 255, 255],<br>[ 0, 0, 0]]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(12).reshape(3,4)<br>a<br>array([[ 0, 1, 2, 3],<br>[ 4, 5, 6, 7],<br>[ 8, 9, 10, 11]])<br>i = array( [ [0,1], # indices for the first dim of a<br>… [1,2] ] )<br>j = array( [ [2,1], <em># indices for the second dim</em><br>… [3,3] ] )<br>a[i,j] # i and j must have equal shape<br>array([[ 2, 5],<br>[ 7, 11]])<br>a[i,2]<br>array([[ 2, 6],<br>[ 6, 10]])<br>a[:,j] # i.e., a[ : , j]<br>array([[[ 2, 1],<br>[ 3, 3]],<br>[[ 6, 5],<br>[ 7, 7]],<br>[[10, 9],<br>[11, 11]]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>自然，我们可以把i和j放到序列中(比如说列表)然后通过list索引。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>l = [i,j]<br>a[l] <em># equivalent to a[i,j]</em><br>array([[ 2, 5],<br>[ 7, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>然而，我们不能把i和j放在一个数组中，因为这个数组将被解释成索引a的第一维。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = array( [i,j] )</p>
<h2 id="a-s-not-what-we-want"><a href="#a-s-not-what-we-want" class="headerlink" title="a[s] # not what we want"></a>a[s] # not what we want</h2><p>IndexError Traceback (most recent call last)<br>in () 1 a[s]<br>IndexError: index (3) out <strong>of</strong> range (0&lt;=index&lt;2) <strong>in</strong> dimension 0</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>a[tuple(s)] # same <strong>as</strong> a[i,j]<br>array([[ 2, 5],<br>[ 7, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>另一个常用的数组索引用法是搜索时间序列最大值 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>6</sup></em></strong></a><sup> </sup>。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>time = linspace(20, 145, 5) <em># time scale</em><br>data = sin(arange(20)).reshape(5,4) <em># 4 time-dependent series</em><br>time<br>array([ 20. , 51.25, 82.5 , 113.75, 145. ])<br>data<br>array([[ 0. , 0.84147098, 0.90929743, 0.14112001],<br>[-0.7568025 , -0.95892427, -0.2794155 , 0.6569866 ],<br>[ 0.98935825, 0.41211849, -0.54402111, -0.99999021],<br>[-0.53657292, 0.42016704, 0.99060736, 0.65028784],<br>[-0.28790332, -0.96139749, -0.75098725, 0.14987721]])<br>ind = data.argmax(axis=0) <em># index of the maxima for each series</em><br>ind<br>array([2, 0, 3, 1])<br>time<em>max = time[ ind] </em># times corresponding to the maxima_<br>data<em>max = data[ind, xrange(data.shape[1])] </em># =&gt; data[ind[0],0], data[ind[1],1]…_<br>time_max<br>array([ 82.5 , 20. , 113.75, 51.25])<br>data_max<br>array([ 0.98935825, 0.84147098, 0.99060736, 0.6569866 ])<br>all(data_max == data.max(axis=0))<br>True<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>你也可以使用数组索引作为目标来赋值：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(5)<br>a<br>array([0, 1, 2, 3, 4])<br>a[[1,3,4]] = 0<br>a<br>array([0, 0, 2, 0, 0])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>然而，当一个索引列表包含重复时，赋值被多次完成，保留最后的值：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(5)<br>a[[0,0,2]]=[1,2,3]<br>a<br>array([2, 1, 3, 3, 4])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>这足够合理，但是小心如果你想用Python的 += 结构，可能结果并非你所期望：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(5)<br>a[[0,0,2]]+=1<br>a<br>array([1, 1, 3, 3, 4])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求a+=1 和 a=a+1 等同。</p>
<p>通过布尔数组索引</p>
<p>当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。</p>
<p>我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(12).reshape(3,4)<br>b = a &gt; 4<br>b # b is a boolean with a’s shape<br>array([[False, False, False, False],<br>[False, True, True, True],<br>[True, True, True, True]], dtype=bool)<br>a[b] <em># 1d array with the selected elements</em><br>array([ 5, 6, 7, 8, 9, 10, 11])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>这个属性在赋值时非常有用：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a[b] = 0 <em># All elements of ‘a’ higher than 4 become 0</em><br>a<br>array([[0, 1, 2, 3],<br>[4, 0, 0, 0],<br>[0, 0, 0, 0]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>你可以参考 <a href="http://scipy.org/Tentative_NumPy_Tutorial/Mandelbrot_Set_Example" target="_blank" rel="external"><strong><em>曼德博集合示例</em></strong></a> 看看如何使用布尔索引来生成曼德博集合的图像。</p>
<p>第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(12).reshape(3,4)<br>b1 = array([False,True,True]) <em># first dim selection</em><br>b2 = array([True,False,True,False]) <em># second dim selection</em><br>a[b1,:] <em># selecting rows</em></p>
</blockquote>
</blockquote>
</blockquote>
<p>array([[ 4, 5, 6, 7],<br>[ 8, 9, 10, 11]])</p>
<blockquote>
<blockquote>
<blockquote>
<p>a[b1] # same thing<br>array([[ 4, 5, 6, 7],<br>[ 8, 9, 10, 11]])<br>a[:,b2] # selecting columns<br>array([[ 0, 2],<br>[ 4, 6],<br>[ 8, 10]])<br>a[b1,b2] # a weird thing to do<br>array([ 4, 10])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>注意一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，b1是一个秩为1长度为三的数组(a的行数)，b2(长度为4)与a的第二秩(列)相一致。 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>7</sup></em></strong></a></p>
<p>ix_()函数</p>
<p>ix<em> 函数可以为了获得 [**</em>多元组_<em>*](<a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84</a>) 的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算 a+b</em>c ：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = array([2,3,4,5])<br>b = array([8,5,4])<br>c = array([5,4,6,8,3])<br>ax,bx,cx = ix_(a,b,c)<br>ax<br>array([[[2]],<br>[[3]],<br>[[4]],<br>[[5]]])<br>bx<br>array([[[8],<br>[5],<br>[4]]])<br>cx<br>array([[[5, 4, 6, 8, 3]]])<br>ax.shape, bx.shape, cx.shape<br>((4, 1, 1), (1, 3, 1), (1, 1, 5))<br>result = ax+bx<em>cx<br>result<br>array([[[42, 34, 50, 66, 26],<br>[27, 22, 32, 42, 17],<br>[22, 18, 26, 34, 14]],<br>[[43, 35, 51, 67, 27],<br>[28, 23, 33, 43, 18],<br>[23, 19, 27, 35, 15]],<br>[[44, 36, 52, 68, 28],<br>[29, 24, 34, 44, 19],<br>[24, 20, 28, 36, 16]],<br>[[45, 37, 53, 69, 29],<br>[30, 25, 35, 45, 20],<br>[25, 21, 29, 37, 17]]])<br>result[3,2,4]<br>17<br>a[3]+b[2]</em>c[4]<br>17<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>你也可以实行如下简化：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]<br>def ufunc<em>reduce(ufct, *vectors):<br>    vs = ix</em>(*vectors)<br>    r = ufct.identity<br>    for v in vs:<br>        r = ufct(r,v)<br>    return r<br>[/code]</p>
<p>然后这样使用它：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>ufunc_reduce(add,a,b,c)<br>array([[[15, 14, 16, 18, 13],<br>[12, 11, 13, 15, 10],<br>[11, 10, 12, 14, 9]],<br>[[16, 15, 17, 19, 14],<br>[13, 12, 14, 16, 11],<br>[12, 11, 13, 15, 10]],<br>[[17, 16, 18, 20, 15],<br>[14, 13, 15, 17, 12],<br>[13, 12, 14, 16, 11]],<br>[[18, 17, 19, 21, 16],<br>[15, 14, 16, 18, 13],<br>[14, 13, 15, 17, 12]]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>8</sup></em></strong></a></p>
<p>用字符串索引</p>
<p>参见 <a href="http://www.scipy.org/RecordArrays" target="_blank" rel="external"><strong><em>RecordArray</em></strong></a> 。</p>
<p>线性代数</p>
<p>继续前进，基本线性代数包含在这里。</p>
<p>简单数组运算</p>
<p>参考numpy文件夹中的linalg.py获得更多信息</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import <em><br>from numpy.linalg import </em><br>a = array([[1.0, 2.0], [3.0, 4.0]])<br><strong>print</strong> a<br>[[ 1. 2.]<br>[ 3. 4.]]<br>a.transpose()<br>array([[ 1., 3.],<br>[ 2., 4.]])<br>inv(a)<br>array([[-2. , 1. ],<br>[ 1.5, -0.5]])<br>u = eye(2) <em># unit 2x2 matrix; “eye” represents “I”</em><br>u<br>array([[ 1., 0.],<br>[ 0., 1.]])<br>j = array([[0.0, -1.0], [1.0, 0.0]])<br>dot (j, j) # matrix product<br>array([[-1., 0.],<br>[ 0., -1.]])<br>trace(u) <em># trace</em><br>2.0<br>y = array([[5.], [7.]])<br>solve(a, y)<br>array([[-3.],<br>[ 4.]])<br>eig(j)<br>(array([ 0.+1.j, 0.-1.j]),<br>array([[ 0.70710678+0.j, 0.70710678+0.j],<br>[ 0.00000000-0.70710678j, 0.00000000+0.70710678j]]))<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Parameters:</p>
<p>square matrix</p>
<p>Returns</p>
<p>The eigenvalues, each repeated according to its multiplicity.</p>
<p>The normalized (unit “length”) eigenvectors, such that the</p>
<p>column <code>v[:,i]</code> <strong>is</strong> the eigenvector corresponding to the</p>
<p>eigenvalue <code>w[i]</code> .</p>
<p>矩阵类</p>
<p>这是一个关于矩阵类的简短介绍。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = matrix(‘1.0 2.0; 3.0 4.0’)<br>A<br>[[ 1. 2.]<br>[ 3. 4.]]<br>type(A) # file where class is defined<br>A.T # transpose<br>[[ 1. 3.]<br> [ 2. 4.]]<br>X = matrix(‘5.0 7.0’)<br>Y = X.T<br>Y<br>[[5.]<br> [7.]]<br>print A*Y # matrix multiplication<br>[[19.]<br> [43.]]<br>print A.I # inverse<br>[[-2. 1. ]<br> [ 1.5 -0.5]]<br>solve(A, Y) # solving linear equation<br>matrix([[-3.],<br> [ 4.]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>索引：比较矩阵和二维数组</p>
<p>注意NumPy中数组和矩阵有些重要的区别。NumPy提供了两个基本的对象：一个N维数组对象和一个通用函数对象。其它对象都是建构在它们之上 的。特别的，矩阵是继承自NumPy数组对象的二维数组对象。对数组和矩阵，索引都必须包含合适的一个或多个这些组合：整数标量、省略号 (ellipses)、整数列表;布尔值，整数或布尔值构成的元组，和一个一维整数或布尔值数组。矩阵可以被用作矩阵的索引，但是通常需要数组、列表或者 其它形式来完成这个任务。</p>
<p>像平常在Python中一样，索引是从0开始的。传统上我们用矩形的行和列表示一个二维数组或矩阵，其中沿着0轴的方向被穿过的称作行，沿着1轴的方向被穿过的是列。 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>9</sup></em></strong></a></p>
<p>让我们创建数组和矩阵用来切片：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = arange(12)<br>A<br>array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])<br>A.shape = (3,4)<br>M = mat(A.copy())<br>print type(A),” “,type(M)<br>print A<br>[[ 0 1 2 3]<br>[ 4 5 6 7]<br>[ 8 9 10 11]]<br>print M<br>[[ 0 1 2 3]<br>[ 4 5 6 7]<br>[ 8 9 10 11]]<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>现在，让我们简单的切几片。基本的切片使用切片对象或整数。例如， A[:] 和 M[:] 的求值将表现得和Python索引很相似。然而要注意很重要的一点就是NumPy切片数组 不 创建数据的副本;切片提供统一数据的视图。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print A[:]; print A[:].shape<br>[[ 0 1 2 3]<br>[ 4 5 6 7]<br>[ 8 9 10 11]]<br>(3, 4)<br>print M[:]; print M[:].shape<br>[[ 0 1 2 3]<br>[ 4 5 6 7]<br>[ 8 9 10 11]]<br>(3, 4)<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>现在有些和Python索引不同的了：你可以同时使用逗号分割索引来沿着多个轴索引。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print A[:,1]; print A[:,1]<strong>.shape</strong><br>[1 5 9]<br>(3,)<br>print M[:,1]; print M[:,1].shape<br>[[1]<br>[5]<br>[9]]<br>(3, 1)<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>注意最后两个结果的不同。对二维数组使用一个冒号产生一个一维数组，然而矩阵产生了一个二维矩阵。 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>10</sup></em></strong></a><sup> </sup>例如，一个 M[2,:] 切片产生了一个形状为(1,4)的矩阵，相比之下，一个数组的切片总是产生一个最低可能维度 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>11</sup></em></strong></a><sup> </sup>的数组。例如，如果C是一个三维数组， C[…,1] 产生一个二维的数组而 C[1,:,1] 产生一个一维数组。从这时开始，如果相应的矩阵切片结果是相同的话，我们将只展示数组切片的结果。</p>
<p>假如我们想要一个数组的第一列和第三列，一种方法是使用列表切片：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[:,[1,3]]<br>array([[ 1, 3],<br>[ 5, 7],<br>[ 9, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>稍微复杂点的方法是使用 take() 方法(method):</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[:,].take([1,3],axis=1)<br>array([[ 1, 3],<br>[ 5, 7],<br>[ 9, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果我们想跳过第一行，我们可以这样：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[1:,].take([1,3],axis=1)<br>array([[ 5, 7],<br>[ 9, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>或者我们仅仅使用 A[1:,[1,3]] 。还有一种方法是通过矩阵向量积(叉积)。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[ix_((1,2),(1,3))]<br>array([[ 5, 7],<br>[ 9, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>为了读者的方便，在次写下之前的矩阵：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[ix_((1,2),(1,3))]<br>array([[ 5, 7],<br>[ 9, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>现在让我们做些更复杂的。比如说我们想要保留第一行大于1的列。一种方法是创建布尔索引：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[0,:]&gt;1<br>array[False, False, True, True], dtype=bool)<br>A[:,A[0,:]&gt;1]<br>array([[ 2, 3],<br>[ 6, 7],<br>[10, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>就是我们想要的！但是索引矩阵没这么方便。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>M[0,:]&gt;1<br>matrix([[False, False, True, True]], dtype=bool)<br>M[:,M[0,:]&gt;1]<br>matrix([[2, 3]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>这个过程的问题是用”矩阵切片”来切片产生一个矩阵 <a href="http://reverland.org/python/2012/08/22/numpy/" target="_blank" rel="external"><strong><em><sup>12</sup></em></strong></a><sup> </sup>，但是矩阵有个方便的 A 属性，它的值是数组呈现的。所以我们仅仅做以下替代：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>M[:,M.A[0,:]&gt;1]<br>matrix([[ 2, 3],<br>[ 6, 7],<br>[10, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果我们想要在矩阵两个方向有条件地切片，我们必须稍微调整策略，代之以：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[A[:,0]&gt;2,A[0,:]&gt;1]<br>array([ 6, 11])<br>M[M.A[:,0]&gt;2,M.A[0,:]&gt;1]<br>matrix([[ 6, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>我们需要使用向量积 ix_ :</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>A[ix<em>(A[:,0]&gt;2,A[0,:]&gt;1)]<br>array([[ 6, 7],<br>[10, 11]])<br>M[ix</em>(M.A[:,0]&gt;2,M<strong>.A</strong>[0,:]&gt;1)]<br>matrix([[ 6, 7],<br>[10, 11]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>技巧和提示</p>
<p>下面我们给出简短和有用的提示。</p>
<p>“自动”改变形状</p>
<p>更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = arange(30)<br>a.shape = 2,-1,3 <em># -1 means “whatever is needed”</em><br>a.shape<br>(2, 5, 3)<br>a<br>array([[[ 0, 1, 2],<br>[ 3, 4, 5],<br>[ 6, 7, 8],<br>[ 9, 10, 11],<br>[12, 13, 14]],<br>[[15, 16, 17],<br>[18, 19, 20],<br>[21, 22, 23],<br>[24, 25, 26],<br>[27, 28, 29]]])<br>[/code]</p>
</blockquote>
</blockquote>
</blockquote>
<p>向量组合(stacking)</p>
<p>我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果x和y是两个相同长度的向量，你仅仅需要做 m=[x;y] 。在NumPy中这个过程通过函数 column_stack 、 dstack 、 hstack 和 vstack 来完成，取决于你想要在那个维度上组合。例如：</p>
<p>[code lang=”python” light=”0” toolbar=”1”]<br>x = arange(0,10,2) # x=([0,2,4,6,8])<br>y = arange(5) # y=([0,1,2,3,4])<br>m = vstack([x,y]) # m=([[0,2,4,6,8],</p>
<h1 id="0-1-2-3-4"><a href="#0-1-2-3-4" class="headerlink" title="[0,1,2,3,4]])"></a>[0,1,2,3,4]])</h1><p>xy = hstack([x,y]) # xy =([0,2,4,6,8,0,1,2,3,4])<br>[/code]</p>
<p>二维以上这些函数背后的逻辑会很奇怪。</p>
<p>参考 <a href="http://scipy.org/NumPy_for_Matlab_Users" target="_blank" rel="external"><strong><em>写个Matlab用户的NumPy指南</em></strong></a> 并且在这里添加你的新发现: )</p>
<p>直方图(histogram)</p>
<p>NumPy中 histogram 函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意： matplotlib 也有一个用来建立直方图的函数(叫作 hist ,正如matlab中一样)与NumPy中的不同。主要的差别是 pylab.hist 自动绘制直方图，而 numpy.histogram 仅仅产生数据。</p>
<p>[code lang=”python” light=”0” toolbar=”1”]<br>import numpy<br>import pylab   # Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2<br>mu, sigma = 2, 0.5<br>v = numpy.random.normal(mu,sigma,10000)  # Plot a normalized histogram with 50 bins<br>pylab.hist(v, bins=50, normed=1) # matplotlib version (plot)<br>pylab.show()  # Compute the histogram with numpy and then plot it<br>(n, bins) = numpy.histogram(v, bins=50, normed=True) <em># NumPy version (no plot)</em><br>pylab.plot(.5*(bins[1:]+bins[:-1]), n)<br>pylab.show()<br>[/code]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="kido zhang" />
          <p class="site-author-name" itemprop="name">kido zhang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">112</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">78</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kidozh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/331837926Ji" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kidozh" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/kidozh" target="_blank" title="douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      douban
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/kidozh" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 &mdash; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kido zhang</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Pisces
    </a>
  </div>


        







        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
