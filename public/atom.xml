<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kidozh</title>
  <subtitle>某不科学的kidozh</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kidozh.com/"/>
  <updated>2017-04-29T08:16:17.187Z</updated>
  <id>http://kidozh.com/</id>
  
  <author>
    <name>kido zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://kidozh.com/2017/04/29/hello-world/"/>
    <id>http://kidozh.com/2017/04/29/hello-world/</id>
    <published>2017-04-29T08:16:17.187Z</published>
    <updated>2017-04-29T08:16:17.187Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用git部署网站代码到生产环境VPS</title>
    <link href="http://kidozh.com/2017/04/05/e7-94-a8git-e9-83-a8-e7-bd-b2-e7-bd-91-e7-ab-99-e4-bb-a3-e7-a0-81-e5-88-b0-e7-94-9f-e4-ba-a7-e7-8e-af-e5-a2-83vps/"/>
    <id>http://kidozh.com/2017/04/05/e7-94-a8git-e9-83-a8-e7-bd-b2-e7-bd-91-e7-ab-99-e4-bb-a3-e7-a0-81-e5-88-b0-e7-94-9f-e4-ba-a7-e7-8e-af-e5-a2-83vps/</id>
    <published>2017-04-05T11:28:27.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前开发网页的时候，经常要把代码传到自己的VPS上，平常用FTP传整个代码很慢，所以就像到了用Git push到VPS上。</p>
<h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>&nbsp;</p>
<pre class="lang:sh decode:true ">cd /var
mkdir git &amp;&amp; cd git
mkdir your_site.git &amp;&amp; cd your_site.git
git init --bare</pre>

<p><code>--bare</code>的意思是，该文件夹是我们的代码仓库，它将不会放源代码而只是做版本控制。</p>
<h2 id="Hook钩子"><a href="#Hook钩子" class="headerlink" title="Hook钩子"></a>Hook钩子</h2><p>我们将会使用<code>post-receive</code>钩子</p>
<pre class="lang:sh decode:true ">ls</pre>

<p>你可以看到有hooks文件夹已经为我们创建好了,而且里面也有各种钩子的样例</p>
<pre class="lang:sh decode:true ">cd hooks</pre>

<p>创建我们自己的<code>post-receive</code></p>
<pre class="lang:sh decode:true ">vim post-receive</pre>

<p>输入下面的命令到这个文件之中：</p>
<pre class="lang:sh decode:true ">#!/bin/sh
git --work-tree=生产环境网站文件夹位置 --git-dir=/var/git/your_site.git checkout -f</pre>

<p><code>git-dir</code>指的是仓库的地址， <code>work-tree</code>则是存放代码的位置，也就是我们的网站的源代码的位置。 接下来则是要保证它可以运行：</p>
<pre class="lang:sh decode:true ">chmod +x post-receive</pre>

<h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p>一般情况是你已经有了自己的git项目了，那么只需要添加vps的仓库地址就行了</p>
<pre><code>git remote add myVPS-sitename ssh://user@mydomain.com/var/git/your_site.git`&lt;/pre&gt;

&apos;myVPS-sitename&apos;只是这个远程连接的名称，你可以同时有多个远程连接，每次push的时候指定名称即可将代码上传到不同的仓库。

如果你本地还没有项目代码：

&lt;pre&gt;`cd 项目地址
git init`&lt;/pre&gt;

添加一个README.ME文件后

&lt;pre&gt;`git add .
git commit -m &quot;项目初始&quot;`&lt;/pre&gt;

接下来我们便可以将代码push到vps了：

&lt;pre&gt;`git push myVPS-sitename master
</code></pre><p><code>master</code>指定的是master分支，如果你有其他分支也可以push其他分支。.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这只是最基本的设置，利用hook结合一些自己编写的脚本我们还可以做很多事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前开发网页的时候，经常要把代码传到自己的VPS上，平常用FTP传整个代码很慢，所以就像到了用Git push到VPS上。&lt;/p&gt;
&lt;h1 
    
    </summary>
    
      <category term="未分类" scheme="http://kidozh.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="git" scheme="http://kidozh.com/tags/git/"/>
    
      <category term="VPS" scheme="http://kidozh.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>基于K-gram的winnowing特征提取剽窃查重检测技术</title>
    <link href="http://kidozh.com/2017/01/28/e5-9f-ba-e4-ba-8ek-gram-e7-9a-84winnowing-e7-89-b9-e5-be-81-e6-8f-90-e5-8f-96-e5-89-bd-e7-aa-83-e6-9f-a5-e9-87-8d-e6-a3-80-e6-b5-8b-e6-8a-80-e6-9c-af/"/>
    <id>http://kidozh.com/2017/01/28/e5-9f-ba-e4-ba-8ek-gram-e7-9a-84winnowing-e7-89-b9-e5-be-81-e6-8f-90-e5-8f-96-e5-89-bd-e7-aa-83-e6-9f-a5-e9-87-8d-e6-a3-80-e6-b5-8b-e6-8a-80-e6-9c-af/</id>
    <published>2017-01-27T23:10:23.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要来自于<a href="http://zkread.com/article/1130090.html" target="_blank" rel="external">http://zkread.com/article/1130090.html</a>，其参考的论文是MOSS的查重原理：<a href="http://theory.stanford.edu/~aiken/publications/papers/sigmod03.pdf" target="_blank" rel="external">http://theory.stanford.edu/~aiken/publications/papers/sigmod03.pdf</a>。</p>
<h1 id="winnowing算法"><a href="#winnowing算法" class="headerlink" title="winnowing算法"></a>winnowing算法</h1><p>winnowing也就是筛除的意思，也就是说，我们需要从源代码之中直接删除掉无用的信息，提取出特征值来匹配。</p>
<h1 id="k-gram模型"><a href="#k-gram模型" class="headerlink" title="k-gram模型"></a>k-gram模型</h1><p>K-gram/ n-gram 英文翻译过来就叫做n元语法模型 参见维基百科： <a href="https://en.wikipedia.org/wiki/N-gram" target="_blank" rel="external">n-gram English version</a> <a href="https://zh.wikipedia.org/wiki/N%E5%85%83%E8%AF%AD%E6%B3%95" target="_blank" rel="external">n-gram 中文版</a></p>
<p>k-gram 就是将一个连续的文本进行切割，每一个部分的长度都是k。当长度为1，2, 3时 分别对应的名称叫做 一元语法（1-gram unigram）, 二元语法（bigram）,三元语法（trigram）.</p>
<p>为了形象的说明这个问题，我们来举一个简单的例子。有一个简单的文档 叫做A，由字母yabbadabbadoo组成：</p>
<p>这个时候我们在A这个文档上取一个大小为3的滑动窗口，就得到了一个3-gram 的集合：</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/k-grams.png" alt=""></p>
<p>A : yab abb bba dad ada dab abb bba bad ado doo</p>
<p>我们把这个集合中的元素都称为shingle.</p>
<p>下面我们再来看另一个文档C，文档C由下面的这些字符组成的：doobeedoobeedoo：</p>
<p>我们在为3构建一个3-gram 的集合，那么组成的shingle就是下面这个样子的：</p>
<p>C : doo oob obe bee eed edo doo oob obe bee eed edo doo</p>
<p>那么我们要比较A和C之间的相似性，我们很容易看出来我们只要比较他们的Shingle集合中相似的有多少就可以了。 在A和C集合中我们可以发现他们共有的元素是doo,但是他在A集合中出现了一次，在C集合中出现了三次。</p>
<p>那么这里就有两种可能，一种就是这是偶然的，还有一种假设就是万一真的存在剽窃呢，那就是说明doo 从A中被复制到C中三次。</p>
<p>但是其实这种情况，完全是取决与我们的K</p>
<p>看下面我们对A和C进行重新的划分，我们去k=4</p>
<p>A : yabb abba bbad bada adab dabb abba bbad dado adoo C : doob oobe obee beed eedo edoo doob oobe obee beed eedo edoo</p>
<p>可以看出现在这样子划分，这两个字符串是完全没有相似性可言的。</p>
<p><strong>注意：</strong> 通过我们前面的观察，或者计算，对于一个含有N个字符的文档，我们按照k来划分得到的shingle 的个数是： N-K+1</p>
<h2 id="K的选取"><a href="#K的选取" class="headerlink" title="K的选取"></a>K的选取</h2><p>根据上面的分析我们知道，在这里最重要的就是选取K值。那么我们要怎么分割呢，一般我们文档的常见单词（不重要的出现频率大）的长度必须要<strong><em>小于</em></strong> K.</p>
<p>注意注意重点来了！！！</p>
<p>我们选取的K必须大于文档中常见的不重要的单词，比如说在一个文档里，中文文档，最常见的单词应该是“的”，这个次几乎是每个文档都会出现的，但是这个次可能对于文档的相似性判断没有任何重要性而言。</p>
<p>又比如说我们英文当中的the 和我们程序当中的if 都是我们不太关心的，所以K的取值一般要比这些单词要大。这样就很好的剔除了文档中自然产生的相似性。</p>
<p>我们使用论文中的原话来讲，我们要查找一些我们感兴趣的信息，重要的shingle的长度必须要大于K，这些使我们感兴趣的，比K小的就是我们不敢兴趣的。你看，这是不是就是一个简单的过滤过程，首先通过K我们可以过滤掉一些信息。</p>
<p>k-gram 最有意思的特征就是，在某种程序上他对于排序是不敏感的。注意关键词， <strong>某种程度</strong>上是不敏感的. 这样可以防止有的人重新排列了我们的文档，这种情况在代码中最为常见，比如说一个代码中有两个类，我们先后调换一下位置，这两份文档还是不能躲过我们k-gram hash 算法的火眼金睛。</p>
<p>比如说我们将 yabbadabbadoo 重新排列成 bbadooyabbada 混淆之后我们得到文档的shingle集合是： A： bba bad ado doo ooy oya yab abb bba bad ada</p>
<p>通过观察我们可以发现，3连字任然完整无缺的出现在其中，那么我们把这个文档和我们的C文档比较一下，他们的相似度是不变的。</p>
<h1 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h1><p>但是假设把这些信息都纳入计算，那么计算的开销无疑是巨大的。所以我们选择hash来直接提取特征值。</p>
<p>Hash 算法就是把任意长度的输入，通过散列算法，变换成固定长度的输出。该输出就是散列值。这种转换是一种压缩映射，散列值的空间一般远小于输入的空间。 但是如果不同的数据通过hash 算法得到了相同的输出，这个就叫做碰撞，因此不可能从散列值来唯一确定输入值。</p>
<p>一般的hash 算法我们都要求满足几个条件：</p>
<ul>
<li><p>单向性（one-way）, 从预映射，能够简单迅速的得到散列值，而在计算上不可能构造一个预映射，使其散列结果等于某个特定的散列值，即构造相应的M=H-1(h)不可行。这样，散列值就能在统计上唯一的表征输入值，因此，密码学上的 Hash 又被称为”消息摘要(messagedigest)”，就是要求能方便的将”消息”进行”摘要”，但在”摘要”中无法得到比”摘要”本身更多的关于”消息”的信息。</p>
</li>
<li><p>第二是抗冲突性(collision-resistant)，即在统计上无法产生2个散列值相同的预映射。给定M，计算上 无法找到M’，满足H(M)=H(M’) ，此谓弱抗冲突性；计算上也难以寻找一对任意的M和M’，使满足H(M)=H(M’) ，此谓强抗冲突性。要求”强抗冲突性”主要是为了防范 所谓”生日攻击(birthdayattack)”，在一个10人的团 体中，你能找到和你生日相同的人的概率是2.4%，而在同一团体中，有2人生日相同的概率是11.7%。类似的， 当预映射的空间很大的情况下，算法必须有足够的强度来保证不能轻易找到”相同生日”的人。</p>
</li>
<li><p>第三是映射分布均匀性和差分分布均匀性，散列结果中，为 0 的 bit 和为 1 的 bit ，其总数应该大致 相等；输入中一个 bit的变化，散列结果中将有一半以上的 bit 改变，这又叫做”雪崩效应(avalanche effect)”； 要实现使散列结果中出现 1bit的变化，则输入中至少有一半以上的 bit 必须发生变化。其实质是必须使输入 中每一个 bit 的信息， 尽量均匀的反映到输出的每一个 bit上去；输出中的每一个 bit，都是输入中尽可能 多 bit 的信息一起作用的结果。</p>
</li>
</ul>
<p>hash 算法最常用的就是加减乘除和移位运算。我们先来看几个常用常见的哈希函数吧。</p>
<p>观察上面的这些hash算法我们可以发现，输入都是一些字符串，我们需要对字符串进行操作，并且是对字符串的<strong>每一个位置上</strong>的字符串进行操作，移位加减乘除，等运算然后得到我们的散列置。在这里我们采用的hash 算法是下面这个：</p>
<p>[ c<em>{1}*b^{k-1}+c</em>{2}<em>b^{k-2}+….+c_{k-1}</em>b+c_{k} ]</p>
<p>其中H表示的是映射关系，这里操作的对象是我们的每一个shingle，所以C1…CK表示的是一个有K位的元model ，将每一个C按照我们的公式进行计算得到一个hash 值，这里的b 表示的是一个基底（Base） 这里是用户自己设定的某个值，我们一般选取一个质数来做我们的基底，按照上面的公式我们计算得到我们每个 Shingle的hash 值。</p>
<p>有了我们的hash算法，我们就可以计算每一个shingle的hash值。 我们的文档有N，按照k 来划分，得到的shingle 总共是N-K+1个。所以我们要计算N-K+1个长度为K的shingle的hash.</p>
<p>其实计算量还是很大的，不要着急，我们后面会讲怎么改进的，现在先卖个关子。</p>
<h1 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h1><p>什么是特征？ 应该是能很快区分出你是谁的点，我们把这些你独一无二的东西叫做我们的“特”征。特征一定是能快速标记你是谁的东西。 在软件文本的检测中这个道理同样适用。</p>
<p>一个软件，它总有一些比较有价值的代码，和一些大众代码，我们谁都可以实现的。你有我有大家有的东西，显然不可能做特征。</p>
<p>我们在破案的时候，常常采用指纹，DNA，掌纹，牙齿的结构，等等来确定这个人是谁。我们没有必要比较所有的特征，因为那是没有任何效率的。比个DNA就能搞定的事情，你非要把身上的每一块肥肉都拿来判别一下，这个行为就是来搞笑的。</p>
<p>所以我们没有必要去比较一个文档的所有的shingle的hash值，我们只需要比较一些特定的hash 值，就可以了。这个时候就涉及到特征的提取和选择，到底那些特征是该保留的，那些特征是该舍弃的？</p>
<p>现在我们有一整个文档的hash 值，那有的人就说了，那我们每隔几个选一个hash 值带代替整个文档，让这些哈希值作为我们整个文档的“胎记”birthmark 或者是”指纹”fingerprint 也就是我们的特征。</p>
<p>OK，这个想法却是减小了我们的特征值，但是有效么？</p>
<p>我们思考一下.</p>
<p>随机每隔相通的距离选取一个hash值，这样的做法有什么弊端么？有可能这些哈希值全部都是不重要的信息的hash, 你用这些值根本找不到剽窃样本。</p>
<p>所以某种程度上效果不好。</p>
<p>之后又有人 提出了我们使用 θmodp = 0 的方法来选择我们的hash 值。这样又使得我们的选择更加的随机。</p>
<p>假设我们有一组hash 值，是这个样子的：</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 77 72 42 17 98 50 17 98 8 88 67 39 77 72 42 17 98</p>
<p>那我们选取 mod 4 =0 的哈希那我们就得到了 四个hash值做我们文档的特征值</p>
<p>我们得到的特征值就是： （1:72）， （ 8:8）， （9:88） ， （13：72）</p>
<p>这个算法比上面的选取固定值又提升了一部，使得选取更加的随机化。但是，有问题么？？</p>
<p>假设我们的散列值是下面这个排序：</p>
<p>72 8 88 72 77 42 17 98 50 17 98 67 39 77 42 17 98</p>
<p>那我们去p=4 ,我们取出来的hash值全部都来自头部的hash, 假设这个文章是有很多段组成的，我们这样选取，很可能使得我们的特征分布不均匀。这样我们很可能只提取到了某些段落的特征值，而完全的忽略了某些段落。</p>
<p>要是我们忽略的段落正好是我们抄袭的段落，那么我们很可能就完全检测不到了。所以，你可以看到这个方法的缺点了吧。有时候取余选取的特征值存在分配不均匀的情况。为了改善这个情况，我们就要推出我们今天的主角 winnowing.</p>
<h1 id="Winnowing方法"><a href="#Winnowing方法" class="headerlink" title="Winnowing方法"></a>Winnowing方法</h1><p>为了使得我们的选取的特征值分布相对来说比较合理一点，这里我们使用了winnowing 的方法。在上面的一个小节中我们已经对这个方法做了一个简单的介绍。</p>
<p>这个方法的基本思想就是，我们首先设置一个大小为W的滑动窗口。将每个窗口中最小的那个hash保留下来（如果窗口中最小的hash 有两个或者多个，就保留最右边的那一个），这样就保证了我们保留下来的文档原文的间隔不会超过 W+K-1.注意，选过的特征是不能在挑选的，我们需要记录下下标。因为hash值是可能重复的。</p>
<p>为什么我们能保证间隔就是 W+K-1？why? 你想过这个问题了没有？</p>
<p>好的我们现在再来解答一下这个问题： 我们的特征值如下：</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_sample-512x43.png" alt=""></p>
<p>我们假设我们选取的窗口的大小为4：</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_windows.png" alt=""></p>
<p>在第一个窗口中我们的最小值是A3:8，以此类推</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_windows_step_1-512x70.png" alt=""></p>
<p>在第二个窗口中我们的最小值依然是A3:8</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_windows_step_2-512x60.png" alt=""></p>
<p>在第三个窗口中我们的最小值依然是A3:8</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_windows_step_3-512x64.png" alt=""></p>
<p>在第四个窗口中我们的最小值依然是A3:8</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_windows_step_4-512x67.png" alt=""></p>
<p>直到第五个窗口的时候我们才能加入新的特征值</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_windows_step_5-512x60.png" alt=""></p>
<p>我们可以看到最差的情况就是上面我们说的这情况，其实就是W-1</p>
<p>按照这种方法我们可以选举出我们的所有特征值。</p>
<p>假设我们的hash值的集合是下面这个样子</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/hash_set.png" alt=""></p>
<p>我们设置窗口的大小为4：</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Winnowing_windows_matrix.png" alt=""></p>
<p>我们得到最终的特征值就是下面这个样子：</p>
<p><img src="http://kidozh.com/wp-content/uploads/2017/01/Fingerprint.png" alt=""></p>
<p>前面的是特征值，后面的是特征值对应的下标。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章主要来自于&lt;a href=&quot;http://zkread.com/article/1130090.html&quot; target=&quot;_bla
    
    </summary>
    
      <category term="算法" scheme="http://kidozh.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://kidozh.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="查重" scheme="http://kidozh.com/tags/%E6%9F%A5%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>解决Python安装包时候的error: Unable to find vcvarsall.bat问题</title>
    <link href="http://kidozh.com/2017/01/23/e8-a7-a3-e5-86-b3python-e5-ae-89-e8-a3-85-e5-8c-85-e6-97-b6-e5-80-99-e7-9a-84error-unable-to-find-vcvarsall-bat-e9-97-ae-e9-a2-98/"/>
    <id>http://kidozh.com/2017/01/23/e8-a7-a3-e5-86-b3python-e5-ae-89-e8-a3-85-e5-8c-85-e6-97-b6-e5-80-99-e7-9a-84error-unable-to-find-vcvarsall-bat-e9-97-ae-e9-a2-98/</id>
    <published>2017-01-22T23:13:38.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在Windows开发Python，需要装一个名为<code>hcluster</code>的包，然后就开始报<a href="http://stackoverflow.com/questions/2817869/error-unable-to-find-vcvarsall-bat" target="_blank" rel="external">error: Unable to find vcvarsall.bat</a>的错误。stackoverflow上面已经讲的很清楚了，所以这就只是一个翻译贴了。</p>
<h1 id="安装Microsoft-Visual-C-Compiler-for-Python-2-7"><a href="#安装Microsoft-Visual-C-Compiler-for-Python-2-7" class="headerlink" title="安装Microsoft Visual C++ Compiler for Python 2.7"></a>安装Microsoft Visual C++ Compiler for Python 2.7</h1><p>地址在这里：<a href="http://www.microsoft.com/en-us/download/details.aspx?id=44266" target="_blank" rel="external">http://www.microsoft.com/en-us/download/details.aspx?id=44266</a></p>
<p>这样你就直接运行就可以了。需要注意的事情，你必须合理的设置环境变量的值以确保其能正常使用。</p>
<p>按照这样来说也应该没问题了，但是很不幸的，也可能出差错。</p>
<p>注意，在正常情况下，你需要避免下项发生。</p>
<h1 id="配置Visual-Studio的环境变量"><a href="#配置Visual-Studio的环境变量" class="headerlink" title="配置Visual Studio的环境变量"></a>配置Visual Studio的环境变量</h1><p>在使用setup.py安装程序包时，Python 2.7就会搜索已安装的Visual Studio。所以假设你已经安装了VS，那么在上述情况不成功的时候，你还需要在运行python setup.py install的之前，需要设定临时的环境变量。</p>
<p>设置的环境变量应该与你的VS版本有关。</p>
<ul>
<li>Visual Studio 2010 (VS10): <code>SET VS90COMNTOOLS=%VS100COMNTOOLS%</code></li>
<li>Visual Studio 2012 (VS11): <code>SET VS90COMNTOOLS=%VS110COMNTOOLS%</code></li>
<li>Visual Studio 2013 (VS12): <code>SET VS90COMNTOOLS=%VS120COMNTOOLS%</code></li>
<li>Visual Studio 2015 (VS14): <code>SET VS90COMNTOOLS=%VS140COMNTOOLS%</code></li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>更多的答案，你可以直接查阅<a href="http://stackoverflow.com/questions/2817869/error-unable-to-find-vcvarsall-bat" target="_blank" rel="external">StackOverFlow</a>关于这个问题的答案。</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在Windows开发Python，需要装一个名为&lt;code&gt;hcluster&lt;/code&gt;的包，然后就开始报&lt;a href=&quot;http:/
    
    </summary>
    
      <category term="Python" scheme="http://kidozh.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidozh.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使你的主题更加安全</title>
    <link href="http://kidozh.com/2016/12/30/e4-bd-bf-e4-bd-a0-e7-9a-84-e4-b8-bb-e9-a2-98-e6-9b-b4-e5-8a-a0-e5-ae-89-e5-85-a8/"/>
    <id>http://kidozh.com/2016/12/30/e4-bd-bf-e4-bd-a0-e7-9a-84-e4-b8-bb-e9-a2-98-e6-9b-b4-e5-8a-a0-e5-ae-89-e5-85-a8/</id>
    <published>2016-12-29T21:40:24.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们正准备要开始创建我们主题的模板文件了。在我们做这之前，快速了解数据验证对于WordPress的重要性是非常必要的。</p>
<h1 id="为什么主题的安全性很重要？"><a href="#为什么主题的安全性很重要？" class="headerlink" title="为什么主题的安全性很重要？"></a>为什么主题的安全性很重要？</h1><p>下面来自WordPress Codex的话很好的回答了这个问题：</p>
<blockquote>
<p>Untrusted data comes from many sources (users, third party sites, your own database!, …) and all of it needs to be validated both on input and output.</p>
<p>“来自许多不可信的来源（例如用户、第三方站点甚至是你自己的数据库）的输入和输出都应该被验证”<br>我们这里需要假设所有在你WordPress数据库中输入和输出的数据都是不安全的，并且需要根据适用的环境来对数据和内容进行认证。例如，我们不希望在设置页面上的文本框中输入的HTML代码，作为主题文件中的作为HTML运行，因为这可能会破坏我们的布局。 更糟糕的是，如果动态内容的代码是JavaScript或SQL查询，那么您的站点可能会面临<a href="http://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">跨站点脚本攻击</a>（XSS）攻击或<a href="http://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="external">SQL注入</a>的风险。</p>
</blockquote>
<p>WordPress提供了一系列的函数，这些函数能让我们使得我们的数据变得安全，这些函数能帮助你：</p>
<ol>
<li>转义一些诸如单双引号、&amp;、大小于符号特殊字符到他们等价的符号(&amp;quot;, &amp;lt;, &amp;gt;, etc)，所以他们不可能作为代码运行。这也被成为输出验证以及转义</li>
<li>确保你输入到数据库之中的内容和你所想的一致（举个例子，检查文字框包含了不含有HTML标签的安全文字）这也被称为输入验证。<br>在这个指南之中，我们将会关注第一个，转义数据。</li>
</ol>
<p>第二项也是对于主题搜集来自用户的数据来说非常重要，比如主题选项页面，主题设置。当然这一部分已经超出了这本章的所述范围了。</p>
<h1 id="输出转义以及无害化"><a href="#输出转义以及无害化" class="headerlink" title="输出转义以及无害化"></a>输出转义以及无害化</h1><p>我们的首要无害化代码的武器就是<a href="http://codex.wordpress.org/Function_Reference/esc_attr" target="_blank" rel="external">esc_attr()</a>和<a href="http://codex.wordpress.org/Function_Reference/esc_attr_e" target="_blank" rel="external">esc_attr_e()</a> 这两个函数，我们将会在此后使用多次，到时候用的时候我会告诉你们他们究竟是什么。</p>
<p>当我们输出HTML内置的属性的时候，这两个函数都会转义我们上面说的字符（这些字符可能会被错误的解析为代码）。<a href="http://codex.wordpress.org/Function_Reference/esc_attr" target="_blank" rel="external">esc_attr()</a>是用于在PHP内部转义代码而<a href="http://codex.wordpress.org/Function_Reference/esc_attr_e" target="_blank" rel="external">esc_attr_e()</a>则会在屏幕上显示我们正在转义的代码。</p>
<p>这里就有一个活生生的例子，这个代码我们将会在之后索引页的教程之中使用到这些函数。</p>
<p><pre class="lang:php decode:true ">&lt;h1 class=”entry-title”&gt;&lt;a href=”&lt;?php the_permalink(); ?&gt;” title=”&lt;?php echo esc_attr( sprintf( <strong>( ‘Permalink to %s’, ‘shape’ ), the_title_attribute( ‘echo=0’ ) ) ); ?&gt;” rel=”bookmark”&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;&lt;/h1&gt;</strong></pre><br>这个代码就会显示博文的标题。即使你不知道现在做的是什么，注意一下，我们在<code>&amp;lt;a&amp;gt;</code>标签之中，包括了title的标签以及title里面的值esc_attr()。所有包含在HTML属性标签都被认为是不安全的。所以`&lt;?php echo esc_attr( sprintf( ( ‘Permalink to %s’, ‘book’ ), the_title_attribute( ‘echo=0’ ) ) ); ?&gt;`也能包含所有的事情，当然也包含了隐含不安全字符的的内容。</p>
<p>深入这个教程，我们将会看到更多的例子。当然，如果你还想深入了解数据无害化以及验证的话，你也可以查阅Stephen Harris的<a href="http://wp.tutsplus.com/tutorials/creative-coding/data-sanitization-and-validation-with-wordpress/" target="_blank" rel="external">Data Validation and Sanitization With WordPress</a> 。</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们正准备要开始创建我们主题的模板文件了。在我们做这之前，快速了解数据验证对于WordPress的重要性是非常必要的。&lt;/p&gt;
&lt;h1 id
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="wordpress" scheme="http://kidozh.com/tags/wordpress/"/>
    
      <category term="网页安全" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>构建WordPress主题函数</title>
    <link href="http://kidozh.com/2016/12/20/e6-9e-84-e5-bb-bawordpress-e4-b8-bb-e9-a2-98-e5-87-bd-e6-95-b0/"/>
    <id>http://kidozh.com/2016/12/20/e6-9e-84-e5-bb-bawordpress-e4-b8-bb-e9-a2-98-e5-87-bd-e6-95-b0/</id>
    <published>2016-12-19T22:04:11.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们已经创建了一个文件结构，那么现在就让我们开始一个主题把。</p>
<p>我们需要添加一些主题函数到我们的主题之中，这些函数将会完成下面的任务：</p>
<ul>
<li>为WordPress主题特征添加一些支持，比如自定义的背景，页首，博文格式等</li>
<li>设置主题的默认值</li>
<li>对于主题的代码复用</li>
</ul>
<h1 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h1><p>首先，让我们创建以及编辑这些文件</p>
<ul>
<li>functions.php</li>
<li>inc/template-tags.php</li>
<li>inc/tweaks.php<br>如果你是PHP新人的话，那么PHP的函数的保留字为<code>function</code>，比如这样：<br><pre class="lang:php decode:true ">function my_function() {<br>…contents of the function<br>}</pre><br>当我们创建这个函数之后，我们就可以在主题之中调用这个函数了。函数能够被调用：<br><pre class="lang:php decode:true ">&lt;div&gt;<br>&lt;?php my_function(); ?&gt;<br>&lt;/div&gt;</pre><br>其他的函数调用方法就可能有些复杂了：<br><pre class="lang:php decode:true ">&lt;div&gt;<br>&lt;?php my_second_function( ‘parameter 1’, ‘parameter 2’ ); ?&gt;<br>&lt;/div&gt;</pre><br>在上面的例子之中，我们都会向函数之中传递参数，这个函数将会使用其并将其作为最终的输出结果。</li>
</ul>
<h1 id="Functions-php"><a href="#Functions-php" class="headerlink" title="Functions.php"></a>Functions.php</h1><p>事不宜迟，我们就开始把。</p>
<p>在上节课创建的主题目录之中，打开functions.php文件，在文件最上面，粘贴下面的值：</p>
<p><pre class="lang:php decode:true ">&lt;?php<br>/**</pre></p>
<ul>
<li>Shape functions and definitions<br>*</li>
<li>@package Shape</li>
<li>@since Shape 1.0<br>*/<br>如果你是PHP新手的话，我们就从<code>&amp;lt;?php</code>开始编辑文件吧。</li>
</ul>
<p>接下来，我们就有描述内联信息的块注释：一个文件的简短的介绍，接着就是PHP文档的标签：@package和@since。你能够在WordPress Codex的<a href="http://codex.wordpress.org/Inline_Documentation" target="_blank" rel="external">内联文档</a>之中找到更多的信息。</p>
<p>php的注释和C语言的注释是很像的。<code>/* ... */</code>就是多行注释，而<code>//</code> 则是单行注释。</p>
<h2 id="content-width"><a href="#content-width" class="headerlink" title="$content_width"></a>$content_width</h2><p><code>$content_width</code> 是一个设置内容（比如图片）最大宽度的全局变量。其能够防止超大图片溢出主要的内容区域。我们应该设置这个值来限制我们主要内容区域的宽度。想想我们之前的HTML结构，这个区域其实就是<code>#content div</code>。我们将会使用CSS来设置div的宽度。然而，我们还没有CSS文件。所以在这里，我会告诉你div将会是654px宽。</p>
<p>在<code>functions.php</code>之中，无视最后的一个<code>*/</code>，粘贴下面的代码：</p>
<p><pre class="lang:php decode:true ">/**</pre></p>
<ul>
<li>Set the content width based on the theme’s design and stylesheet.<br>*</li>
<li>@since Shape 1.0<br><em>/<br>if ( ! isset( $content_width ) )<br> $content_width = 654; /</em> pixels */<br>所以<code>$content_width</code>就被设置好了，PHP变量有一个美元符<code>$</code>置于名称之前，在分配值之后，会有一个半角的<code>;</code>。</li>
</ul>
<h2 id="shape-setup"><a href="#shape-setup" class="headerlink" title="shape_setup()"></a>shape_setup()</h2><p>接下来，我们将会创建一个函数来新建一个默认主题并且添加一个对于众多WordPress特性支持的函数，跳过在$content_width之后的那一行，添加这个：</p>
<p><pre class="lang:php decode:true ">if ( ! function_exists( ‘shape_setup’ ) ):<br>/**</pre></p>
<ul>
<li>Sets up theme defaults and registers support for various WordPress features.<br>*</li>
<li>Note that this function is hooked into the after_setup_theme hook, which runs</li>
<li>before the init hook. The init hook is too late for some features, such as indicating</li>
<li>support post thumbnails.<br>*</li>
<li><p>@since Shape 1.0<br>*/<br>function shape_setup() {</p>
<p> /**</p>
<ul>
<li><p>Custom template tags for this theme.<br>*/<br>require( get_template_directory() . ‘/inc/template-tags.php’ );</p>
<p>/**</p>
</li>
<li><p>Custom functions that act independently of the theme templates<br>*/<br>require( get_template_directory() . ‘/inc/tweaks.php’ );</p>
<p>/**</p>
</li>
<li>Make theme available for translation</li>
<li>Translations can be filed in the /languages/ directory</li>
<li>If you’re building a theme based on Shape, use a find and replace</li>
<li><p>to change ‘shape’ to the name of your theme in all the template files<br>*/<br>load_theme_textdomain( ‘shape’, get_template_directory() . ‘/languages’ );</p>
<p>/**</p>
</li>
<li><p>Add default posts and comments RSS feed links to head<br>*/<br>add_theme_support( ‘automatic-feed-links’ );</p>
<p>/**</p>
</li>
<li><p>Enable support for the Aside Post Format<br>*/<br>add_theme_support( ‘post-formats’, array( ‘aside’ ) );</p>
<p>/**</p>
</li>
<li>This theme uses wp_nav_menu() in one location.<br>*/<br>register_nav_menus( array(<br> ‘primary’ =&gt; __( ‘Primary Menu’, ‘shape’ ),<br>) );<br>}<br>endif; // shape_setup<br>add_action( ‘after_setup_theme’, ‘shape_setup’ );<br>代码都是很好注释过的，所以你能很好的了解他们正在做什么。</li>
</ul>
</li>
</ul>
<p>那么我们就一一说明把：</p>
<p>我们将会引用在inc/文件夹下的两个文件template-tags.php和tweak.php。我们将会在稍后创建这两个文件。</p>
<p>接下来，我们调用了<code>load_theme_textdomain()</code>这个函数，这个函数会告诉我们WordPress将会使用我们文件夹下的languages这个来作为翻译的标准。如果你正要创建一个WordPress主题，你一个穷尽你的可能来保证所有字符串都是可翻译的。你永远不知道在啥时候其他人是否需要在其他语言中硬编码。下面有些好的方法来翻译文章，我也会说一些出来，<a href="http://codex.wordpress.org/I18n_for_WordPress_Developers" target="_blank" rel="external">I18n for WordPress Developers</a>将会是一个非常好的入门。</p>
<p>接着，下面的两个函数为RSS反馈以及侧边博文格式提供了支持链接。最后一个函数注册了一个导航菜单位置，我们将会在我们的主要菜单中用到。</p>
<p>接下来，我们会用<code>}</code>来闭合这个函数，并且使用钩子（hook）的方法将其加到我们的主题函数之中。</p>
<p><pre class="lang:php decode:true ">add_action( ‘after_setup_theme’, ‘shape_setup’ );</pre><br>简而言之，我们将会告诉WordPress在运行<code>after_setup_theme()</code>之后运行<code>shape_setup()</code>函数。</p>
<p>我们将会在functions.php之中加入更多东西。</p>
<p>你可能注意到functions.php文件没有任何PHP的闭合符号?&gt;，这是因为这个文件绝大多数都是PHP代码，所以吞掉闭合符号也是非常安全的。至于我们为什么要这么做的原因，自然是因为其能帮助我们免于闭合PHP代码之后引入的空白符。</p>
<h2 id="Template-tags-php和Tweak-php"><a href="#Template-tags-php和Tweak-php" class="headerlink" title="Template-tags.php和Tweak.php"></a>Template-tags.php和Tweak.php</h2><p>还记得下面的代码吗？</p>
<p><pre class="lang:php decode:true ">/**</pre></p>
<pre><code> * Custom template tags for this theme.
 */
require( get_template_directory() . &apos;/inc/template-tags.php&apos; );

/**
 * Custom functions that act independently of the theme templates
 */
require( get_template_directory() . &apos;/inc/tweaks.php&apos; );&lt;/pre&gt;
</code></pre><p>在inc文件夹中创建template-tags.php和tweak.php文件。为什么我们要把自定义的函数分散在众多的文件之中呢？大多数情况下，我们像保持functions.php代码中的干净整洁，但更多的是保证我们主题的模块化，如果你并不需要这些函数的话，你只需要移除这一行就可以了。</p>
<h3 id="template-tags-php"><a href="#template-tags-php" class="headerlink" title="template-tags.php"></a>template-tags.php</h3><p>首先，什么是模板标签？自然是一个函数了。特殊而言，他们是你可以插入到你主题之中来显示动态页面的WordPress函数。你可以在 <a href="https://codex.wordpress.org/Template_Tags" target="_blank" rel="external">everything you want to know about template tags</a>找到一些关于模板标签的信息。</p>
<p>在大多数情况下，我们会在任何我们想要的时候将模板标签添加到我们的主题之中。然而，还是有时候我们需要将多个模板标签输出到一起。把所有的标签放到一起自然是一个很好的主意，所以想想我们要添加的模板函数，我们把他们视为一个乐符，最终我们把他们组成到一起成为一个交响乐，就像这样：一句描述博文何时发表，被谁，或者一个上一个和下一个博文的链接，或者是一个评论列表，你就能知道了。我们首先写下了乐符，然后播放多次。或者，从专业的角度上来说，写了一个函数，把他调用多次。</p>
<p>为了保证这个教程不会过于冗长，我们将返回到template-tags.php之中来添加一些我们需要的函数。对现在而言，让我们在文件首添加一些基本的文档信息把。</p>
<p><pre class="lang:php decode:true ">&lt;?php<br>/**</pre></p>
<ul>
<li>Custom template tags for this theme.<br>*</li>
<li>Eventually, some of the functionality here could be replaced by core features<br>*</li>
<li>@package Shape</li>
<li>@since Shape 1.0<br>*/<br>最后需要提到一点：“一些在template-tags.php之中的函数功能也许会被核心特性所替代”。这些我们添加的函数将会和WordPress核心特征一样有用。当我们添加了这些函数之后，这回变得更加有意义。</li>
</ul>
<p>现在，我们就能够正常的闭合PHP标签了。</p>
<h3 id="tweak-php"><a href="#tweak-php" class="headerlink" title="tweak.php"></a>tweak.php</h3><p>这些我们放在文件中的函数并不会影响到模板标签，而相反的是他们将会提升我们主题的品质。他们提供了一个很好的后台任务，这样使得我们的主题更好。</p>
<p>在文件的页首，粘贴一些寻常的文档信息到里面。</p>
<p><pre class="lang:php decode:true ">&lt;?php<br>/**</pre></p>
<ul>
<li>Custom functions that act independently of the theme templates<br>*</li>
<li>Eventually, some of the functionality here could be replaced by core features<br>*</li>
<li>@package Shape</li>
<li>@since Shape 1.0<br><em>/<br>接下来，我们要粘贴下面的函数：<br><pre class="lang:php decode:true ">/*</pre></em></li>
<li>Get our wp_nav_menu() fallback, wp_page_menu(), to show a home link.<br>*</li>
<li>@since Shape 1.0<br>*/<br>function shape_page_menu_args( $args ) {<br> $args[‘show_home’] = true;<br> return $args;<br>}<br>add_filter( ‘wp_page_menu_args’, ‘shape_page_menu_args’ );</li>
</ul>
<p>/**</p>
<ul>
<li>Adds custom classes to the array of body classes.<br>*</li>
<li><p>@since Shape 1.0<br>*/<br>function shape_body_classes( $classes ) {<br> // Adds a class of group-blog to blogs with more than 1 published author<br> if ( is_multi_author() ) {</p>
<pre><code>$classes[] = &apos;group-blog&apos;;
</code></pre><p> }</p>
<p> return $classes;<br>}<br>add_filter( ‘body_class’, ‘shape_body_classes’ );</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>Filter in a link to a content ID attribute for the next/previous image links on image attachment pages<br>*</li>
<li><p>@since Shape 1.0<br>*/<br>function shape_enhanced_image_navigation( $url, $id ) {<br> if ( ! is_attachment() &amp;&amp; ! wp_attachment_is_image( $id ) )</p>
<pre><code>return $url;
</code></pre><p> $image = get_post( $id );<br> if ( ! empty( $image-&gt;post_parent ) &amp;&amp; $image-&gt;post_parent != $id )</p>
<pre><code>$url .= &apos;#main&apos;;
</code></pre><p> return $url;<br>}<br>add_filter( ‘attachment_link’, ‘shape_enhanced_image_navigation’, 10, 2 );<br>第一个函数<code>shape_page_menu_args</code>，将会影响到我们主要的导航菜单。我们在之前就已经为导航菜单申请了支持，在<code>shape_setup()</code>之中。如果导航菜单并没有被配置，WordPress将会显示一连串的页面（由<code>wp_page_menu()</code>所决定）</p>
</li>
</ul>
<p>在第二个函数<code>shape_body_classes()</code>，我们将会添加一个新的CSS类，<code>group-blog</code>，到我们的主题标签之中。我们将会在WordPress Header 模板之中提及到<a href="http://codex.wordpress.org/Function_Reference/body_class" target="_blank" rel="external">body class</a>。但是现在，你只需要理解body classes使得我们能够在不同的情况下装饰我们的主题的一些部分（比如我们正在访问的页面类型或者是我们作者的数目）。</p>
<p>最终，第三个函数shape_enhanced_image_navigation()，把#main这个id添加到上一个/下一个图像连接之中。回想一下，“#main”是包装我们的内容和小部件区域的div的ID名称。 ID也是页面内的锚点。 当用户点击您的下一个/上一个图片链接时，他们不必从页面顶部向下滚动来查看每个图片。</p>
<p>这就是tweak.php。记着，我们不需要PHP的闭合标签。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Woo，这里有好多函数，我们已经在这个教程之中做出了大量的工作。但是不要太高兴，这只是万里长征的第一步路罢了。</p>
<p>敬请关注</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们已经创建了一个文件结构，那么现在就让我们开始一个主题把。&lt;/p&gt;
&lt;p&gt;我们需要添加一些主题函数到我们的主题之中，这些函数将会完成下面的
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="wordpress" scheme="http://kidozh.com/tags/wordpress/"/>
    
      <category term="PHP" scheme="http://kidozh.com/tags/PHP/"/>
    
      <category term="主题" scheme="http://kidozh.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>peewee入门</title>
    <link href="http://kidozh.com/2016/12/15/peewee-e5-85-a5-e9-97-a8/"/>
    <id>http://kidozh.com/2016/12/15/peewee-e5-85-a5-e9-97-a8/</id>
    <published>2016-12-15T10:37:46.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>折腾了几天SQLAlchemy，实在是折腾不动了，所以我决定开一个peewee的坑。</p>
<p>那么，迁移必然是有原因的，我来简单的说一下迁移代码的原因。</p>
<ul>
<li>peewee的写法很像Django自带的orm，对于我这种Django支持者很好</li>
<li>其自带的类型比起SQLAlchemy来说，验证起来要简单许多</li>
<li>peewee轻量级，很方便</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="PIP"><a href="#PIP" class="headerlink" title="PIP"></a>PIP</h2><p>最简单的还是通过<code>PIP</code>来安装：</p>
<pre class="lang:default decode:true ">pip install peewee</pre>
peewee包含了两个C的扩展：

*   Speedup ： 其包含了一些可以用C来重写的函数，当Cython已经安装的话，这个模块将会被自动安装。
*   Sqlite扩展 ： 其包含了一些用C操纵的SQLite的函数， REGEXP运算符以及全文搜索排序算法，这个模块应该使用`build_sqlite_ext`命令来安装
安装SQLite扩展的方法：
<pre class="lang:default decode:true ">python setup.py build_sqlite_ext
python setup.py install</pre>

<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>这个工程托管于<a href="https://github.com/coleifer/peewee" target="_blank" rel="external">https://github.com/coleifer/peewee</a>并且可以使用git来安装。</p>
<pre class="lang:default decode:true ">git clone https://github.com/coleifer/peewee.git
cd peewee
python setup.py install</pre>
如果你想构建SQLite扩展，你可以这样：

&nbsp;
<pre class="lang:default decode:true "># Build the sqlite extension and place the shared library alongside the other modules.
python setup.py build_sqlite_ext -i</pre>
在有些系统上，你需要使用`sudo`来提权

# 运行测试样例

运行命令
<pre class="lang:default decode:true ">python setup.py test

# Or use the test runner:
python runtests.py</pre>
你也可以使用`runtests.py`测试指定的特征，默认情况下会使用SQLite数据库，并且playhouse的扩展并不会被测试，你也可以使用下面的命令来查看命令的选项：
<pre class="lang:default decode:true ">python runtests.py --help</pre>

<h1 id="可选的依赖"><a href="#可选的依赖" class="headerlink" title="可选的依赖"></a>可选的依赖</h1><blockquote>
<p>因为大多数的Python发行版都包含SQLite的支持，你并不需要任何区别于标准库的依赖。你可以在命令行中运行import sqlite3来检测，如果你想运行于其他数据库的话，你可以分别使用满足 DB-API 2.0-compatible的驱动，比如针对MySQL的<code>pymysql</code> 或者针对Postgres的<code>psycopg2</code></p>
</blockquote>
<ul>
<li><a href="http://cython.org/" target="_blank" rel="external">Cython</a> ： 通常用于加速。如果你是用SQLite的话，那么速度提升就会变得很明显</li>
<li><a href="https://github.com/rogerbinns/apsw" target="_blank" rel="external">apsw</a> ： 一个可选的SQLite的第三方库，其提供了更好的性能。你可以通过<a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#AESEncryptedField" title="AESEncryptedField" target="_blank" rel="external"><code>&lt;span class=&quot;pre&quot;&gt;AESEncryptedField&lt;/span&gt;</code></a>来使用它。</li>
<li><a href="http://pythonhosted.org/pycrypto/" target="_blank" rel="external">pycrypto</a> ： 一个为了AES加密的库，作用于<a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#AESEncryptedField" title="AESEncryptedField" target="_blank" rel="external"><code>&lt;span class=&quot;pre&quot;&gt;AESEncryptedField&lt;/span&gt;</code></a></li>
<li>bcrypt ： bcrypt加密手段，作用于<a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#PasswordField" title="PasswordField" target="_blank" rel="external"><code>&lt;span class=&quot;pre&quot;&gt;PasswordField&lt;/span&gt;</code></a></li>
<li><a href="http://www.gevent.org/" target="_blank" rel="external">gevent</a> ：为了SqliteQueueDatabase的一个可选的依赖（其和<code>threading</code>这个库运行的很好）</li>
<li><a href="http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html" target="_blank" rel="external">BerkeleyDB</a> ：可以使用SQLite前端编译，它与Peewee一起工作。<br>如果你使用过django和flask框架，那会对你了解peewee非常有用。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;折腾了几天SQLAlchemy，实在是折腾不动了，所以我决定开一个peewee的坑。&lt;/p&gt;
&lt;p&gt;那么，迁移必然是有原因的，我来简单的说一
    
    </summary>
    
      <category term="Python" scheme="http://kidozh.com/categories/Python/"/>
    
      <category term="网页" scheme="http://kidozh.com/categories/Python/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="Python" scheme="http://kidozh.com/tags/Python/"/>
    
      <category term="orm" scheme="http://kidozh.com/tags/orm/"/>
    
      <category term="peewee" scheme="http://kidozh.com/tags/peewee/"/>
    
  </entry>
  
  <entry>
    <title>站点迁移到新加坡</title>
    <link href="http://kidozh.com/2016/12/12/e7-ab-99-e7-82-b9-e8-bf-81-e7-a7-bb-e5-88-b0-e6-96-b0-e5-8a-a0-e5-9d-a1/"/>
    <id>http://kidozh.com/2016/12/12/e7-ab-99-e7-82-b9-e8-bf-81-e7-a7-bb-e5-88-b0-e6-96-b0-e5-8a-a0-e5-9d-a1/</id>
    <published>2016-12-11T18:46:29.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<p>以后还请多多关照啦~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后还请多多关照啦~&lt;/p&gt;

    
    </summary>
    
      <category term="未分类" scheme="http://kidozh.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>python获取系统状态psutil的模块</title>
    <link href="http://kidozh.com/2016/12/01/python-e8-8e-b7-e5-8f-96-e7-b3-bb-e7-bb-9f-e7-8a-b6-e6-80-81psutil-e7-9a-84-e6-a8-a1-e5-9d-97/"/>
    <id>http://kidozh.com/2016/12/01/python-e8-8e-b7-e5-8f-96-e7-b3-bb-e7-bb-9f-e7-8a-b6-e6-80-81psutil-e7-9a-84-e6-a8-a1-e5-9d-97/</id>
    <published>2016-11-30T22:45:35.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要一个可以实时访问系统信息的模块，网上搜索以后，发现了psutil可以大致满足我的要求。</p>
<h1 id="psutil简介"><a href="#psutil简介" class="headerlink" title="psutil简介"></a>psutil简介</h1><p>psutil(Python system and process utilities)是一个跨平台的进程管理和系统工具的python库，可以处理系统CPU，memory，disks，network等信息。主要用于系统资源的监控，分析，以及对进程进行一定的管理。通过psutil可以实现如<code>ps</code>，<code>top</code>，<code>lsof</code>，<code>netstat</code>，<code>ifconfig</code>， <code>who</code>，<code>df</code>，<code>kill</code>，<code>free</code>，<code>nice</code>，<code>ionice</code>，<code>iostat</code>，<code>iotop</code>，<code>uptime</code>，<code>pidof</code>，<code>tty</code>，<code>taskset</code>，<code>pmap</code>。在Linux，windows，OSX，freebsdSun，Solaris等系统上工作，最新的版本python是要高于2.6(Python 2.4 Python2.5 可以用2.1.3版本)</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先确定下当前系统有没有psutil模块</p>
<pre class="lang:python decode:true">import psutil</pre>

<p>如果有的话，就直接导入模块成功，如果没有，就会提示错误然后到官网上下载psutil-2.0.0.tar.gz源码包</p>
<pre class="lang:sh decode:true ">tar -zxf psutil-2.0.0.tar.gz &amp; cd psutil-2.0.0
python setup.py install</pre>

<p>也可以直接使用<span class="lang:sh decode:true  crayon-inline ">pip install psutil</span> 来安装</p>
<h1 id="系统相关功能"><a href="#系统相关功能" class="headerlink" title="系统相关功能"></a>系统相关功能</h1><h2 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h2><h3 id="cpu-times"><a href="#cpu-times" class="headerlink" title="cpu_times"></a>cpu_times</h3><pre class="lang:python decode:true">psutil.cpu_times(precpu=False) </pre>

<p>返回系统CPU运行时间的元组，时间为秒。</p>
<h3 id="cpu-percent"><a href="#cpu-percent" class="headerlink" title="cpu_percent"></a>cpu_percent</h3><pre class="lang:python decode:true ">psutil.cpu_percent(interval=None, percpu=False)</pre>

<p>返回一个浮点数，代表当前cpu的利用率的百分比，包括sy+user. 当<code>interval</code>为0或者None时，表示的是interval时间内的sys的利用率。 当<code>percpu</code>为True返回是每一个cpu的利用率。</p>
<h3 id="cpu-count"><a href="#cpu-count" class="headerlink" title="cpu_count"></a>cpu_count</h3><pre class="lang:python decode:true ">psutil.cpu_count()</pre>

<p>返回CPU的逻辑个数</p>
<pre class="lang:python decode:true ">psutil.cpu_count(logical=True)</pre>

<p>返回CPU的物理个数</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><pre class="lang:python decode:true ">psutil.virtual_memory()</pre>

<p>返回一个内存信息的元组，大小为字节</p>
<ul>
<li>total: 内存的总大小.</li>
<li>available: 可以用来的分配的内存，不同系统计算方式不同； Linux下的计算公式:free+ buffers +cached</li>
<li>percent: 已经用掉内存的百分比 (total - available) / total 100.</li>
<li>used: 已经用掉内存大小，不同系统计算方式不同</li>
<li>*free: 空闲未被分配的内存，Linux下不包括buffers和cached</li>
</ul>
<p>Platform-specific fields:</p>
<ul>
<li>active: (UNIX): 最近使用内存和正在使用内存。</li>
<li>inactive: (UNIX): 已经分配但是没有使用的内存</li>
<li>buffers: (Linux, BSD): 缓存，linux下的Buffers</li>
<li>cached:(Linux, BSD): 缓存，Linux下的cached.</li>
<li>wired: (BSD, OSX): 一直存在于内存中的部分，不会被移除</li>
<li>shared: (BSD): 缓存</li>
</ul>
<p>内存总大小不等于Used+available,在windows系统可用内存和空闲内存是用一个。</p>
<pre class="lang:default decode:true">psutil.swap_memory()</pre>

<p>返回系统的swap信息</p>
<ul>
<li>total: swap的总大小 单位为字节</li>
<li>used: 已用的swap大小 bytes</li>
<li>free: 空闲的swap大小 bytes</li>
<li>percent: 已用swap的百分比</li>
<li>sin: 从磁盘调入是swap的大小</li>
<li>sout: 从swap调出到disk的大小<blockquote>
<p><code>sin</code>，<code>sout</code>在windows<strong>没有意义</strong>。</p>
</blockquote>
</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><pre class="lang:python decode:true">psutil.disk_partitions(all=False)</pre>

<p>返回所有挂载的分区的信息的列表，列表中的每一项类似于df命令的格式输出，包括分区，挂载点，文件系统格式，挂载参数等，会忽略掉<code>/dev/shm</code>,<code>/proc/filesystem</code>等，windows上分区格式 “<code>removable</code>“, “<code>fixed</code>“, “<code>remote</code>“, “<code>cdrom</code>“, “<code>unmounted</code>“ or “<code>ramdisk</code>“。</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.disk_partitions()
[sdiskpart(device='/dev/sda3', mountpoint='/', fstype='ext4', opts='rw,errors=remount-ro'),
 sdiskpart(device='/dev/sda7', mountpoint='/home', fstype='ext4', opts='rw')]</pre>
<pre class="lang:python decode:true">psutil.disk_usage(path) </pre>

<p>返回硬盘，分区或者目录的使用情况，单位字节</p>
<p>如果不存在会报“<code>OSError</code>”错误。</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.disk_usage('/')
sdiskusage(total=21378641920, used=4809781248, free=15482871808, percent=22.5)</pre>
<pre class="lang:python decode:true ">psutil.disk_io_counters(perdisk=False)</pre>

<p>返回当前磁盘的io情况</p>
<ul>
<li>read_count: number of reads</li>
<li>write_count: number of writes</li>
<li>read_bytes: number of bytes read</li>
<li>write_bytes: number of bytes written</li>
<li>read_time: time spent reading from disk (in milliseconds)</li>
<li>write_time: time spent writing to disk (in milliseconds)</li>
</ul>
<h2 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h2><p>返回整个系统的网络信息</p>
<pre class="lang:python decode:true">psutil.net_io_counters(pernic=False)</pre>

<ul>
<li>bytes_sent: 发送的字节数</li>
<li>bytes_recv: 接收的字节数</li>
<li>packets_sent: 发送到数据包的个数</li>
<li>packets_recv: 接受的数据包的个数</li>
<li>errin:</li>
<li>errout: 发送数据包错误的总数</li>
<li>dropin: 接收时丢弃的数据包的总数</li>
<li>dropout: 发送时丢弃的数据包的总数(OSX和BSD系统总是0)</li>
</ul>
<p>如果 <code>pernic</code>值为True，会显示具体各个网卡的信息。</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.net_io_counters()
snetio(bytes_sent=14508483, bytes_recv=62749361, packets_sent=84311, packets_recv=94888, errin=0, errout=0, dropin=0, dropout=0)
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.net_io_counters(pernic=True)
{'lo': snetio(bytes_sent=547971, bytes_recv=547971, packets_sent=5075, packets_recv=5075, errin=0, errout=0, dropin=0, dropout=0),
'wlan0': snetio(bytes_sent=13921765, bytes_recv=62162574, packets_sent=79097, packets_recv=89648, errin=0, errout=0, dropin=0, dropout=0)}</pre>
<pre class="lang:python decode:true">psutil.net_connections(kind='inet') </pre>

<p>返回系统的整个socket连接的信息，可以选择查看哪些类型的连接信息，类似于netstat命令</p>
<p>&nbsp;</p>
<p><strong>fd</strong>:</p>
<p> <strong>family</strong>: the address family, either AF_INET, AF_INET6 or AF_UNIX.</p>
<p> <strong>type</strong>: the address type, either SOCK_STREAM or SOCK_DGRAM.</p>
<p> <strong>laddr</strong>: the local address as a (ip, port) tuple or a path in case of AF_UNIX sockets.</p>
<p> <strong>raddr</strong>: the remote address as a (ip, port) tuple or an absolute path in case of UNIX sockets. When the remote endpoint is not connected you’ll <strong>get an empty tuple (AF_INET*) or None (AF_UNIX). On Linux AF_UNIX sockets will always have this set to None. </strong>status<strong>: represents the status of a TCP connection. The return value is one of the psutil.CONN_* constants (a string). For UDP and UNIX </strong>sockets this is always going to be psutil.CONN_NONE.</p>
<p> <strong>pid</strong>: the PID of the process which opened the socket, if retrievable, else None. On some platforms (e.g. Linux) the availability of this field **changes depending on process privileges (root is needed).</p>
<p>参数kind的类型：</p>
<p> “inet” IPv4 and IPv6</p>
<p> “inet4” IPv4</p>
<p> “inet6” IPv6</p>
<p> “tcp” TCP</p>
<p> “tcp4” TCP over IPv4</p>
<p> “tcp6” TCP over IPv6</p>
<p> “udp” UDP</p>
<p> “udp4” UDP over IPv4</p>
<p> “udp6” UDP over IPv6</p>
<p> “unix” UNIX socket (both UDP and TCP protocols)</p>
<p> “all” the sum of all the possible families and protocols</p>
<pre><code>&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; psutil.net_connections()
[pconn(fd=115, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 48776), raddr=(&apos;93.186.135.91&apos;, 80), status=&apos;ESTABLISHED&apos;, pid=1254),
 pconn(fd=117, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 43761), raddr=(&apos;72.14.234.100&apos;, 80), status=&apos;CLOSING&apos;, pid=2987),
 pconn(fd=-1, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 60759), raddr=(&apos;72.14.234.104&apos;, 80), status=&apos;ESTABLISHED&apos;, pid=None),
 pconn(fd=-1, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 51314), raddr=(&apos;72.14.234.83&apos;, 443), status=&apos;SYN_SENT&apos;, pid=None)
 ...]`&lt;/pre&gt;

## Other system info

`psutil.users()`

 返回当前系统用户登录信息

**user**: 用户的名称

 **terminal**: 运行终端，tty还是pts等

 **host**: 登录的IP

 **started**: 登录了多长时间

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; psutil.users()
[suser(name=&apos;giampaolo&apos;, terminal=&apos;pts/2&apos;, host=&apos;localhost&apos;, started=1340737536.0),
 suser(name=&apos;giampaolo&apos;, terminal=&apos;pts/3&apos;, host=&apos;localhost&apos;, started=1340737792.0)]`&lt;/pre&gt;

`psutil.boot_time()`

 返回当前的时间

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil, datetime
&amp;gt;&amp;gt;&amp;gt; psutil.boot_time()
1389563460.0
&amp;gt;&amp;gt;&amp;gt; datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
&apos;2014-01-12 22:51:00&apos;`&lt;/pre&gt;

* * *

## Processes

### Functions

`psutil.pids()`

 返回当前运行的进程pid列表

`psutil.pid_exists(pid)`

 是否存在次pid，快速的验证方式`pid in psutil.pids()`

`psutil.process_iter()`

 返回一个包含Process对象的迭代器。每一个对象只创建一次，创建后缓存起来。当一个进程更新时，会更新缓存。遍历所有进程首选psutil.pids().迭代器排序是根据pid。

&lt;pre&gt;`import psutil

for proc in psutil.process_iter():
    try:
        pinfo = proc.as_dict(attrs=[&apos;pid&apos;, &apos;name&apos;])
    except psutil.NoSuchProcess:
        pass
    else:
        print(pinfo)`&lt;/pre&gt;

`psutil.wait_procs(procs, timeout=None, callback=None)`

Convenience function which waits for a list of Process instances to terminate. Return a (gone, alive) tuple indicating which processes are gone and which ones are still alive. The gone ones will have a new returncode attribute indicating process exit status (it may be None). callback is a function which gets called every time a process terminates (a Process instance is passed as callback argument). Function will return as soon as all processes terminate or when timeout occurs. Tipical use case is:

send SIGTERM to a list of processes

 give them some time to terminate

 send SIGKILL to those ones which are still alive

Example:

&lt;pre&gt;`import psutil

def on_terminate(proc):
    print(&quot;process {} terminated&quot;.format(proc))

procs = [...]  # a list of Process instances
for p in procs:
    p.terminate()
gone, alive = wait_procs(procs, timeout=3, callback=on_terminate)
for p in alive:
    p.kill()`&lt;/pre&gt;

### Exceptions

`class psutil.Error`

 基础异常，psutil的其他异常都继承这个

`class psutil.NoSuchProcess(pid, name=None, msg=None)`

 当进程不在进程列表中，或者进程不存在时触发。

`class psutil.AccessDenied(pid=None, name=None, msg=None)`

 没有权限时，被触发

`class psutil.TimeoutExpired(seconds, pid=None, name=None, msg=None)`

 当Process.wait() 超时，并且Process 一直在运行时.

# psutil

标签（空格分隔）： Python

* * *

## Process class

`class psutil.Process(pid=None)`

 Process类是一个带有pid的进程。如果没有指定pid，则默认的进程为`os.getpid()`所得进程。Process会触发`NoSuchProcess`（当进程不存在时）和`AccessDenied`异常，

**注意**

&gt; Process是通过pid绑定的。如果在一个Process实例，在psutil运行中pid进程死掉，而
</code></pre><blockquote>
<pre><code>这个pid又绑定给了别的新的进程。为了保证Process的安全性可以通过pid+createion time

方式来确认进程是否是同一个。
</code></pre></blockquote>
<pre><code>`pid`

 进程的PID

`ppid()`

 父进程pid. On Windows the return value is cached after first call.

`name()`

 进程名.

`exe()`

 进程运行命令的绝对路径。

`cmdline()`

 The command line this process has been called with.

`create_time()`

 进程创建时间

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil, datetime
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.create_time()
1307289803.47
&amp;gt;&amp;gt;&amp;gt; datetime.datetime.fromtimestamp(p.create_time()).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
&apos;2011-03-05 18:03:52&apos;`&lt;/pre&gt;

`as_dict(attrs=None, ad_value=None)`

 返回进程信息的哈希字典的实用方法，`attrs`指定的值必须是Process的属性值，例如（[&apos;cpu_times&apos;,&apos;name&apos;]）

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.as_dict(attrs=[&apos;pid&apos;, &apos;name&apos;, &apos;username&apos;])
{&apos;username&apos;: &apos;giampaolo&apos;, &apos;pid&apos;: 12366, &apos;name&apos;: &apos;python&apos;}`&lt;/pre&gt;

`parent()`

 返回父进程，如果不存在父进程，则返回None。

`status()`

 进程当前运行状态，string形式。

`cwd()`

 进程运行的所在的目录

`username()`

 哪个用户下运行的进程

`uids()`

 返回real=uid，effective，saved用户的uid

**Availability**: UNIX

`gids()`

**Availability**: UNIX

`terminal()`

 The terminal associated with this process, if any, else None. This is similar to “tty” command but can be used for every process PID.

**Availability**: UNIX

`nice(value=None)`

 获取或者设置进程的nice值，

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.nice(10)  # set
&amp;gt;&amp;gt;&amp;gt; p.nice()  # get
10
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

在windows系统上，只能通过`GetProrityClass`和`SetPriorityClass`的`psutil.*_PRIORITY_CLASS`包含的值来设定

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; p.nice(psutil.HIGH_PRIORITY_CLASS)`&lt;/pre&gt;

`ionice(ioclass=None, value=None)`

 获取或者设置进程I/O的优先级。Linux上的`ioclass`的值`psutil.IOPRO_CLASS_*`值在0-7，windows 2 为正常，1为优先级低，0为非常低。

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.ionice(psutil.IOPRIO_CLASS_IDLE)  # set
&amp;gt;&amp;gt;&amp;gt; p.ionice()  # get
pionice(ioclass=3, value=0)
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

`rlimit(resource, limits=None)`

 Get or set process resource limits (see man prlimit). resource is one of the psutil.RLIMIT_* constants. limits is a (soft, hard) tuple. This is the same as resource.getrlimit() and resource.setrlimit() but can be used for every process PID and only on Linux. Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; # process may open no more than 128 file descriptors
&amp;gt;&amp;gt;&amp;gt; p.rlimit(psutil.RLIMIT_NOFILE, (128, 128))
&amp;gt;&amp;gt;&amp;gt; # process may create files no bigger than 1024 bytes
&amp;gt;&amp;gt;&amp;gt; p.rlimit(psutil.RLIMIT_FSIZE, (1024, 1024))
&amp;gt;&amp;gt;&amp;gt; # get
&amp;gt;&amp;gt;&amp;gt; p.rlimit(psutil.RLIMIT_FSIZE)
(1024, 1024)
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

**Availability**: Linux

`io_counters()`

 返回这个进程的IO情况

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.io_counters()
pio(read_count=454556, write_count=3456, read_bytes=110592, write_bytes=0)`&lt;/pre&gt;

**Availability**: all platforms except OSX

`num_ctx_switches()`

 The number voluntary and involuntary context switches performed by this process.

`num_fds()`

 The number of file descriptors used by this process.

**Availability**: UNIX

`num_handles()`

 The number of handles used by this process.

**Availability**: Windows

`num_threads()`

 The number of threads currently used by this process.

`threads()`

 Return threads opened by process as a list of namedtuples including thread id and thread CPU times (user/system).

`cpu_times()`

 Return a tuple whose values are process CPU user and system times which means the amount of time expressed in seconds that a process has spent in user / system mode. This is similar to os.times() but can be used for every process PID.

`cpu_percent(interval=None)`

 Return a float representing the process CPU utilization as a percentage. When interval is &amp;gt; 0.0 compares process times to system CPU times elapsed before and after the interval (blocking). When interval is 0.0 or None compares process times to system CPU times elapsed since last call, returning immediately. That means the first time this is called it will return a meaningless 0.0 value which you are supposed to ignore. In this case is recommended for accuracy that this function be called a second time with at least 0.1 seconds between calls. Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # blocking
&amp;gt;&amp;gt;&amp;gt; p.cpu_percent(interval=1)
2.0
&amp;gt;&amp;gt;&amp;gt; # non-blocking (percentage since last call)
&amp;gt;&amp;gt;&amp;gt; p.cpu_percent(interval=None)
2.9
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

Note a percentage &amp;gt; 100 is legitimate as it can result from a process with multiple threads running on different CPU cores.

 Warning the first time this method is called with interval = 0.0 or None it will return a meaningless 0.0 value which you are supposed to ignore.

 cpu_affinity(cpus=None)

 Get or set process current CPU affinity. CPU affinity consists in telling the OS to run a certain process on a limited set of CPUs only. The number of eligible CPUs can be obtained with list(range(psutil.cpu_count())).

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; psutil.cpu_count()
4
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity()  # get
[0, 1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity([0])  # set; from now on, process will run on CPU #0 only
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity()
[0]
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # reset affinity against all CPUs
&amp;gt;&amp;gt;&amp;gt; all_cpus = list(range(psutil.cpu_count()))
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity(all_cpus)
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

**Availability**: Linux, Windows, BSD

Changed in version 2.2.0: added support for FreeBSD

`memory_info()`

 Return a tuple representing RSS (Resident Set Size) and VMS (Virtual Memory Size) in bytes. On UNIX rss and vms are the same values shown by ps. On Windows rss and vms refer to “Mem Usage” and “VM Size” columns of taskmgr.exe. For more detailed memory stats use memory_info_ex().

`memory_info_ex()`

 Return a namedtuple with variable fields depending on the platform representing extended memory information about the process. All numbers are expressed in bytes.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Linux&lt;/th&gt;
&lt;th&gt;OSX&lt;/th&gt;
&lt;th&gt;BSD&lt;/th&gt;
&lt;th&gt;SunOS&lt;/th&gt;
&lt;th&gt;Windows&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;num_page_faults&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;peak_wset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shared&lt;/td&gt;
&lt;td&gt;pfaults&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;wset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;pageins&lt;/td&gt;
&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;peak_paged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lib&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;stack&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;paged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;peak_nonpaged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dirty&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;nonpaged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;pagefile&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;peak_pagefile&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;private&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Windows metrics are extracted from PROCESS_MEMORY_COUNTERS_EX structure. Example on Linux:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.memory_info_ex()
pextmem(rss=15491072, vms=84025344, shared=5206016, text=2555904, lib=0, data=9891840, dirty=0)`&lt;/pre&gt;

`memory_percent()`

 Compare physical system memory to process resident memory (RSS) and calculate process memory utilization as a percentage.

`memory_maps(grouped=True)`

 Return process’s mapped memory regions as a list of nameduples whose fields are variable depending on the platform. As such, portable applications should rely on namedtuple’s path and rss fields only. This method is useful to obtain a detailed representation of process memory usage as explained here. If grouped is True the mapped regions with the same path are grouped together and the different memory fields are summed. If grouped is False every mapped region is shown as a single entity and the namedtuple will also include the mapped region’s address space (addr) and permission set (perms). See examples/pmap.py for an example application.

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.memory_maps()
[pmmap_grouped(path=&apos;/lib/x8664-linux-gnu/libutil-2.15.so&apos;, rss=16384, anonymous=8192, swap=0),
 pmmap_grouped(path=&apos;/lib/x8664-linux-gnu/libc-2.15.so&apos;, rss=6384, anonymous=15, swap=0),
 pmmap_grouped(path=&apos;/lib/x8664-linux-gnu/libcrypto.so.0.1&apos;, rss=34124, anonymous=1245, swap=0),
 pmmap_grouped(path=&apos;[heap]&apos;, rss=54653, anonymous=8192, swap=0),
 pmmap_grouped(path=&apos;[stack]&apos;, rss=1542, anonymous=166, swap=0),
 ...]
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

`children(recursive=False)`

 Return the children of this process as a list of Process objects, pre-emptively checking whether PID has been reused. If recursive is True return all the parent descendants. Example assuming A == this process:

A ─┐

 │

 ├─ B (child) ─┐

 │ └─ X (grandchild) ─┐

 │ └─ Y (great grandchild)

 ├─ C (child)

 └─ D (child)

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt; p.children()
B, C, D
&amp;gt;&amp;gt;&amp;gt; p.children(recursive=True)
B, X, Y, C, D`&lt;/pre&gt;

Note that in the example above if process X disappears process Y won’t be returned either as the reference to process A is lost.

`open_files()`

 Return regular files opened by process as a list of namedtuples including the absolute file name and the file descriptor number (on Windows this is always -1). Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; f = open(&apos;file.ext&apos;, &apos;w&apos;)
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.open_files()
[popenfile(path=&apos;/home/giampaolo/svn/psutil/file.ext&apos;, fd=3)]`&lt;/pre&gt;

`connections(kind=&quot;inet&quot;)`

 Return socket connections opened by process as a list of namedutples. To get system-wide connections use psutil.net_connections(). Every namedtuple provides 6 attributes:

**fd:** the socket file descriptor. This can be passed to socket.fromfd() to obtain a usable socket object. This is only available on UNIX; on Windows -1 is always returned.

 **family:** the address family, either AF_INET, AF_INET6 or AF_UNIX.

 **type:** the address type, either SOCK_STREAM or SOCK_DGRAM.

 **laddr:** the local address as a (ip, port) tuple or a path in case of AF_UNIX sockets.

 **raddr:** the remote address as a (ip, port) tuple or an absolute path in case of UNIX sockets. When the remote endpoint is not connected you’ll get an empty tuple (AF_INET) or None (AF_UNIX). On Linux AF_UNIX sockets will always have this set to None.

 **status:** represents the status of a TCP connection. The return value is one of the psutil.CONN_* constants. For UDP and UNIX sockets this is always going to be `psutil.CONN_NONE`.

The kind parameter is a string which filters for connections that fit the following criteria:

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Kind value&lt;/th&gt;
&lt;th&gt;Connections using&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;“inet”&lt;/td&gt;
&lt;td&gt;IPv4 and IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“inet4”&lt;/td&gt;
&lt;td&gt;IPv4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“inet6”&lt;/td&gt;
&lt;td&gt;IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“tcp”&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“tcp4”&lt;/td&gt;
&lt;td&gt;TCP over IPv4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“tcp6”&lt;/td&gt;
&lt;td&gt;TCP over IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“udp”&lt;/td&gt;
&lt;td&gt;UDP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“udp4”&lt;/td&gt;
&lt;td&gt;UDP over IPv4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“udp6”&lt;/td&gt;
&lt;td&gt;UDP over IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“unix”&lt;/td&gt;
&lt;td&gt;UNIX socket (both UDP and TCP protocols)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“all”&lt;/td&gt;
&lt;td&gt;the sum of all the possible families and protocols&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process(1694)
&amp;gt;&amp;gt;&amp;gt; p.name()
&apos;firefox&apos;
&amp;gt;&amp;gt;&amp;gt; p.connections()
[pconn(fd=115, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 48776), raddr=(&apos;93.186.135.91&apos;, 80), status=&apos;ESTABLISHED&apos;),
 pconn(fd=117, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 43761), raddr=(&apos;72.14.234.100&apos;, 80), status=&apos;CLOSING&apos;),
 pconn(fd=119, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 60759), raddr=(&apos;72.14.234.104&apos;, 80), status=&apos;ESTABLISHED&apos;),
 pconn(fd=123, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 51314), raddr=(&apos;72.14.234.83&apos;, 443), status=&apos;SYN_SENT&apos;)]`&lt;/pre&gt;

`is_running()`

 判断进程是否存活

 Return whether the current process is running in the current process list. This is reliable also in case the process is gone and its PID reused by another process, therefore it must be preferred over doing psutil.pid_exists(p.pid).

Note this will return True also if the process is a zombie (p.status() == psutil.STATUS_ZOMBIE).

 `send_signal(signal)`

 发送新号给进程

 Send a signal to process (see signal module constants) pre-emptively checking whether PID has been reused. This is the same as os.kill(pid, sig). On Windows only SIGTERM is valid and is treated as an alias for kill().

`suspend()`

 Suspend process execution with SIGSTOP signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGSTOP). On Windows this is done by suspending all process threads execution.

`resume()`

 Resume process execution with SIGCONT signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGCONT). On Windows this is done by resuming all process threads execution.

`terminate()`

 Terminate the process with SIGTERM signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGTERM). On Windows this is an alias for kill().

`kill()`

 Kill the current process by using SIGKILL signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGKILL). On Windows this is done by using TerminateProcess.

`wait(timeout=None)`

 Wait for process termination and if the process is a children of the current one also return the exit code, else None. On Windows there’s no such limitation (exit code is always returned). If the process is already terminated immediately return None instead of raising NoSuchProcess. If timeout is specified and process is still alive raise TimeoutExpired exception. It can also be used in a non-blocking fashion by specifying timeout=0 in which case it will either return immediately or raise TimeoutExpired. To wait for multiple processes use psutil.wait_procs().

### Popen class

`class psutil.Popen(*args, **kwargs)`

 A more convenient interface to stdlib subprocess.Popen. It starts a sub process and deals with it exactly as when using subprocess.Popen but in addition it also provides all the methods of psutil.Process class in a single interface. For method names common to both classes such as send_signal(), terminate() and kill() psutil.Process implementation takes precedence. For a complete documentation refer to subprocess module documentation.

Note Unlike subprocess.Popen this class pre-emptively checks wheter PID has been reused on send_signal(), terminate() and kill() so that you don’t accidentally terminate another process, fixing [http://bugs.python.org/issue6973](http://bugs.python.org/issue6973).

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; from subprocess import PIPE
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; p = psutil.Popen([&quot;/usr/bin/python&quot;, &quot;-c&quot;, &quot;print(&apos;hello&apos;)&quot;], stdout=PIPE)
&amp;gt;&amp;gt;&amp;gt; p.name()
&apos;python&apos;
&amp;gt;&amp;gt;&amp;gt; p.username()
&apos;giampaolo&apos;
&amp;gt;&amp;gt;&amp;gt; p.communicate()
(&apos;hello\n&apos;, None)
&amp;gt;&amp;gt;&amp;gt; p.wait(timeout=2)
0
&amp;gt;&amp;gt;&amp;gt;
</code></pre><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><blockquote>
<p>psutil.STATUS_RUNNING</p>
<p> psutil.STATUS_SLEEPING</p>
<p> psutil.STATUS_DISK_SLEEP</p>
<p> psutil.STATUS_STOPPED</p>
<p> psutil.STATUS_TRACING_STOP</p>
<p> psutil.STATUS_ZOMBIE</p>
<p> psutil.STATUS_DEAD</p>
<p> psutil.STATUS_WAKE_KILL</p>
<p> psutil.STATUS_WAKING</p>
<p> psutil.STATUS_IDLE</p>
<p> psutil.STATUS_LOCKED</p>
<p> psutil.STATUS_WAITING</p>
</blockquote>
<p>A set of strings representing the status of a process. Returned by psutil.Process.status().</p>
<blockquote>
<p>psutil.CONN_ESTABLISHED</p>
<p> psutil.CONN_SYN_SENT</p>
<p> psutil.CONN_SYN_RECV</p>
<p> psutil.CONN_FIN_WAIT1</p>
<p> psutil.CONN_FIN_WAIT2</p>
<p> psutil.CONN_TIME_WAIT</p>
<p> psutil.CONN_CLOSE</p>
<p> psutil.CONN_CLOSE_WAIT</p>
<p> psutil.CONN_LAST_ACK</p>
<p> psutil.CONN_LISTEN</p>
<p> psutil.CONN_CLOSING</p>
<p> psutil.CONN_NONE</p>
<p> psutil.CONN_DELETE_TCB(Windows)</p>
<p> psutil.CONN_IDLE(Solaris)</p>
<p> psutil.CONN_BOUND(Solaris)</p>
</blockquote>
<p>A set of strings representing the status of a TCP connection. Returned by psutil.Process.connections() (status field).</p>
<blockquote>
<p>psutil.ABOVE_NORMAL_PRIORITY_CLASS</p>
<p> psutil.BELOW_NORMAL_PRIORITY_CLASS</p>
<p> psutil.HIGH_PRIORITY_CLASS</p>
<p> psutil.IDLE_PRIORITY_CLASS</p>
<p> psutil.NORMAL_PRIORITY_CLASS</p>
<p> psutil.REALTIME_PRIORITY_CLASS</p>
<p> A set of integers representing the priority of a process on Windows (see MSDN documentation). They can be used in conjunction with psutil.Process.nice() to get or set process priority.</p>
</blockquote>
<p><strong>Availability</strong>: Windows</p>
<p>psutil.IOPRIO_CLASS_NONE</p>
<p> psutil.IOPRIO_CLASS_RT</p>
<p> psutil.IOPRIO_CLASS_BE</p>
<p> psutil.IOPRIO_CLASS_IDLE</p>
<p> A set of integers representing the I/O priority of a process on Linux. They can be used in conjunction with psutil.Process.ionice() to get or set process I/O priority. IOPRIO_CLASS_NONE and IOPRIO_CLASS_BE (best effort) is the default for any process that hasn’t set a specific I/O priority. IOPRIO_CLASS_RT (real time) means the process is given first access to the disk, regardless of what else is going on in the system. IOPRIO_CLASS_IDLE means the process will get I/O time when no-one else needs the disk. For further information refer to manuals of ionice command line utility or ioprio_get system call.</p>
<p><strong>Availability</strong>: Linux</p>
<blockquote>
<p>psutil.RLIMIT_INFINITY</p>
<p> psutil.RLIMIT_AS</p>
<p> psutil.RLIMIT_CORE</p>
<p> psutil.RLIMIT_CPU</p>
<p> psutil.RLIMIT_DATA</p>
<p> psutil.RLIMIT_FSIZE</p>
<p> psutil.RLIMIT_LOCKS</p>
<p> psutil.RLIMIT_MEMLOCK</p>
<p> psutil.RLIMIT_MSGQUEUE</p>
<p> psutil.RLIMIT_NICE</p>
<p> psutil.RLIMIT_NOFILE</p>
<p> psutil.RLIMIT_NPROC</p>
<p> psutil.RLIMIT_RSS</p>
<p> psutil.RLIMIT_RTPRIO</p>
<p> psutil.RLIMIT_RTTIME</p>
<p> psutil.RLIMIT_RTPRIO</p>
<p> psutil.RLIMIT_SIGPENDING</p>
<p> psutil.RLIMIT_STACK</p>
<p> Constants used for getting and setting process resource limits to be used in conjunction with psutil.Process.rlimit(). See man prlimit for futher information.</p>
</blockquote>
<p><strong>Availability</strong>: Linux</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近需要一个可以实时访问系统信息的模块，网上搜索以后，发现了psutil可以大致满足我的要求。&lt;/p&gt;
&lt;h1 id=&quot;psutil简介&quot;&gt;
    
    </summary>
    
      <category term="Python" scheme="http://kidozh.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>bcrypt的使用方法</title>
    <link href="http://kidozh.com/2016/11/28/bcrypt-e7-9a-84-e4-bd-bf-e7-94-a8-e6-96-b9-e6-b3-95/"/>
    <id>http://kidozh.com/2016/11/28/bcrypt-e7-9a-84-e4-bd-bf-e7-94-a8-e6-96-b9-e6-b3-95/</id>
    <published>2016-11-27T16:29:32.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还是因为倒腾lab.npuacm.info，看了网上的一些关于密码存储的报道，再加上我之前开发Django的经验，我选择bcrypt作为加密密码的方法。</p>
<p>bcrypt作为一种非常有力的加密手法。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>最简单的还是使用pip了：</p>
<pre class="lang:default decode:true ">$ pip install bcrypt</pre>

<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>哈希然后检查这个值是否正确很简单：</p>
<pre class="lang:python decode:true ">import bcrypt
password = b"super secret password"
# Hash a password for the first time, with a randomly-generated salt
hashed = bcrypt.hashpw(password, bcrypt.gensalt())
# Check that a unhashed password matches one that has previously been
#   hashed
if bcrypt.hashpw(password, hashed) == hashed:
     print("It Matches!")
else:
     print("It Does not Match :(")</pre>

<h1 id="可调节的工作轮次"><a href="#可调节的工作轮次" class="headerlink" title="可调节的工作轮次"></a>可调节的工作轮次</h1><p>bcrypt的特性之一是可调的工作轮次。调节这个轮次，你只需要传入round的参数就可以了。<code>bcrypt.gensalt(rounds=12)</code> 默认的就是12</p>
<pre class="lang:python decode:true ">import bcrypt
password = b"super secret password"
# Hash a password for the first time, with a certain number of rounds
hashed = bcrypt.hashpw(password, bcrypt.gensalt(14))
# Check that a unhashed password matches one that has previously been
#   hashed
if bcrypt.hashpw(password, hashed) == hashed:
    print("It Matches!")
else:
    print("It Does not Match :(")</pre>

<h1 id="可调节的前缀"><a href="#可调节的前缀" class="headerlink" title="可调节的前缀"></a>可调节的前缀</h1><p>你也可以调整bcrypt的前缀来决定其会兼容谁，你可以传递2a或者2b（默认值）来决定。</p>
<pre class="lang:python decode:true ">bcrypt.gensalt(prefix=b"2b") </pre>

<h1 id="兼容的版本"><a href="#兼容的版本" class="headerlink" title="兼容的版本"></a>兼容的版本</h1><p>其可以运行于Python2.6+、3.2+以及PyPy之上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;还是因为倒腾lab.npuacm.info，看了网上的一些关于密码存储的报道，再加上我之前开发Django的经验，我选择bcrypt作为加密
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="bcrypt" scheme="http://kidozh.com/tags/bcrypt/"/>
    
      <category term="密码" scheme="http://kidozh.com/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>Nginx对于Tornado的配置</title>
    <link href="http://kidozh.com/2016/11/27/nginx-e5-af-b9-e4-ba-8etornado-e7-9a-84-e9-85-8d-e7-bd-ae/"/>
    <id>http://kidozh.com/2016/11/27/nginx-e5-af-b9-e4-ba-8etornado-e7-9a-84-e9-85-8d-e7-bd-ae/</id>
    <published>2016-11-27T15:38:23.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直被轰炸HTTPS的好处，于是咬咬牙把<a href="https://lab.npuacm.info" target="_blank" rel="external">lab.npuacm.info</a>加了个SSL。下面我就简单的说一下步骤。</p>
<h1 id="获得SSL证书"><a href="#获得SSL证书" class="headerlink" title="获得SSL证书"></a>获得SSL证书</h1><p>对于SSL证书，我们可以在下面这些网站获得：</p>
<ol>
<li><a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s encrypt</a></li>
<li><a href="https://www.startssl.com/" target="_blank" rel="external">StartSSL</a></li>
<li>腾讯云提供的<a href="https://www.qcloud.com/product/ssl.html" target="_blank" rel="external">SSL</a>证书</li>
</ol>
<p>前面几种网上案例很多，我就不多说了，需要注意的是第一和第二个都是需要Shell权限的，所以如果你没有权限的话，那就需要联系一下你的server提供商了。</p>
<h1 id="配置Nginx服务器"><a href="#配置Nginx服务器" class="headerlink" title="配置Nginx服务器"></a>配置Nginx服务器</h1><p>网上主要可以配置Nginx和Tornado主程序两种，不过我还是建议各位dalao直接去配置Nginx，毕竟耐艹，而且对于静态文件而言，还需要Nginx来处理。</p>
<p>首先，我的思路是，需要对原来的HTTP访问全部转发到HTTPS上，所以，我们可以在Nginx中配置这一项。</p>
<pre class="lang:default decode:true " title="转发到安全的连接服务">server {
    listen 80;
    server_name example.com;

    rewrite /(.*) https://$http_host/$1 redirect;
}</pre>

<p>然后就要对HTTPS进行配置</p>
<pre class="lang:default decode:true ">server {
    listen 443;
    ssl on;
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/cert.key;

    default_type application/octet-stream;

    location /static/ {
        root /var/www/static;
        if ($query_string) {
            expires max;
        }
    }

    location = /favicon.ico {
        rewrite (.*) /static/favicon.ico;
    }

    location / {
        proxy_pass_header Server;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://tornadoes;
    }
}</pre>

<p>但是这样明显不够，因为我的tornado中使用了Websocket技术，这里就不能使用<code>ws://</code>协议而应该是<code>wss://</code>了，所以我们需要告诉Nginx开启Websocket服务。</p>
<p>所以最终的代码应该是</p>
<pre class="lang:default decode:true ">upstream tornados{
    server 127.0.0.1:8003;
    server 127.0.0.1:8001;
    server 127.0.0.1:8002;
}
proxy_next_upstream error;
server {
    listen  80;
    server_name lab.npuacm.info;

    # rewrite
    rewrite /(.*) https://$http_host/$1 redirect;
}
server{
    listen 443;
    ssl on;
    server_name lab.npuacm.info;

    ssl_certificate your_public_key.crt;
    ssl_certificate_key your_key.key;

    default_type application/octet-stream;

    # Nginx处理这个问题
    location /static/ {
        root /home/ubuntu/npuacmLab;
        if ($query_string){
            expires 24h;
        }
    }
    location / {
        proxy_pass_header Server;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://tornados;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }
}

</pre>

<p>自然，如果你并不想配置ngnix的话，你可以直接在本地开启HTTPS服务。</p>
<pre class="lang:python decode:true ">    http_server = tornado.httpserver.HTTPServer(app
        ssl_options={
        "certfile": os.path.join(os.path.abspath("SSL"), "public_key.crt"),
        "keyfile": os.path.join(os.path.abspath("SSL"), "private_key.key"),
    }
    )
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()</pre>

<p>这样本地调试的时候，你就可以直接输入HTTPS调试了，同样的Websocket也可以直接使用<code>wss://</code>协议了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>被国内运营商劫持的满屏幕都是充话费的。。。也是醉了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近一直被轰炸HTTPS的好处，于是咬咬牙把&lt;a href=&quot;https://lab.npuacm.info&quot; target=&quot;_blank
    
    </summary>
    
      <category term="Python" scheme="http://kidozh.com/categories/Python/"/>
    
      <category term="网页" scheme="http://kidozh.com/categories/Python/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="Nginx" scheme="http://kidozh.com/tags/Nginx/"/>
    
      <category term="HTTPS" scheme="http://kidozh.com/tags/HTTPS/"/>
    
      <category term="tornado" scheme="http://kidozh.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>ABAQUS模拟螺栓连接的方法</title>
    <link href="http://kidozh.com/2016/11/14/abaqus-e6-a8-a1-e6-8b-9f-e8-9e-ba-e6-a0-93-e8-bf-9e-e6-8e-a5-e7-9a-84-e6-96-b9-e6-b3-95/"/>
    <id>http://kidozh.com/2016/11/14/abaqus-e6-a8-a1-e6-8b-9f-e8-9e-ba-e6-a0-93-e8-bf-9e-e6-8e-a5-e7-9a-84-e6-96-b9-e6-b3-95/</id>
    <published>2016-11-13T21:52:14.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>螺栓连接是结构连接的一种主要方式，在CAE分析中经常遇到，针对不同的情况，通常我们会采取不同的方法来处理。如果仿真的重点在于模拟螺栓，要求输出螺栓的应力、变形数据等，则将其创建为三维部件进行精细建模；如果螺栓在仿真过程中是次要的，只起简单的连接和紧固作用，则可以使用MPC约束和梁单元对螺栓进行简化建模。作为一款功能强大的通用CAE软件，ABAQUS处理普通螺栓连接的方式有三种：带螺纹的实体螺栓、不带螺纹的实体螺栓和MPC与梁单元组合的螺栓简化模型。</p>
<h1 id="带螺纹的实体螺栓"><a href="#带螺纹的实体螺栓" class="headerlink" title="带螺纹的实体螺栓"></a>带螺纹的实体螺栓</h1><p>对于带螺纹的实体螺栓仿真，只需在ABAQUS中定义适当的接触关系，选择合适的摩擦系数即可，通常使用通用接触即可满足计算的要求。采用这种实体螺栓的仿真计算，虽然得到的结果很精确，但却大大增加了螺栓模型前处理的工作量（螺栓和螺纹均用六面体网格建模），且计算量大，计算过程中接触收敛困难。因此，在精度要求不高的情况下，不采用这种实体螺栓模型。</p>
<h1 id="不带螺纹的实体螺栓"><a href="#不带螺纹的实体螺栓" class="headerlink" title="不带螺纹的实体螺栓"></a>不带螺纹的实体螺栓</h1><p>为了简化模型，提高计算的效率，可以创建不带螺纹的实体螺栓模型。这种情况下，只需在ABAQUS的接触定义中设置跟实际螺纹形状有关联的参数，如牙角、螺距、螺栓小径等，即可以模拟真实的螺栓连接接触状况，得到足够精确的结果，同时节省了分析的时间，提高分析效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;螺栓连接是结构连接的一种主要方式，在CAE分析中经常遇到，针对不同的情况，通常我们会采取不同的方法来处理。如果仿真的重点在于模拟螺栓，要求输
    
    </summary>
    
      <category term="机械" scheme="http://kidozh.com/categories/%E6%9C%BA%E6%A2%B0/"/>
    
    
      <category term="ABAQUS" scheme="http://kidozh.com/tags/ABAQUS/"/>
    
      <category term="FEM" scheme="http://kidozh.com/tags/FEM/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy关系</title>
    <link href="http://kidozh.com/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/"/>
    <id>http://kidozh.com/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/</id>
    <published>2016-11-04T20:20:42.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>『关系』是关系型数据库的一大特色，也是我们在建模过程中的一个重要的抽象过程。在前面的两个教程中，我们分别回顾了使用SQLAlchemy在数据库中进行<a href="http://www.jianshu.com/p/0d234e14b5d3" target="_blank" rel="external">创建</a>和<a href="http://www.jianshu.com/p/8d085e2f2657" target="_blank" rel="external">简单查询</a>的方法，今天我们来深入到更为复杂和抽象部分。</p>
<h1 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h1><p>之前我们已经建立了一个用户(User)表，现在我们来考虑增加一个与用户关联的新的表。在我们的系统里面，用户可以存储多个与之相关的email地址。这是一种基本的一对多的关系。我们把这个新增加的存储email地址的表称为<code>addresses</code>。应用Declarative，我们按照如下方式定义这个新表：</p>
<pre><code>&amp;gt;&amp;gt;&amp;gt; from sqlalchemy import ForeignKey
&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.orm import relationship

&amp;gt;&amp;gt;&amp;gt; class Address(Base):
...     __tablename__ = &lt;span class=&quot;hljs-string&quot;&gt;&apos;addresses&apos;&lt;/span&gt;
...     id = Column(Integer, primary_key=True)
...     email_address = Column(String, nullable=False)
...     user_id = Column(Integer, ForeignKey(&lt;span class=&quot;hljs-string&quot;&gt;&apos;users.id&apos;&lt;/span&gt;))
...
...     user = relationship(&lt;span class=&quot;hljs-string&quot;&gt;&quot;User&quot;&lt;/span&gt;, back_populates=&lt;span class=&quot;hljs-string&quot;&gt;&quot;addresses&quot;&lt;/span&gt;)
...
...     def __repr__(self):
...         &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;Address(email_address=&apos;%s&apos;)&amp;gt;&quot;&lt;/span&gt; % self.email_address

&amp;gt;&amp;gt;&amp;gt; User.addresses = relationship(
...     &lt;span class=&quot;hljs-string&quot;&gt;&quot;Address&quot;&lt;/span&gt;, order_by=Address.id, back_populates=&lt;span class=&quot;hljs-string&quot;&gt;&quot;user&quot;&lt;/span&gt;)`&lt;/pre&gt;

上面的代码中我们使用了一个新的名为`ForeignKey`的构造。其含义为，其所在的列的值域应当被限制在另一个表的指定列的取值范围之类。这一特性是关系型数据库的核心特性之一。就上例而言，`addresses.user_id`这一列的取值范围，应当包含在`users.id`的取值范围之内。

除了`ForeignKey`之外，我们还引入了一个`relationship`，来告诉ORM，`Address`类需要被连接到`User`类。`relationship`和`ForeignKey`这个两个属性决定了表之间关系的属性，决定了这个关系是多对一的。

在完成对`Address`类的声明之后，我们还定义另一个`relationship`，将其赋值给了`User.addresses`。在两个`relationship`中，我们都有传入了一个`relationship.back_populates`的属性来为反向关系所对应的属性进行命名。（作者：到这里为止，看来SQLAlchemy中定义关系要比Django的ORM要麻烦许多。Django中只需要一行就可以了。而且这里的两个`relationship`的定义明显是冗余的）

多对一的关系的反向永远都是一对多的关系。关于更多的`relationship()`的配置方法，可以参见这个链接[Basic Relationship Patterns](http://docs.sqlalchemy.org/en/rel_1_0/orm/basic_relationships.html#relationship-patterns)。

上述我们定义的两个互补的关系`Address.user`和`User.addresses`被称为双向关系([bidirectional relationship](http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-bidirectional-relationship))，这是SQLAlchemy的核心特性这一。

`relationship()`的参数配置中指向被连接的类的字符串，可以指向工程中任何位置所定义的，基于`declarative base`的类，而无先后之分。Declarative会在完成所有的映射以后的将这些字符串转换为适当的、实际使用的参数形式。

# 使用关联对象

现在，当我们创建一个`User`实例的时候，会同时创建一个空的`addresses`的collection。这个collection可能是多种类型，如list, set, 或是dictionary。默认情况下，其应当为一个Python列表。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack = User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; jack.addresses
[]`&lt;/pre&gt;

此时你可以自由的向这个列表里面插入`User`对象。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack.addresses = [
...                 Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;),
...                 Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)]`&lt;/pre&gt;

当使用bidirectional relationship时，通过其中一个方向的关系（如上例）会自动出现在另一个方向的关系上。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack.addresses[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]
&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; jack.addresses[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].user
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

让我们把jack添加进入`Session`。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; session.add(jack)
&amp;gt;&amp;gt;&amp;gt; session.commit()
INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)
INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)
INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)
COMMIT`&lt;/pre&gt;

可以发现上面执行了三个`INSERT`命令，也就是说与jack关联的两个`Address`对象也被提交了。现在我们通过查询来取出jack。

&lt;pre class=&quot;hljs php&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack = session.query(User).\
... filter_by(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;).one()
BEGIN (implicit)
SELECT users.id &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_id,
        users.name &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_name,
        users.fullname &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_fullname,
        users.password &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_password
FROM users
WHERE users.name = ?
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;,)

&amp;gt;&amp;gt;&amp;gt; jack
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

可以发现目前只有针对`User`表的查询，而没有对`Address`表的查询。此时访问`addresses`属性，相关的SQL才会执行

&lt;pre class=&quot;hljs php&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack.addresses
SELECT addresses.id &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; addresses_id,
        addresses.email_address &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt;
        addresses_email_address,
        addresses.user_id &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; addresses_user_id
FROM addresses
WHERE ? = addresses.user_id ORDER BY addresses.id
(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,)
[&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;)&amp;gt;, &amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)&amp;gt;]`&lt;/pre&gt;

上面这种方式我们称之为[lazy loading](http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-lazy-loading)。

# 使用join进行查询

现在我们有了两会在那个彼此关联的数据表了，相比与上一篇教程中的简单查询情况，此时试图对这两张表进行联合查询就更加复杂一些了。关于join技术，读者可以自行阅读[我的前一篇文章](http://www.jianshu.com/p/9e1d3793cba6)。

为了在`User`和`Address`之间构造一个简单的join，我们可以通过`Query.filter()`来连接其相关列（本质是隐式写法的JOIN）。下面是一个简单的例子：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; u, a &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User, Address).\
...                     filter(User.id==Address.user_id).\
...                     filter(Address.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;).\
...                     all():
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(u)
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a)
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;
&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

而实际的SQL JOIN语法，可以通过`Query.join()`来想实现

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; session.query(User).join(Address).\
...         filter(Address.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;).\
...         all()
users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users JOIN addresses ON users.id = addresses.user_id
WHERE addresses.email_address = ?
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;,)
[&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;]`&lt;/pre&gt;

在上面的例子中由于只存在一个ForeignKey，`Query.join`知道如何选取合适的列进行JOIN。如果没有定义ForeignKey，或者存在多个，此时你需要手动指明你参与JOIN的列。`Query.join()`以如下方式进行：

&lt;pre class=&quot;hljs bash&quot;&gt;`query.join(Address, User.id==Address.user_id)    &lt;span class=&quot;hljs-comment&quot;&gt;# explicit condition&lt;/span&gt;
query.join(User.addresses)                       &lt;span class=&quot;hljs-comment&quot;&gt;# specify relationship from left to right&lt;/span&gt;
query.join(Address, User.addresses)              &lt;span class=&quot;hljs-comment&quot;&gt;# same, with explicit target&lt;/span&gt;
query.join(&lt;span class=&quot;hljs-string&quot;&gt;&apos;addresses&apos;&lt;/span&gt;)`&lt;/pre&gt;

对于OUTER JOIN，只需要使用`Query.outerjoin()`就可以了。

&lt;pre class=&quot;hljs bash&quot;&gt;`query.outerjoin(User.addresses)   &lt;span class=&quot;hljs-comment&quot;&gt;# LEFT OUTER JOIN&lt;/span&gt;`&lt;/pre&gt;

关于`join()`更为详细的用法，还是请参考官方的文档[join](http://docs.sqlalchemy.org/en/rel_1_0/orm/query.html#sqlalchemy.orm.query.Query.join)

## 使用Aliases

当你的查询涉及多个表，而其中同一个表出现了多次时，你需要的为重复的表aliase一个新的名字来避免冲突。这个功能其实我们在上一篇文章里面也提到过，下面是关于`aliased`的一个例子：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.orm import aliased
&amp;gt;&amp;gt;&amp;gt; adalias1 = aliased(Address)
&amp;gt;&amp;gt;&amp;gt; adalias2 = aliased(Address)
&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; username, email1, email2 &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; \
...     session.query(User.name, adalias1.email_address, adalias2.email_address).\
...     join(adalias1, User.addresses).\
...     join(adalias2, User.addresses).\
...     filter(adalias1.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;).\
...     filter(adalias2.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(username, email1, email2)
SELECT users.name AS users_name,
        addresses_1.email_address AS addresses_1_email_address,
        addresses_2.email_address AS addresses_2_email_address
FROM users JOIN addresses AS addresses_1
        ON users.id = addresses_1.user_id
JOIN addresses AS addresses_2
        ON users.id = addresses_2.user_id
WHERE addresses_1.email_address = ?
        AND addresses_2.email_address = ?
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)
jack jack@google.com j25@yahoo.com`&lt;/pre&gt;

## 使用子查询(Subqueries)

`Query`适合于用来构造子查询。假如我们想要取出`User`记录，并且同时计算各个用户的`Address`的数量。产生这种功能的SQL指令最好的办法是按照user的id分组统计地址的数量，然后join到外层查询。此时我们需要LEFT JOIN，这样可以使得没有地址的用户也会出现在查询结果中（地址数量为0）。 我们期望的SQL命令是这样的：

&lt;pre class=&quot;hljs sql&quot;&gt;`&lt;span class=&quot;hljs-operator&quot;&gt;SELECT &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;.*, adr_count.address_count &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OUTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;JOIN&lt;/span&gt;
    (SELECT user_id, &lt;span class=&quot;hljs-keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; address_count
        &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; addresses &lt;span class=&quot;hljs-keyword&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; user_id) &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; adr_count
    &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;=adr_count.user_id&lt;/span&gt;`&lt;/pre&gt;

使用`Query`，我们可以从内到外来构造上面的语句。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.sql import func
&amp;gt;&amp;gt;&amp;gt; stmt = session.query(Address.user_id, func.count(&lt;span class=&quot;hljs-string&quot;&gt;&apos;*&apos;&lt;/span&gt;).\
...         label(&lt;span class=&quot;hljs-string&quot;&gt;&apos;address_count&apos;&lt;/span&gt;)).\
...         group_by(Address.user_id).subquery()`&lt;/pre&gt;

`func`我们已经在之前的教程中认识过了。`subquery()`可以产生一个内嵌了alias（是一个`query.statement.alias()`）的查询(SELECT)语句的表达。

当我们生成了statement之后，其完全可以视为一个`Table`来使用。你可以通过`c`来访问它的属性。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; u, count &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User, stmt.c.address_count).\
...     outerjoin(stmt, User.id==stmt.c.user_id).order_by(User.id):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(u, count)
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        anon_1.address_count AS anon_1_address_count
FROM users LEFT OUTER JOIN
    (SELECT addresses.user_id AS user_id, count(?) AS address_count
    FROM addresses GROUP BY addresses.user_id) AS anon_1
    ON users.id = anon_1.user_id
ORDER BY users.id
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;*&apos;&lt;/span&gt;,)
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;ed&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Ed Jones&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;f8s7ccs&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;wendy&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Wendy Williams&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;foobar&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;mary&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Mary Contrary&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;xxg527&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;fred&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Fred Flinstone&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;blah&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;`&lt;/pre&gt;

## 从子查询中取出Entity

在前一个例子中，我们从子查询活着的是一个临时性的JOIN后的表，但是这个表并未定义我们在ORM中定义的Entity。如果我们想将这个临时表映射到ORM中的类呢？此时我们可以使用`aliased`这个函数来完成这个映射。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; stmt = session.query(Address).\
...                 filter(Address.email_address != &lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;).\
...                 subquery()
&amp;gt;&amp;gt;&amp;gt; adalias = aliased(Address, stmt)
&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; user, address &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User, adalias).\
...         join(adalias, User.addresses):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(user)
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(address)
SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            anon_1.id AS anon_1_id,
            anon_1.email_address AS anon_1_email_address,
            anon_1.user_id AS anon_1_user_id
FROM users JOIN
    (SELECT addresses.id AS id,
            addresses.email_address AS email_address,
            addresses.user_id AS user_id
    FROM addresses
    WHERE addresses.email_address != ?) AS anon_1
    ON users.id = anon_1.user_id
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;,)
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;
&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

# 使用EXISTS

EXISTS关键字是一个BOOL型操作符。当查询结果存在至少一行时返回True。EXISTS可以常常和JOIN搭配使用。

下面是一个显式的EXISTS构造方法：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.sql import exists
&amp;gt;&amp;gt;&amp;gt; stmt = exists().where(Address.user_id==User.id)
&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User.name).filter(stmt):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(name)
SELECT users.name AS users_name
FROM users
WHERE EXISTS (SELECT *
FROM addresses
WHERE addresses.user_id = users.id)
()
jack`&lt;/pre&gt;

`Query`还定义了若干个自动使用了EXISTS的操作。上面的例子可以用`any()`来完成：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User.name).\
...         filter(User.addresses.any()):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(name)
SELECT users.name AS users_name
FROM users
WHERE EXISTS (SELECT &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
FROM addresses
WHERE users.id = addresses.user_id)
()
jack`&lt;/pre&gt;

`any()`也接受筛选条件来限制匹配的行：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User.name).\
...     filter(User.addresses.any(Address.email_address.like(&lt;span class=&quot;hljs-string&quot;&gt;&apos;%google%&apos;&lt;/span&gt;))):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(name)
jack`&lt;/pre&gt;

`has()`对于的many-to-one的关系，起到的是和`any()`同样的作用（注意这里`~`表示NOT）：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; session.query(Address).\
...         filter(~Address.user.has(User.name==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;)).all()
[]`&lt;/pre&gt;

## 常用的关系操作

下面只是简单的列出了一些常用的操作。想要更为详细的了解这些功能，还是推荐去官网的相关文档。
</code></pre><ul>
<li><p><strong>eq</strong>() (many-to-one “equals” comparison):</p>
<pre class="hljs swift">`query.<span class="hljs-built_in">filter</span>(<span class="hljs-type">Address</span>.user == someuser)`</pre>
</li>
<li><p><strong>ne</strong>() (many-to-one “not equals” comparison):</p>
<pre class="hljs swift">`query.<span class="hljs-built_in">filter</span>(<span class="hljs-type">Address</span>.user != someuser)`</pre>
</li>
<li><p>IS NULL (many-to-one comparison, also uses <strong>eq</strong>()):</p>
<pre class="hljs python">`query.filter(Address.user == <span class="hljs-keyword">None</span>)`</pre>
</li>
<li><p>contains() (used for one-to-many collections):</p>
<pre class="hljs css">`<span class="hljs-tag">query</span><span class="hljs-class">.filter</span>(<span class="hljs-tag">User</span><span class="hljs-class">.addresses</span><span class="hljs-class">.contains</span>(<span class="hljs-tag">someaddress</span>))`</pre>
</li>
<li><p>any() (used for collections):</p>
<pre class="hljs bash">`query.filter(User.addresses.any(Address.email_address == <span class="hljs-string">'bar'</span>))

<span class="hljs-comment"># also takes keyword arguments:</span>
query.filter(User.addresses.any(email_address=<span class="hljs-string">'bar'</span>))`</pre>
</li>
<li><p>has() (used for scalar references):</p>
<pre class="hljs bash">`query.filter(Address.user.has(name=<span class="hljs-string">'ed'</span>))`</pre>
</li>
<li><p>Query.with_parent() (used for any relationship):</p>
<pre class="hljs bash">`session.query(Address).with_parent(someuser, <span class="hljs-string">'addresses'</span>)`</pre>

<h2 id="Eager-Loading（找不到合适的翻译）"><a href="#Eager-Loading（找不到合适的翻译）" class="headerlink" title="Eager Loading（找不到合适的翻译）"></a>Eager Loading（找不到合适的翻译）</h2><p>前面的教程中我们有提及到lazing loading的机制。当我们通过查询取出用户时，与之关联的地址并没有取出来。当我们试图获取<code>User.addresses</code>时，相关的针对地址的SQL查询才起作用。如果你想要减少query的次数的话，就需要使用Eager Loading了。SQLAlchemy提供了三种Eager Loading的方式，其中两种是自动的，而第三种涉及到自定义的筛选条件。所有的这三种Eager Loading方式都会通过调用<code>Query.options()</code>来影响查询的过程，促使<code>Query</code>生成需要的额外配置来取出期望的内容。</p>
<h1 id="Subquery-Loading"><a href="#Subquery-Loading" class="headerlink" title="Subquery Loading"></a>Subquery Loading</h1><p>在上面的例子中，我们希望在 取出用户的时候就同步取出对应的地址。此时你们可以此采用<code>orm.subqueryload()</code>。这个函数可以发起第二个SELECT查询来取出与结果相关的另一个表的信息。这里取名为”subquery”的原因是，此处的<code>Query</code>在发起第二个查询时作为子查询而被复用了。详细过程参加下面的程序：</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy.orm import subqueryload
&gt;&gt;&gt; jack = session.query(User).\
...                 options(subqueryload(User.addresses)).\
...                 filter_by(name=<span class="hljs-string">'jack'</span>).one()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users
WHERE users.name = ?
(<span class="hljs-string">'jack'</span>,)
SELECT addresses.id AS addresses_id,
        addresses.email_address AS addresses_email_address,
        addresses.user_id AS addresses_user_id,
        anon_1.users_id AS anon_1_users_id
FROM (SELECT users.id AS users_id
    FROM users WHERE users.name = ?) AS anon_1
JOIN addresses ON anon_1.users_id = addresses.user_id
ORDER BY anon_1.users_id, addresses.id
(<span class="hljs-string">'jack'</span>,)
&gt;&gt;&gt; jack
&lt;User(name=<span class="hljs-string">'jack'</span>, fullname=<span class="hljs-string">'Jack Bean'</span>, password=<span class="hljs-string">'gjffdd'</span>)&gt;

&gt;&gt;&gt; jack.addresses
[&lt;Address(email_address=<span class="hljs-string">'jack@google.com'</span>)&gt;, &lt;Address(email_address=<span class="hljs-string">'j25@yahoo.com'</span>)&gt;]`</pre>

<p><strong>注意</strong>：当<code>subqueryload()</code>和涉及limiting的函数一起使用的时候（如<code>Query.first()</code>, <code>Query.limit()</code>, Query.offset()<code>等），应当加上一个以Unique的行作为参数的</code>Query.order_by()`来确保结果的正确性。详情参见<a href="http://docs.sqlalchemy.org/en/rel_1_0/orm/loading_relationships.html#subqueryload-ordering" target="_blank" rel="external">The importance of Ordering</a></p>
<h1 id="Joined-Load"><a href="#Joined-Load" class="headerlink" title="Joined Load"></a>Joined Load</h1><p>这种自动Eager Loading的方式要更为常用一些。Joined Loading发起了一个JOIN（默认是LEFT OUTER JOIN），故而查询结果和制定的与之关联的行可以被同时取出。我们这里以和上面的Subquery Loading中同样的查询目的为例。</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy.orm import joinedload

&gt;&gt;&gt; jack = session.query(User).\
...                        options(joinedload(User.addresses)).\
...                        filter_by(name=<span class="hljs-string">'jack'</span>).one()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        addresses_1.id AS addresses_1_id,
        addresses_1.email_address AS addresses_1_email_address,
        addresses_1.user_id AS addresses_1_user_id
FROM users
    LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id
WHERE users.name = ? ORDER BY addresses_1.id
(<span class="hljs-string">'jack'</span>,)

&gt;&gt;&gt; jack
&lt;User(name=<span class="hljs-string">'jack'</span>, fullname=<span class="hljs-string">'Jack Bean'</span>, password=<span class="hljs-string">'gjffdd'</span>)&gt;

&gt;&gt;&gt; jack.addresses
[&lt;Address(email_address=<span class="hljs-string">'jack@google.com'</span>)&gt;, &lt;Address(email_address=<span class="hljs-string">'j25@yahoo.com'</span>)&gt;]`</pre>

<p>注意到，如果你是在命令行运行了前一个Subquery Loading的例子的话，在这里jack的addresses实际上已经填充了的，但是这里的Joined Load仍然是会发起JOIN。另外，LEFT OUTER JOIN指令实际上有可能导致重复的User出现，但是在结果中实际得到的User却不会重复。这是因为<code>Query</code>实际上是基于Object Identity采用了一种”uniquing”的策略。</p>
<p>历史上来看<code>joinedload()</code>出现的更早一些。<code>joinedloading()</code>更加适合于处理Many-to-one的关系。</p>
<h1 id="显式的Join-EagerLoad"><a href="#显式的Join-EagerLoad" class="headerlink" title="显式的Join + EagerLoad"></a>显式的Join + EagerLoad</h1><p>第三种方式我们是我们自己显式的调用join来定位JOIN连接主键，并接着关联表的信息填充到查询结果中对应对象或者列表中。这个特性需要使用到<code>orm.contains_eager()</code>函数。这个机制最典型的用途是pre-loading many-to-one关系，同时添加对这个关系的筛选。我们用下面的这个例子来阐述说明上面这些比较绕的话。假设我们需要筛选出用户的名字为jack的邮件地址，进行这个查询的方法如下：</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy.orm import contains_eager
&gt;&gt;&gt; jacks_addresses = session.query(Address).\
...                             join(Address.user).\
...                             filter(User.name==<span class="hljs-string">'jack'</span>).\
...                             options(contains_eager(Address.user)).\
...                             all()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        addresses.id AS addresses_id,
        addresses.email_address AS addresses_email_address,
        addresses.user_id AS addresses_user_id
FROM addresses JOIN users ON users.id = addresses.user_id
WHERE users.name = ?
(<span class="hljs-string">'jack'</span>,)

&gt;&gt;&gt; jacks_addresses
[&lt;Address(email_address=<span class="hljs-string">'jack@google.com'</span>)&gt;, &lt;Address(email_address=<span class="hljs-string">'j25@yahoo.com'</span>)&gt;]

&gt;&gt;&gt; jacks_addresses[<span class="hljs-number">0</span>].user
&lt;User(name=<span class="hljs-string">'jack'</span>, fullname=<span class="hljs-string">'Jack Bean'</span>, password=<span class="hljs-string">'gjffdd'</span>)&gt;`</pre>

<h2 id="关系中的删除问题"><a href="#关系中的删除问题" class="headerlink" title="关系中的删除问题"></a>关系中的删除问题</h2><p>沃恩尝试删除jack，来看结果：</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.delete(jack)
&gt;&gt;&gt; session.query(User).filter_by(name=<span class="hljs-string">'jack'</span>).count()
UPDATE addresses SET user_id=? WHERE addresses.id = ?
((None, <span class="hljs-number">1</span>), (None, <span class="hljs-number">2</span>))
DELETE FROM users WHERE users.id = ?
(<span class="hljs-number">5</span>,)
SELECT count(*) AS count_1
FROM (SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users
WHERE users.name = ?) AS anon_1
(<span class="hljs-string">'jack'</span>,)
<span class="hljs-number">0</span>`</pre>

<p>那么与jack关联的地址呢？</p>
<pre class="hljs css">`&gt;&gt;&gt; <span class="hljs-tag">session</span><span class="hljs-class">.query</span>(<span class="hljs-tag">Address</span>)<span class="hljs-class">.filter</span>(
...     <span class="hljs-tag">Address</span><span class="hljs-class">.email_address</span><span class="hljs-class">.in_</span>(<span class="hljs-attr_selector">['jack@google.com', 'j25@yahoo.com']</span>)
...  )<span class="hljs-class">.count</span>()
2`</pre>

<p>地址记录仍然在这里。如果我们commit的话，我们可以从上面的SQL语句中发现，相关的<code>Address</code>的<code>user_id</code>属性被设置成了NULL。这不符合我们的要求。那么我们需要自己来设置关系的删除规则。</p>
<h2 id="配置delete-delete-orphan-Cascade"><a href="#配置delete-delete-orphan-Cascade" class="headerlink" title="配置delete/delete-orphan Cascade"></a>配置delete/delete-orphan Cascade</h2><p>我们通过配置<code>User.addresses</code>关系的<strong>cascade*</strong>选项来控制删除行为。尽管SQLAlchemy允许你在任何时候给ORM添加属性或者关系。此时我们还是需要移除现存的关系并且重新开始（作者：django的ORM包含）。让我们首先关闭当前的session</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.close()`</pre>

<p>并且使用一个新的<code>declarative_base()</code>:</p>
<pre class="hljs bash">`&gt;&gt;&gt; Base = declarative_base()`</pre>

<p>下面我们重新声明<code>User</code>类，注意<code>addresses</code>中的配置：</p>
<pre class="hljs bash">`&gt;&gt;&gt; class User(Base):
...     __tablename__ = <span class="hljs-string">'users'</span>
...
...     id = Column(Integer, primary_key=True)
...     name = Column(String)
...     fullname = Column(String)
...     password = Column(String)
...
...     addresses = relationship(<span class="hljs-string">"Address"</span>, back_populates=<span class="hljs-string">'user'</span>,
...                     cascade=<span class="hljs-string">"all, delete, delete-orphan"</span>)
...
...     def __repr__(self):
...        <span class="hljs-built_in">return</span> <span class="hljs-string">"&lt;User(name='%s', fullname='%s', password='%s')&gt;"</span> % (
...                                self.name, self.fullname, self.password)`</pre>

<p>接下来重新声明<code>Address</code>。</p>
<pre class="hljs bash">`&gt;&gt;&gt; class Address(Base):
...     __tablename__ = <span class="hljs-string">'addresses'</span>
...     id = Column(Integer, primary_key=True)
...     email_address = Column(String, nullable=False)
...     user_id = Column(Integer, ForeignKey(<span class="hljs-string">'users.id'</span>))
...     user = relationship(<span class="hljs-string">"User"</span>, back_populates=<span class="hljs-string">"addresses"</span>)
...
...     def __repr__(self):
...         <span class="hljs-built_in">return</span> <span class="hljs-string">"&lt;Address(email_address='%s')&gt;"</span> % self.email_address`</pre>

<p>现在让我们取出jack(下面我们使用了一个之前没有提到的函数<code>get()</code>，其参数为查询目标的主键)，现在从<code>addresses</code>中删除一个地址的话，会导致这个<code>Address</code>被删除。</p>
<pre class="hljs bash">`<span class="hljs-comment"># load Jack by primary key</span>
SQL&gt;&gt;&gt; jack = session.query(User).get(<span class="hljs-number">5</span>)

<span class="hljs-comment"># remove one Address (lazy load fires off)</span>
SQL&gt;&gt;&gt; del jack.addresses[<span class="hljs-number">1</span>]

<span class="hljs-comment"># only one address remains</span>
SQL&gt;&gt;&gt; session.query(Address).filter(
...     Address.email_address.in_([<span class="hljs-string">'jack@google.com'</span>, <span class="hljs-string">'j25@yahoo.com'</span>])
... ).count()
<span class="hljs-number">1</span>`</pre>

<p>删除jack也会导致剩下jack以及其所有的<code>Address</code>都会被删除:</p>
<pre class="hljs bash">`&gt;&gt; session.delete(jack)

SQL&gt;&gt;&gt; session.query(User).filter_by(name=<span class="hljs-string">'jack'</span>).count()
<span class="hljs-number">0</span>

SQL&gt;&gt;&gt; session.query(Address).filter(
...    Address.email_address.in_([<span class="hljs-string">'jack@google.com'</span>, <span class="hljs-string">'j25@yahoo.com'</span>])
... ).count()
<span class="hljs-number">0</span>`</pre>

<p>关于更多的Cascade配置请参见官方文档。</p>
<h2 id="建立多对多关系ManyToMany-Relationship"><a href="#建立多对多关系ManyToMany-Relationship" class="headerlink" title="建立多对多关系ManyToMany Relationship"></a>建立多对多关系ManyToMany Relationship</h2><p>现在我们需要引入一个新的模型来阐述多对多的关系了。假设我们需要完成一个博客应用。在这个应用里面我们可以书写<code>BlogPost</code>，每个博客都有若干<code>Keyword</code>。</p>
<p>对于一个多对多的关系，我们需要建立一个未映射的（也就是没有一个Python类与之对应的）表<code>Table</code>来作为中间联系的表。</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy import Table, Text
&gt;&gt;&gt; <span class="hljs-comment"># association table</span>
&gt;&gt;&gt; post_keywords = Table(<span class="hljs-string">'post_keywords'</span>, Base.metadata,
...     Column(<span class="hljs-string">'post_id'</span>, ForeignKey(<span class="hljs-string">'posts.id'</span>), primary_key=True),
...     Column(<span class="hljs-string">'keyword_id'</span>, ForeignKey(<span class="hljs-string">'keywords.id'</span>), primary_key=True)
... )`</pre>

<p>不同于我们之前的典型的ORM方法，在上面的代码中我们直接声明了一个<code>Table</code>，而没有制定与之对应的Python类。<code>Table</code>是一个构造函数，其参数中的每个<code>Colomn</code>以逗号分隔。</p>
<p>下面我们来定义<code>BlogPost</code>和<code>Keyword</code>。我们这里需要使用<code>relationship()</code>在这两个类中定义一对互补的关系，其中每个关系的都指向<code>post_keyword</code>这个表。</p>
<pre class="hljs bash">`&gt;&gt;&gt; class B<span class="hljs-built_in">log</span>Post(Base):
...     __tablename__ = <span class="hljs-string">'posts'</span>
...
...     id = Column(Integer, primary_key=True)
...     user_id = Column(Integer, ForeignKey(<span class="hljs-string">'users.id'</span>))
...     headline = Column(String(<span class="hljs-number">255</span>), nullable=False)
...     body = Column(Text)
...
...     <span class="hljs-comment"># many to many BlogPost&lt;-&gt;Keyword</span>
...     keywords = relationship(<span class="hljs-string">'Keyword'</span>,
...                             secondary=post_keywords,
...                             back_populates=<span class="hljs-string">'posts'</span>)
...
...     def __init__(self, headline, body, author):
...         self.author = author
...         self.headline = headline
...         self.body = body
...
...     def __repr__(self):
...         <span class="hljs-built_in">return</span> <span class="hljs-string">"BlogPost(%r, %r, %r)"</span> % (self.headline, self.body, self.author)

&gt;&gt;&gt; class Keyword(Base):
...     __tablename__ = <span class="hljs-string">'keywords'</span>
...
...     id = Column(Integer, primary_key=True)
...     keyword = Column(String(<span class="hljs-number">50</span>), nullable=False, unique=True)
...     posts = relationship(<span class="hljs-string">'BlogPost'</span>,
...                          secondary=post_keywords,
...                          back_populates=<span class="hljs-string">'keywords'</span>)
...
...     def __init__(self, keyword):
...         self.keyword = keyword`</pre>

<p>在上面的定义中，我们可以发现和OneToMany关系不同，<code>relationship()</code>中多了一个<code>secondary</code>的参数，这个参数指向了中间表(原文为associated table)。这个中间表只包含了指向多对多关系两侧的表的主键的列。如果这个表包含了其他属性，甚至是自身的主键，SQLAlchemy需要你使用另一种，称为<code>association object</code>的机制来处理。</p>
<p>我们还希望我们的<code>BlogPost</code>能够拥有一个<code>author</code>属性，这个属性指向我们先前定义的<code>User</code>。此时我们需要再定义一个双向关系。由于一个作者可能拥有很多文章，我们希望访问<code>User.posts</code>的时候可以加以筛选而不是载入全部的相关文章。为此我们在定义<code>User.posts</code>中的时候，设置<code>lazy=&#39;dynamic&#39;</code>，来控制载入策略。</p>
<pre class="hljs bash">`&gt;&gt;&gt; B<span class="hljs-built_in">log</span>Post.author = relationship(User, back_populates=<span class="hljs-string">"posts"</span>)
&gt;&gt;&gt; User.posts = relationship(B<span class="hljs-built_in">log</span>Post, back_populates=<span class="hljs-string">"author"</span>, lazy=<span class="hljs-string">"dynamic"</span>)`</pre>

<p>然后让我们来创建数据库中对应的表</p>
<pre class="hljs bash">`&gt;&gt;&gt; Base.metadata.create_all(engine)
PRAGMA...
CREATE TABLE keywords (
    id INTEGER NOT NULL,
    keyword VARCHAR(<span class="hljs-number">50</span>) NOT NULL,
    PRIMARY KEY (id),
    UNIQUE (keyword)
)
()
COMMIT
CREATE TABLE posts (
    id INTEGER NOT NULL,
    user_id INTEGER,
    headline VARCHAR(<span class="hljs-number">255</span>) NOT NULL,
    body TEXT,
    PRIMARY KEY (id),
    FOREIGN KEY(user_id) REFERENCES users (id)
)
()
COMMIT
CREATE TABLE post_keywords (
    post_id INTEGER NOT NULL,
    keyword_id INTEGER NOT NULL,
    PRIMARY KEY (post_id, keyword_id),
    FOREIGN KEY(post_id) REFERENCES posts (id),
    FOREIGN KEY(keyword_id) REFERENCES keywords (id)
)
()
COMMIT`</pre>

<p>多对多关系的使用方法道也没有太大的不同之处。让我们先来给windy添加博文。</p>
<pre class="hljs bash">`&gt;&gt;&gt; wendy = session.query(User).\
...                 filter_by(name=<span class="hljs-string">'wendy'</span>).\
...                 one()
&gt;&gt;&gt; post = B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">"Wendy's Blog Post"</span>, <span class="hljs-string">"This is a test"</span>, wendy)
&gt;&gt;&gt; session.add(post)`</pre>

<p>给博文添加一些关键字。目前数据库里面还没有关键字存在，我们创建一些：</p>
<pre class="hljs bash">`&gt;&gt;&gt; post.keywords.append(Keyword(<span class="hljs-string">'wendy'</span>))
&gt;&gt;&gt; post.keywords.append(Keyword(<span class="hljs-string">'firstpost'</span>))`</pre>

<p>我们可以开始查询了。先以’firstpost’为关键字来检索所有的博文。我们使用<code>any</code>来查询拥有关键词’firstpost’的博文：</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(B<span class="hljs-built_in">log</span>Post).\
...             filter(B<span class="hljs-built_in">log</span>Post.keywords.any(keyword=<span class="hljs-string">'firstpost'</span>)).\
...             all()
[B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">"Wendy's Blog Post"</span>, <span class="hljs-string">'This is a test'</span>, &lt;User(name=<span class="hljs-string">'wendy'</span>, fullname=<span class="hljs-string">'Wendy Williams'</span>, password=<span class="hljs-string">'foobar'</span>)&gt;)]`</pre>

<p>如果我们希望将查询范围限制在wendy用户所拥有的博文之内，</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(B<span class="hljs-built_in">log</span>Post).\
...             filter(B<span class="hljs-built_in">log</span>Post.author==wendy).\
...             filter(B<span class="hljs-built_in">log</span>Post.keywords.any(keyword=<span class="hljs-string">'firstpost'</span>)).\
...             all()
SELECT posts.id AS posts_id,
        posts.user_id AS posts_user_id,
        posts.headline AS posts_headline,
        posts.body AS posts_body
FROM posts
WHERE ? = posts.user_id AND (EXISTS (SELECT <span class="hljs-number">1</span>
    FROM post_keywords, keywords
    WHERE posts.id = post_keywords.post_id
        AND keywords.id = post_keywords.keyword_id
        AND keywords.keyword = ?))
(<span class="hljs-number">2</span>, <span class="hljs-string">'firstpost'</span>)
[B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">"Wendy's Blog Post"</span>, <span class="hljs-string">'This is a test'</span>, &lt;User(name=<span class="hljs-string">'wendy'</span>, fullname=<span class="hljs-string">'Wendy Williams'</span>, password=<span class="hljs-string">'foobar'</span>)&gt;)]`</pre>

<p>或者我们可以直接在wendy的<code>posts</code>属性上进行查询：</p>
<p><pre class="hljs bash">`&gt;&gt;&gt; wendy.posts.\<br>…         filter(B<span class="hljs-built_in">log</span>Post.keywords.any(keyword=<span class="hljs-string">‘firstpost’</span>)).\<br>…         all()<br>[B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">“Wendy’s Blog Post”</span>, <span class="hljs-string">‘This is a test’</span>, &lt;User(name=<span class="hljs-string">‘wendy’</span>, fullname=<span class="hljs-string">‘Wendy Williams’</span>, password=<span class="hljs-string">‘foobar’</span>)&gt;)]</pre></p>
</li>
</ul>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;『关系』是关系型数据库的一大特色，也是我们在建模过程中的一个重要的抽象过程。在前面的两个教程中，我们分别回顾了使用SQLAlchemy在数据
    
    </summary>
    
      <category term="Python" scheme="http://kidozh.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidozh.com/tags/Python/"/>
    
      <category term="sqlalchemy" scheme="http://kidozh.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy查询</title>
    <link href="http://kidozh.com/2016/11/05/sqlalchemy-e6-9f-a5-e8-af-a2/"/>
    <id>http://kidozh.com/2016/11/05/sqlalchemy-e6-9f-a5-e8-af-a2/</id>
    <published>2016-11-04T20:15:08.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>和Django一样，我们orm也要知道如何查询数据。</p>
<h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><p><code>Session</code>的<code>query</code>函数会返回一个<code>Query</code>对象。<code>query</code>函数可以接受多种参数类型。可以是类，或者是类的instrumented <strong>descriptor</strong>。下面的这个例子取出了所有的<code>User</code>记录。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for instance in session.query(User).order_by(User.id):
...     print(instance.name, instance.fullname)
ed Ed Jones
wendy Wendy Williams
mary Mary Contrary
fred Fred Flinstone</pre>

<p><code>Query</code>也接受ORM-instrumented descriptors作为参数。当多个参数传入时，返回结果为以同样顺序排列的tuples</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for name, fullname in session.query(User.name, User.fullname):
...     print(name, fullname)
ed Ed Jones
wendy Wendy Williams
mary Mary Contrary
fred Fred Flinstone</pre>

<p><code>Query</code>返回的tuples由<code>KeyedTuple</code>这个类提供，其成员除了用下标访问意外，还可以视为实例变量来获取。对应的变量的名称与被查询的类变量名称一样，如下例：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for row in session.query(User, User.name).all():
...    print(row.User, row.name)
&lt;User(name='ed', fullname='Ed Jones', password='f8s7ccs')&gt; ed
&lt;User(name='wendy', fullname='Wendy Williams', password='foobar')&gt; wendy
&lt;User(name='mary', fullname='Mary Contrary', password='xxg527')&gt; mary
&lt;User(name='fred', fullname='Fred Flinstone', password='blah')&gt; fred</pre>

<p>你可以通过<code>label()</code>来制定descriptor对应实例变量的名称</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for row in session.query(User.name.label('name_label')).all():
...    print(row.name_label)
ed
wendy
mary
fred</pre>

<p>而对于类参数而言，要实现同样的定制需要使用<code>aliased</code></p>
<pre class="lang:python decode:true">&gt;&gt;&gt; from sqlalchemy.orm import aliased
&gt;&gt;&gt; user_alias = aliased(User, name='user_alias')

SQL&gt;&gt;&gt; for row in session.query(user_alias, user_alias.name).all():
...    print(row.user_alias)
&lt;User(name='ed', fullname='Ed Jones', password='f8s7ccs')&gt;
&lt;User(name='wendy', fullname='Wendy Williams', password='foobar')&gt;
&lt;User(name='mary', fullname='Mary Contrary', password='xxg527')&gt;
&lt;User(name='fred', fullname='Fred Flinstone', password='blah')&gt;</pre>

<p>基本的查询操作除了上面这些之外，还包括OFFSET和LIMIT，这个可以通过Python的array slice来完成。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for u in session.query(User).order_by(User.id)[1:3]:
...    print(u)
&lt;User(name='wendy', fullname='Wendy Williams', password='foobar')&gt;
&lt;User(name='mary', fullname='Mary Contrary', password='xxg527')&gt;</pre>

<p>上述过程实际上只涉及了整体取出的操作，而没有进行筛选，筛选常用的函数是<code>filter_by</code>和<code>filter</code>。其中后者比起前者要更灵活一些，你可以在后者的参数中使用python的运算符。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for name, in session.query(User.name).\
...             filter_by(fullname='Ed Jones'):
...    print(name)
ed
&gt;&gt;&gt; for name, in session.query(User.name).\
...             filter(User.fullname=='Ed Jones'):
...    print(name)
ed</pre>

<p>注意<code>Query</code>对象是<strong>generative</strong>的，这意味你可以把他们串接起来调用，如下：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for user in session.query(User).\
...          filter(User.name=='ed').\
...          filter(User.fullname=='Ed Jones'):
...    print(user)
&lt;User(name='ed', fullname='Ed Jones', password='f8s7ccs')&gt;</pre>

<p>串接的<code>filter</code>之间是<strong>与</strong>的关系。</p>
<h1 id="常用的filter操作符"><a href="#常用的filter操作符" class="headerlink" title="常用的filter操作符"></a>常用的filter操作符</h1><p>下面的这些操作符可以应用在<code>filter</code>函数中</p>
<ul>
<li><p><code>equals</code>:</p>
<p>query.filter(User.name == <span class="hljs-string">‘ed’</span>)`</p>
</li>
<li><p><code>not equals</code>:</p>
<pre class="hljs bash">`query.filter(User.name != <span class="hljs-string">'ed'</span>)`</pre></li>
<li><p><code>LIKE</code>:</p>
<pre class="hljs bash">`query.filter(User.name.like(<span class="hljs-string">'%ed%'</span>))`</pre></li>
<li><p><code>IN</code>:</p>
<pre class="hljs bash">`query.filter(User.name.in_([<span class="hljs-string">'ed'</span>, <span class="hljs-string">'wendy'</span>, <span class="hljs-string">'jack'</span>]))

<span class="hljs-comment"># works with query objects too:</span>
query.filter(User.name.in_(
        session.query(User.name).filter(User.name.like(<span class="hljs-string">'%ed%'</span>))
))`</pre>
</li>
<li><p><code>NOT IN</code>:</p>
<pre class="hljs bash">`query.filter(~User.name.in_([<span class="hljs-string">'ed'</span>, <span class="hljs-string">'wendy'</span>, <span class="hljs-string">'jack'</span>]))`</pre>
</li>
<li><p><code>IS NULL</code>:</p>
<pre class="hljs bash">`query.filter(User.name == None)

<span class="hljs-comment"># alternatively, if pep8/linters are a concern</span>
query.filter(User.name.is_(None))`</pre>
</li>
<li><p><code>IS NOT NULL</code>:</p>
<pre class="hljs bash">`query.filter(User.name != None)

<span class="hljs-comment"># alternatively, if pep8/linters are a concern</span>
query.filter(User.name.isnot(None))`</pre>
</li>
<li><p><code>AND</code>:</p>
<pre class="hljs bash">`<span class="hljs-comment"># use and_()</span>
from sqlalchemy import and_
query.filter(and_(User.name == <span class="hljs-string">'ed'</span>, User.fullname == <span class="hljs-string">'Ed Jones'</span>))

<span class="hljs-comment"># or send multiple expressions to .filter()</span>
query.filter(User.name == <span class="hljs-string">'ed'</span>, User.fullname == <span class="hljs-string">'Ed Jones'</span>)

<span class="hljs-comment"># or chain multiple filter()/filter_by() calls</span>
query.filter(User.name == <span class="hljs-string">'ed'</span>).filter(User.fullname == <span class="hljs-string">'Ed Jones'</span>)`</pre>
</li>
<li><p><code>OR</code>:</p>
<pre class="hljs bash">`from sqlalchemy import or_
query.filter(or_(User.name == <span class="hljs-string">'ed'</span>, User.name == <span class="hljs-string">'wendy'</span>))`</pre>
</li>
<li><p><code>MATCH</code>:</p>
<pre class="hljs bash">`query.filter(User.name.match(<span class="hljs-string">'wendy'</span>))`</pre>

<h1 id="返回列表-List-和单项-Scalar"><a href="#返回列表-List-和单项-Scalar" class="headerlink" title="返回列表(List)和单项(Scalar)"></a>返回列表(List)和单项(Scalar)</h1><p>很多<code>Query</code>的方法执行了SQL命令并返回了取出的数据库结果。</p>
</li>
<li><p><code>all()</code>返回一个列表:</p>
<pre class="hljs bash">`&gt;&gt;&gt; query = session.query(User).filter(User.name.like(<span class="hljs-string">'%ed'</span>)).order_by(User.id)
SQL&gt;&gt;&gt; query.all()
[&lt;User(name=<span class="hljs-string">'ed'</span>, fullname=<span class="hljs-string">'Ed Jones'</span>, password=<span class="hljs-string">'f8s7ccs'</span>)&gt;,
    &lt;User(name=<span class="hljs-string">'fred'</span>, fullname=<span class="hljs-string">'Fred Flinstone'</span>, password=<span class="hljs-string">'blah'</span>)&gt;]`</pre></li>
<li><p><code>first()</code>返回至多一个结果，而且以单项形式，而不是只有一个元素的tuple形式返回这个结果.</p>
<pre class="hljs bash">`&gt;&gt;&gt; query.first()
&lt;User(name=<span class="hljs-string">'ed'</span>, fullname=<span class="hljs-string">'Ed Jones'</span>, password=<span class="hljs-string">'f8s7ccs'</span>)&gt;`</pre>
</li>
<li><p><code>one()</code>返回且仅返回一个查询结果。当结果的数量不足一个或者多于一个时会报错。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; user = query.one()
Traceback (most recent call last):
...
MultipleResultsFound: Multiple rows were found for one()</pre>

<p>没有查找到结果时：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; user = query.filter(User.id == 99).one()
Traceback (most recent call last):
...
NoResultFound: No row was found for one()</pre>
</li>
<li><p><code>one_or_none()</code>：从名称可以看出，当结果数量为0时返回<code>None</code>， 多于1个时报错</p>
</li>
<li><p><code>scalar()</code>和<code>one()</code>类似，但是返回单项而不是tuple</p>
<h1 id="嵌入使用SQL"><a href="#嵌入使用SQL" class="headerlink" title="嵌入使用SQL"></a>嵌入使用SQL</h1><p>你可以在<code>Query</code>中通过<code>text()</code>使用SQL语句。例如：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; from sqlalchemy import text
&gt;&gt;&gt; for user in session.query(User).\
...             filter(text("id&lt;224")).\
...             order_by(text("id")).all():
...     print(user.name)
ed
wendy
mary
fred</pre>

<p>除了上面这种直接将参数写进字符串的方式外，你还可以通过<code>params()</code>方法来传递参数</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; session.query(User).filter(text("id&lt;:value and name=:name")).\
...     params(value=224, name='fred').order_by(User.id).one()
&lt;User(name='fred', fullname='Fred Flinstone', password='blah')&gt;</pre>

<p>并且，你可以直接使用完整的SQL语句，但是要注意将表名和列明写正确。</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(User).from_statement(
...                     text(<span class="hljs-string">"SELECT * FROM users where name=:name"</span>)).\
...                     params(name=<span class="hljs-string">'ed'</span>).all()
[&lt;User(name=<span class="hljs-string">'ed'</span>, fullname=<span class="hljs-string">'Ed Jones'</span>, password=<span class="hljs-string">'f8s7ccs'</span>)&gt;]`</pre>

<h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><p><code>Query</code>定义了一个很方便的计数函数<code>count()</code></p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(User).filter(User.name.like(<span class="hljs-string">'%ed'</span>)).count()
SELECT count(*) AS count_1
FROM (SELECT users.id AS users_id,
                users.name AS users_name,
                users.fullname AS users_fullname,
                users.password AS users_password
FROM users
WHERE users.name LIKE ?) AS anon_1
(<span class="hljs-string">'%ed'</span>,)
<span class="hljs-number">2</span>`</pre>

<p>注意上面我们同时列出了实际的SQL指令。在SQLAlchemy中，我们总是将被计数的查询打包成一个子查询，然后对这个子查询进行计数。即便是最简单的<code>SELECT count(*) FROM table</code>，也会如此处理。为了更精细的控制计数过程，我们可以采用<code>func.count()</code>这个函数。</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy import func
SQL&gt;&gt;&gt; session.query(func.count(User.name), User.name).group_by(User.name).all()
SELECT count(users.name) AS count_1, users.name AS users_name
FROM users GROUP BY users.name
()
[(<span class="hljs-number">1</span>, u<span class="hljs-string">'ed'</span>), (<span class="hljs-number">1</span>, u<span class="hljs-string">'fred'</span>), (<span class="hljs-number">1</span>, u<span class="hljs-string">'mary'</span>), (<span class="hljs-number">1</span>, u<span class="hljs-string">'wendy'</span>)]`</pre>

<p>为了实现最简单的<code>SELECT count(*) FROM table</code>，我们可以如下调用</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(func.count(<span class="hljs-string">'*'</span>)).select_from(User).scalar()
SELECT count(?) AS count_1
FROM users
(<span class="hljs-string">'*'</span>,)
<span class="hljs-number">4</span>`</pre>

<p>如果我们对<code>User</code>的主键进行计数，那么<code>select_from</code>也可以省略。</p>
<p><pre class="hljs bash">`&gt;&gt;&gt; session.query(func.count(User.id)).scalar()<br>SELECT count(users.id) AS count_1<br>FROM users<br>()<br><span class="hljs-number">4</span></pre></p>
</li>
</ul>
<p>在下一篇教程里面我们将会介绍SQLAlchemy对于『关系』的处理方式，以及针对关系的更加复杂的查询。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;和Django一样，我们orm也要知道如何查询数据。&lt;/p&gt;
&lt;h1 id=&quot;Query&quot;&gt;&lt;a href=&quot;#Query&quot; class=&quot;
    
    </summary>
    
      <category term="Python" scheme="http://kidozh.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidozh.com/tags/Python/"/>
    
      <category term="sqlalchemy" scheme="http://kidozh.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy介绍</title>
    <link href="http://kidozh.com/2016/11/05/sqlalchemy-e4-bb-8b-e7-bb-8d/"/>
    <id>http://kidozh.com/2016/11/05/sqlalchemy-e4-bb-8b-e7-bb-8d/</id>
    <published>2016-11-04T17:33:34.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直忙着开发<a href="http://lab.npuacm.info" target="_blank" rel="external">lab.npuacm.info</a>，因为更换了Python的框架（Django -&gt; Tornado），所以对于数据库而言，我需要一个ORM来防止手残的我存储数据。</p>
<p>所以我选择了SQLAlchemy。</p>
<h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><p>所谓ORM（Object Relational Mapping），就是建立其由Python类到数据库表的映射关系：一个Python实例(<em>instance</em>)对应数据库中的一行(<em>row</em>)。这种映射包含两层含义，一是实现对象和与之关联的的行的状态同步，二是将涉及数据库的查询操作，表达为Python类的相互关系。</p>
<p>注意ORM和SQLAlchemy的Expression Language不同。后者可以视为对原始SQL的封装。ORM是基于Expression Language而构建的，其抽象层次要高于Expression Language。很多时候我们都是使用ORM，有时需要一些高度定制化的功能时，就需要使用到Expression Language。</p>
<h1 id="版本检查"><a href="#版本检查" class="headerlink" title="版本检查"></a>版本检查</h1><p>你可以这样检查SQLAlchemy的版本信息</p>
<pre class="lang:python decode:true ">import sqlalchemy
sqlalchemy.__version__

'1.1.2'</pre>

<h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>在这个教程中我们使用in-memory的SQLite数据库，你也可以根据自己的需要配置对应的数据库设置。为了建立同数据库的链接，我们需要使用到<code>create_engine</code></p>
<pre class="lang:python decode:true ">&gt;&gt;&gt; from sqlalchemy import create_engine
&gt;&gt;&gt; engine = create_engine('sqlite:///:memory:', echo=True)</pre>

<p>这里的<code>echo</code>设置为True可以使得后面我们可以在控制台看到操作涉及的SQL语言。如果你觉得麻烦，可以将其设置为False。我们这里就不贴出了。</p>
<p><code>create_engine</code>返回的是一个<code>Engine</code>实例，它代表了指向数据库的一些非常核心的接口。他会根据你选择的数据库配置而调用对应的<code>DBAPI</code>。</p>
<p>当第一次如<code>Engine.execute()</code>或者<code>Engine.connect()</code>的方法被调用时，<code>Engine</code>才会真正的建立起到数据库的<code>DBAPI</code>连接。实际上，我们一般并不会直接使用<code>Engine</code>。</p>
<h1 id="Declaring-a-Mapping"><a href="#Declaring-a-Mapping" class="headerlink" title="Declaring a Mapping"></a>Declaring a Mapping</h1><p>当我们使用ORM的时候，其配置过程主要分为两个部分：一是描述我们要处理的数据库表的信息，二是将我们的Python类映射到这些表上。这两个过程在SQLAlchemy中是一起完成的，我们将这个过程称之为<strong>Declarative</strong>。</p>
<p>使用Declarative参与ORM映射的类需要被定义成为一个指定基类的子类，这个基类应当含有ORM映射中相关的类和表的信息。这样的基类我们称之为<strong>declarative base class</strong>。在我们的应用中，我们一般只需要一个这样的基类。这个基类我们可以通过<code>declarative_base</code>来创建</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; from sqlalchemy.ext.declarative import declarative_base

&gt;&gt;&gt; Base = declarative_base()</pre>

<p>现在我们已经有了一个基类，我们可以基于这个基类来创建我们的自定义类了。我们以建立一个用户类为例子。从<code>Base</code>派生一个名为<code>User</code>的类，在这个类里面我们可以定义将要映射到数据库的表上的属性（主要是表的名字，列的类型和名称等）：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; from sqlalchemy import Column, Integer, String
&gt;&gt;&gt; class User(Base):
...     __tablename__ = 'users'
...
...     id = Column(Integer, primary_key=True)
...     name = Column(String)
...     fullname = Column(String)
...     password = Column(String)
...
...     def __repr__(self):
...        return "&lt;User(name='%s', fullname='%s', password='%s')&gt;" % (
...                             self.name, self.fullname, self.password)</pre>

<p>通过Declarative生成的类至少应该包含一个名为<strong>tablename</strong>的属性来给出目标表的名称，以及至少一个<code>Column</code>来给出表的主键(Primary Key)。SQLAlchemy不会对于类名和表名之间的关联做任何假设，也不会自动涉及数据类型以及约束的转换。一般的你可以自己创建一个模板来建立这些自动转换，这样可以减少你的很多重复劳动。</p>
<p>当我们的类声明完成后，Declarative将会将所有的<code>Column</code>成员替换成为特殊的Python访问器(accessors)，我们称之为<strong>descriptors</strong>。这个过程我们称为<strong>instrumentation</strong>，经过instrumentation的映射类可以让我们能够读写数据库的表和列。</p>
<p>注意除了这些涉及ORM的映射意外，这些mapping类的其他部分仍然是不变的。</p>
<h1 id="Create-a-schema"><a href="#Create-a-schema" class="headerlink" title="Create a schema"></a>Create a schema</h1><p>我们通过Declarative系统构建好我们的<code>User</code>类之后，与之同时的关于表的信息也已经创建好了，我们称之为<strong>table metadata</strong>。描述这些信息的类为<code>Table</code>。我们可以通过<code>__table__</code>这个类变量来查看表信息</p>
<pre class="lang:default decode:true">&gt;&gt;&gt; User.__table__ 
Table('users', MetaData(bind=None),
            Column('id', Integer(), table=&lt;users&gt;, primary_key=True, nullable=False),
            Column('name', String(), table=&lt;users&gt;),
            Column('fullname', String(), table=&lt;users&gt;),
            Column('password', String(), table=&lt;users&gt;), schema=None)</pre>

<p>当我们完成类声明时，Declarative用一个Python的metaclass来为这个类进行了加工。在这个阶段，它依据我们给出的设置创建了<code>Table</code>对象，然后构造一个<code>Mapper</code>对象来与之关联。这些幕后的对象我们大多都不需要直接与之打交道。</p>
<p><code>Table</code>对象是一个更大家庭—-我们称之为<code>MetaData</code>—-的一部分。当我们使用Declarative时，这个对象也可以在Declarative base class的<code>.metadata</code>属性中看到。</p>
<p><code>MetaData</code>是我们与数据库打交道的一个接口。对于我们的SQLite数据库而言，此时还没有一个名为<code>users</code>的表的存在，我们需要使用<code>MetaData</code>来发出<code>CREATE TABLE</code>的命令。下面我们使用<code>MetaData.create_all()</code>指令，将我们上面得到的<code>Engine</code>作为参数传入。如果你上面设置了echo为True的话，应该可以看到这一过程中的SQL指令。首先检查了<code>users</code>表的存在性，如果不存在的话会执行表的创建工作。</p>
<pre class="lang:default decode:true">&gt;&gt;&gt; Base.metadata.create_all(engine)
SELECT ...
PRAGMA table_info("users")
()
CREATE TABLE users (
    id INTEGER NOT NULL, name VARCHAR,
    fullname VARCHAR,
    password VARCHAR,
    PRIMARY KEY (id)
)
()
COMMIT</pre>

<h1 id="Create-an-Instance-of-the-Mapped-Class"><a href="#Create-an-Instance-of-the-Mapped-Class" class="headerlink" title="Create an Instance of the Mapped Class"></a>Create an Instance of the Mapped Class</h1><p>创建<code>User</code>对象十分简单</p>
<pre class="lang:default decode:true">&gt;&gt;&gt; ed_user = User(name='ed', fullname='Ed Jones', password='edspassword')
&gt;&gt;&gt; ed_user.name
'ed'
&gt;&gt;&gt; ed_user.password
'edspassword'
&gt;&gt;&gt; str(ed_user.id)
'None'</pre>

<h1 id="Create-a-Session"><a href="#Create-a-Session" class="headerlink" title="Create a Session"></a>Create a Session</h1><p>Session是一个非常重要的概念，类似于iOS中的NSManagedContext的概念，我也在尝试进一步去理解它。</p>
<p>我们现在可以和数据库对话了。ORM对数据库的入口即是<code>Session</code>，当我们构建应用时，和<code>create_engine</code>的同一级别下，我们定义一个<code>Session</code>类来作为生成新的Session的Factory类</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; from sqlalchemy.orm import sessionmaker
&gt;&gt;&gt; Session = sessionmaker(bind=engine)</pre>

<p>当你试图在定义<code>Engine</code>之前定义<code>Sesssion</code>的话，这里的<code>bind</code>可以不设置</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; Session = sessionmaker()</pre>

<p>后续你定义好<code>Engine</code>后可以通过<code>configure()</code>来将其连接到<code>Session</code></p>
<pre class="lang:python decode:true">&gt;&gt;&gt; Session.configure(bind=engine)  # once engine is available</pre>

<p>这个我们自定义的工厂类就可以拿来我们构造新的<code>Session</code>了。</p>
<pre class="lang:python decode:true">session = Session()</pre>

<p>上面的<code>Session</code>已经和我们的<code>SQLite</code>的数据库的<code>Engine</code>关联起来了，但是我们可以发现它还没有打开任何到数据库的连接(connection)。当一个<code>Session</code>被首次使用时，它会从<code>Engine</code>所维护的连接池中取出一个连接来操作数据库。这个连接在我们应用有所更改或者关闭<code>Session</code>时会被释放。</p>
<h1 id="Adding-and-Update-Objects"><a href="#Adding-and-Update-Objects" class="headerlink" title="Adding and Update Objects"></a>Adding and Update Objects</h1><p>为了将<code>User</code>对象存入数据库，我们调用<code>Sesson</code>的<code>add()</code>函数</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; ed_user = User(name='ed', fullname='Ed Jones', password='edspassword')
&gt;&gt;&gt; session.add(ed_user)</pre>

<p>当这个操作完成之后，我们成这个<code>User</code>实例的状态为<strong>pending</strong>。目前实际上还没有执行SQL操作，也就是说数据库中还没有产生和这个<code>User</code>实例对应的行。<code>Session</code>将会在需要的时候执行相应的SQL命令，这个过程我们称之为<strong>flush</strong>。如果我们试图查询<code>Ed Jones</code>，所有处于<code>pending</code>状态的信息将会首先被<strong>flush</strong>，然后负责进行查询的SQL语言在此之后立即被执行。</p>
<p>例如，我们创建一个查询来获取刚刚我们创建的用户（涉及查询的部分我们后续会详细介绍）。这个查询会返回一个和我们之前添加的用户相同的用户实例。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; our_user = session.query(User).filter_by(name='ed').first() BEGIN (implicit)
INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
('ed', 'Ed Jones', 'edspassword')
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users
WHERE users.name = ?
 LIMIT ? OFFSET ?
('ed', 1, 0)
&gt;&gt;&gt; our_user
&lt;User(name='ed', fullname='Ed Jones', password='edspassword')&gt;</pre>

<p>事实上这里的<code>Session</code>判断出来了需要返回的行和已经存在内存中的一个映射实例应当是同一个，所以我们会得到一个和之前完全相同的实例</p>
<pre class="lang:python decode:true ">&gt;&gt;&gt; ed_user is our_user
True</pre>

<p>这里ORM所表现的理念，我们称之为<a href="http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-identity-map" target="_blank" rel="external">identity map</a>。这个设计理念保证了在一个<code>Session</code>对于一个制定行的操作，作用于同一个内存实例上。当一个拥有特定主键的对象出现在<code>Session</code>中时，所有的查询操作对这个主键都会返回一个相同的Python对象。并且，如果你试图引入重复了主键的新的对象时，系统会产生一个错误来阻止你的操作。</p>
<p>我们可以通过<code>add_all()</code>来一次加入多个对象</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; session.add_all([
...     User(name='wendy', fullname='Wendy Williams', password='foobar'),
...     User(name='mary', fullname='Mary Contrary', password='xxg527'),
...     User(name='fred', fullname='Fred Flinstone', password='blah')])</pre>

<p>并且，如果我们希望改变Ed的密码，可以直接修改之：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; ed_user.password = 'f8s7ccs'</pre>

<p>这个修改会被<code>Session</code>记录下来</p>
<pre><code>&amp;gt;&amp;gt;&amp;gt; session.dirty
IdentitySet([&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;ed&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Ed Jones&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;f8s7ccs&apos;&lt;/span&gt;)&amp;gt;])
</code></pre><p>当然，上面的插入操作也被记录了</p>
<pre class="lang:python decode:true ">&gt;&gt;&gt; session.new 
IdentitySet([&lt;User(name='wendy', fullname='Wendy Williams', password='foobar')&gt;,
&lt;User(name='mary', fullname='Mary Contrary', password='xxg527')&gt;,
&lt;User(name='fred', fullname='Fred Flinstone', password='blah')&gt;])</pre>

<p>&nbsp;</p>
<p>我们可以使用<code>commit()</code>命令来将这些更改<strong>flush</strong>到数据库中。</p>
<pre class="lang:python decode:true ">&gt;&gt;&gt; session.commit()</pre>

<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近一直忙着开发&lt;a href=&quot;http://lab.npuacm.info&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
      <category term="Python" scheme="http://kidozh.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidozh.com/tags/Python/"/>
    
      <category term="sqlalchemy" scheme="http://kidozh.com/tags/sqlalchemy/"/>
    
      <category term="数据库" scheme="http://kidozh.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>WordPress主题模板和目录结构</title>
    <link href="http://kidozh.com/2016/11/03/wordpress-e4-b8-bb-e9-a2-98-e6-a8-a1-e6-9d-bf-e5-92-8c-e7-9b-ae-e5-bd-95-e7-bb-93-e6-9e-84/"/>
    <id>http://kidozh.com/2016/11/03/wordpress-e4-b8-bb-e9-a2-98-e6-a8-a1-e6-9d-bf-e5-92-8c-e7-9b-ae-e5-bd-95-e7-bb-93-e6-9e-84/</id>
    <published>2016-11-02T23:29:30.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于WordPress而言，WordPress主题可能只需要一个<code>index.php</code>模板和一个<code>style.css</code>的文件。但是大多数的WordPress主题还是需要一些更为坚实的东西。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>让我们创建一些文件和目录来装饰我们基于<code>_s</code>的主题，shape。</p>
<p>在wp-content/themes/目录下创建你的主题，在这个指南中，我们称之为shape。当然，这也可以是你想要的任何文件，接下来我们将会创建下面的空白文件和文件夹。</p>
<ul>
<li>inc (folder)</li>
<li>js (folder)</li>
<li>languages (folder)</li>
<li>layouts (folder)</li>
<li>404.php</li>
<li>archive.php</li>
<li>comments.php</li>
<li>content.php</li>
<li>content-aside.php</li>
<li>content-page.php</li>
<li>content-single.php</li>
<li>footer.php</li>
<li>functions.php</li>
<li>header.php</li>
<li>index.php</li>
<li>no-results.php</li>
<li>page.php</li>
<li>search.php</li>
<li>searchform.php</li>
<li>sidebar.php</li>
<li>single.php</li>
<li>license.txt</li>
<li>rtl.css</li>
<li>style.css</li>
</ul>
<p>现在让我们在文本编辑器里打开我们创建的最后的文件<code>style.css</code>。我们需要做的第一件事情就是在CSS文件的头几行内加入CSS注释（以<code>/* */</code>开头和结尾）。在这里，我们将会把一些信息写入CSS文件中，这些信息将会告知WordPress你的主题。没有这个，你的主题将不会在主题栏之中显示。</p>
<p>我将会使用Shape作为主题名称，但是你想用啥名字都无所谓。同时，你需要填入author（作者），URLs（地址栏）和你的主题的说明信息。</p>
<pre class="lang:css decode:true ">/*
Theme Name: Shape
Theme URI: https://themeshaper.com/
Author: ThemeShaper
Author URI: https://themeshaper.com/
Description: The Shape theme is a simple, minimalist theme based on Underscores and the original Shape Theme by Ian Stewart. It was created especially as a learning theme for The ThemeShaper WordPress Theme Tutorial: 2nd Edition.
Version: 2.0
License: GNU General Public License
License URI: license.txt
Tags: light, white, one-column, two-columns, left-sidebar, right-sidebar, flexible-width, custom-backgroud, custom-header, custom-menu, featured-images, flexible-header, microformats, post-formats, rtl-language-support, threaded-comments, translation-ready
This theme, like WordPress, is licensed under the GPL.
Use it to make something cool, have fun, and share what you've learned with others.
*/</pre>

<p>让我们挨个看这些元素，这样你就会知道他们在说什么了。</p>
<ul>
<li>Theme Name - 你的主题名称</li>
<li>Theme URL - 你主题主页在网络中的地址。这可以是你网站的某一部分。举个例子，许多的主题作者都可能使用类似于这样的地址：<a href="http://yourgroovydomain.com/your-theme/&amp;#8221" target="_blank" rel="external">http://yourgroovydomain.com/your-theme/&amp;#8221</a></li>
<li>Author - 自我说明，当然也就是你的名字咯</li>
<li>Author URL - 连接到你的网站</li>
<li>Description - 提供一个你主题的简短而清晰的说明，你可以用几句话总结你创建主题的目的以及主题的特性。当用户搜索主题的时候，这个说明将会出现在用户的仪表盘（Dashboard）之中，当然也有可能出现在WordPress.org免费主题库之中</li>
<li>Version - 你主题的版本号。这取决于你是如何对你的版本进行编号，倘若主题是全新的，你也可以从1.0开始命名主题版本号。如果你已经释出了更新，你就能够相应的更改版本号。</li>
<li>License - 你的主题协议。如果你想发布你的主题，你就必须要使用GPL协议了，这也正是WordPress使用的。</li>
<li>License URL - 提供一个用户能找到协议文本的链接。我们的主题将会包含一个<code>license.txt</code>文件，这个文件我们将会在如何分发WordPress主题那一节上提到</li>
<li>Tags - 这些文字（标签）将会描述你主题的特性，颜色和主题。如果你想分发你的主题的话，他们就是必要的。这些标签允许人们去按照颜色主题等来检索主题。<a href="http://wordpress.org/extend/themes/about/" target="_blank" rel="external">这里是一些支持的标签</a>。</li>
</ul>
<p>需要注意的事情：这些东西很多都是可选的。事实上，你只需要主题名称就够了。但是一旦你计划要发布你的主题或者你想为某个人做一个自定义的注意的话，你就需要包含上面的东西了。最后，我希望你不要对这些琐事感到一头雾水。</p>
<p>一旦你做到这些之后，你就可以激活你的注意并且访问你的测试站点了。我们已经完成了我们的空主题了。事情将会开始变得有趣。</p>
<h1 id="构建你的HTML结构"><a href="#构建你的HTML结构" class="headerlink" title="构建你的HTML结构"></a>构建你的HTML结构</h1><p>现在我们将会从前面的教程中使用我们的HTML结构。但是让我们还是学一点关于WordPress和模板的东西吧。</p>
<p>WordPress真的只需要一个模板文件，<code>index.php</code>。我们能够并且将会针对一些特殊的场合使用一系列模板文件（单个文章，归档，页面等）而不是<code>index.php</code>。但是在最开始，<code>index.php</code>才是我们所需要的。</p>
<p>现在，<code>index.php</code>和所有相关的文件都构成了我们在浏览器看到的种种。他们是由一些HTML和PHP渲染而成的。</p>
<p>让我们想想一些类似小说的网页，其包含了开头中间和结尾。当我们写入我们的index.php文件的时候（接下来就是我们的<code>single.php</code>，<code>category.php</code>等文件），我们将只会留心与中间的部分。但是我们将会直接引用开头和结尾的那一部分。我们可能需要复写我们的中间部分因为我们只想一次性的搞定开头和结尾的网页页面。</p>
<h2 id="Header-php和Footer-php"><a href="#Header-php和Footer-php" class="headerlink" title="Header.php和Footer.php"></a>Header.php和Footer.php</h2><p>在我们之前的创建的HTML结构查看并且把所有的代码粘贴到这里并且在<code>header.php</code>之中应该包含<code>&amp;lt;div id=&quot;main&quot;&amp;gt;</code>。它看起来应该像这样：</p>
<pre class="lang:xhtml decode:true ">&lt;div id="page" class="hfeed site"&gt;
     &lt;header id="masthead" class="site-header" role="banner"&gt;
         &lt;hgroup&gt;&lt;/hgroup&gt;
         &lt;nav role="navigation" class="site-navigation main-navigation"&gt;&lt;/nav&gt;&lt;!-- .site-navigation .main-navigation --&gt;
     &lt;/header&gt;&lt;!-- #masthead .site-header --&gt;
&lt;div id="main" class="site-main"&gt;</pre>

<p>现在在后面复制所有事情，包含<span class="lang:xhtml decode:true crayon-inline">&lt;/div&gt;&lt;!– #main –&gt;</span>在<code>footer.php</code>之中，它看起来可能是这样：</p>
<pre class="lang:xhtml decode:true ">&lt;/div&gt;&lt;!-- #main .site-main --&gt;
     &lt;footer id="colophon" class="site-footer" role="contentinfo"&gt;
          &lt;div class="site-info"&gt;&lt;/div&gt;&lt;!-- .site-info --&gt;
     &lt;/footer&gt;&lt;!-- #colophon .site-footer --&gt;
&lt;/div&gt;&lt;!-- #page .hfeed .site --&gt;</pre>

<h2 id="sidebar-php"><a href="#sidebar-php" class="headerlink" title="sidebar.php"></a>sidebar.php</h2><p>把下面的代码复制到<code>sidebar.php</code>之中：</p>
<pre class="lang:xhtml decode:true ">&lt;div id="secondary" class="widget-area"&gt;
&lt;/div&gt;&lt;!-- #secondary .widget-area --&gt;

&lt;div id="tertiary" class="widget-area"&gt;
&lt;/div&gt;&lt;!-- #tertiary .widget-area --&gt;</pre>

<h2 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h2><p>我猜你们已经知道我们要做什么了。把下面的代码复制到#main div 之中而在#primary 闭合之前，那么差不多看成这样：</p>
<pre class="lang:xhtml decode:true ">&lt;div id="primary" class="content-area"&gt;
    &lt;div id="content" class="site-content" role="main"&gt;
    &lt;/div&gt;&lt;!-- #content .site-content --&gt;
&lt;/div&gt;&lt;!-- #primary .content-area --&gt;</pre>

<p>只需要两个很小几部，我们就会有一个完美的WordPress主题。我们需要在<code>header</code>，<code>sidebar</code>和<code>footer</code>之中调用这些函数。</p>
<p>在<code>index.php</code>的页首，我们需要添加模板标签：</p>
<pre class="lang:php decode:true ">&lt;?php get_header(); ?&gt;</pre>

<p>很好！那么在页尾，我们需要添加</p>
<pre class="lang:php decode:true ">&lt;?php get_sidebar(); ?&gt;
&lt;?php get_footer(); ?&gt;</pre>

<p>是的，现在我们就能够看到WordPress的主要文件index.php了。其有在页首调用了开始页，而在页尾也会调用函数。</p>
<p>重新加载页面并且检出代码，这样就是你的代码了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于WordPress而言，WordPress主题可能只需要一个&lt;code&gt;index.php&lt;/code&gt;模板和一个&lt;code&gt;style
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="wordpress" scheme="http://kidozh.com/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>创建一个WordPress的主题HTML结构</title>
    <link href="http://kidozh.com/2016/10/30/e5-88-9b-e5-bb-ba-e4-b8-80-e4-b8-aawordpress-e7-9a-84-e4-b8-bb-e9-a2-98html-e7-bb-93-e6-9e-84/"/>
    <id>http://kidozh.com/2016/10/30/e5-88-9b-e5-bb-ba-e4-b8-80-e4-b8-aawordpress-e7-9a-84-e4-b8-bb-e9-a2-98html-e7-bb-93-e6-9e-84/</id>
    <published>2016-10-29T17:09:47.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在我们着手进入到WordPress的真正开发阶段：开始编写HTML结构</p>
<h1 id="建立HTML结构的目的"><a href="#建立HTML结构的目的" class="headerlink" title="建立HTML结构的目的"></a>建立HTML结构的目的</h1><p>当我们编写一个网站的时候，你一定会有两个目标：使代码精简并且有意义。这样就是说，尽可能使用少的标记（也就是HTML的标签）并且保证使用类和ID名称使得标记有意义。举个例子，对于小工具栏，你应该使用<code>class=”widget-area”</code> 而不是 <code>class=”sidebar-left”</code>。</p>
<p>现在当我们编写一个WordPress的主题（或者任何针对内容管理系统的模板）的时候，我们需要找到一种介于精简代码和我们称之为<a href="http://www.456bereastreet.com/lab/web_development_mistakes/" target="_blank" rel="external">冗余</a>的东西。代码里包含了很多不必要的<code>div</code>元素。换句话说，有很多冗余结构。你可能在浏览网页或者WordPress的主题的源代码时候见过div。你可以把他们作为HTML代码的一个容器 - 这个容器对于使用CSS来操作HTML代码来说很方便。当然我们也会有一些，但是我们不会想要太多的以及没有意义的标签。</p>
<p>有一些诸如<code>header</code>、<code>nav</code>和<code>footer</code>的标签，HTML5已经使得我们对于有意义的布局的请求变得更为简单。这些信的主题和div标签很相似，并且这些标签能够作为HTML代码的容器。同样的，他们也能够允许我们创造一个更能描述HTML大纲的框架。</p>
<p>所以我们已经有很好的框架了，使用在HTML5新的标签，这样我们能够针对我们的博客和站点布局来进行代码复用。</p>
<h1 id="针对WordPress主题的HTML结构"><a href="#针对WordPress主题的HTML结构" class="headerlink" title="针对WordPress主题的HTML结构"></a>针对WordPress主题的HTML结构</h1><p>让我们看一看我们将会使用在WordPress主题主体的HTML结构。</p>
<pre class="lang:xhtml decode:true ">&lt;div id="page" class="hfeed site"&gt;
     &lt;header id="masthead" class="site-header" role="banner"&gt;
          &lt;hgroup&gt;&lt;/hgroup&gt;
          &lt;nav role="navigation" class="site-navigation main-navigation"&gt;&lt;/nav&gt;&lt;!-- .site-navigation .main-navigation --&gt;
     &lt;/header&gt;&lt;!-- #masthead .site-header --&gt;
     &lt;div id="main" class="site-main"&gt;
          &lt;div id="primary" class="content-area"&gt;
               &lt;div id="content" class="site-content"&gt;
               &lt;/div&gt;&lt;!-- #content .site-content --&gt;&lt;/div&gt;
          &lt;!-- #primary .content-area --&gt;
          &lt;div id="secondary" class="widget-area"&gt;
          &lt;/div&gt;&lt;!-- #secondary .widget-area --&gt;
          &lt;div id="tertiary" class="widget-area"&gt;
          &lt;/div&gt;&lt;!-- #tertiary .widget-area --&gt;&lt;/div&gt;
     &lt;!-- #main .site-main --&gt;
     &lt;footer id="colophon" class="site-footer" role="contentinfo"&gt;
          &lt;div class="site-info"&gt;
          &lt;/div&gt;&lt;!-- .site-info --&gt;
     &lt;/footer&gt;&lt;!-- #colophon .site-footer --&gt;
&lt;/div&gt; &lt;!-- #page .hfeed .site --&gt;</pre>

<p>事实上，这个HTML组成了_s的脊梁。继续把这个粘到你的文本编辑器并且把他存到一个顺手的地方，当我们勾践文件结构的时候，我们将会稍后使用到它。但是在这之前，我们还是要看一些事情。</p>
<h1 id="WordPress主题HTML快速的预览"><a href="#WordPress主题HTML快速的预览" class="headerlink" title="WordPress主题HTML快速的预览"></a>WordPress主题HTML快速的预览</h1><p>[caption id=”attachment_1390” align=”aligncenter” width=”768”]<img src="http://kidozh.com/wp-content/uploads/2016/10/html-visual1.png" alt="一个HTML的样例，点击获得大尺寸图片"> 一个HTML的样例，点击获得大尺寸图片[/caption]</p>
<p>看一下上面的HTML结构。块的颜色越深，也就代表其布局也越深。这些块的布局是由CSS所大致决定的，这些内容我们在后面会提到。</p>
<p>你也可以编辑HTML结构来满足你的需要。举个例子，你可以把导航（navigation）块移出<code>header</code>块或者把小工具（widget）块放进页脚（footer）块。根据这个指南的入门，我们将会使用CSS来安排我们的内容和小工具界面。</p>
<p>那么现在我们就开始写一点代码吧。</p>
<p>首先，在内容页的类，<code>hfeed</code>，<code>hfeed</code>是hatom Microformat schema的一部分。用简单的英语来说，就是告诉计算机来阅读这个内容（比如搜索引擎的爬虫或者其他服务都会通过这个来访问）。</p>
<p>看下文件结构中的<code>header</code>和<code>footer</code>的，你可能已经注意到了HTML5的新特征<code>header</code>和<code>footer</code>。这些标签描述了文件的广义小节。通过借用这些类名称，我将会向标记中添加更多的信息。</p>
<p>你将会发现了在HTML标签中的<code>ARIA</code>  <code>role</code>这个属性。这个role属性能够帮助一些残障辅助工具也来浏览你的站点。你可以在这里获得更多这一点的信息。</p>
<p>在我们HTML的主要区域中，注意一下我们的小工具块是在内容块之后的。你也许发现了我们的内容是在一个容器div（类名为‘content-area ’）这就是关键。它不仅让我们的主要内容在搜索引擎优先发现，而且使用CSS的时候也能精简CSS代码。</p>
<p>这个HTML的结构将会是你WordPress的未来框架，并且也会告诉你怎么使用CSS和这个强大的功能所搭配。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在我们着手进入到WordPress的真正开发阶段：开始编写HTML结构&lt;/p&gt;
&lt;h1 id=&quot;建立HTML结构的目的&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="wordpress" scheme="http://kidozh.com/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>主题开发工具</title>
    <link href="http://kidozh.com/2016/10/21/e4-b8-bb-e9-a2-98-e5-bc-80-e5-8f-91-e5-b7-a5-e5-85-b7/"/>
    <id>http://kidozh.com/2016/10/21/e4-b8-bb-e9-a2-98-e5-bc-80-e5-8f-91-e5-b7-a5-e5-85-b7/</id>
    <published>2016-10-20T21:58:41.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们开始开发wordpress主题之前，我们也需要把我们的工具带到位。在这一片博文中，我们将使用最好最强大的跨平台编译工具。</p>
<h1 id="本地开发工具XAMPP或者MAPP"><a href="#本地开发工具XAMPP或者MAPP" class="headerlink" title="本地开发工具XAMPP或者MAPP"></a>本地开发工具XAMPP或者MAPP</h1><p>开发wordpress最好的地方并不是在服务器上，而是在本地环境里。为了做到这个，你需要把你的电脑变成一个本地的服务器，特别是要把主题移植到一个常见的网页服务器（Apache、MySQL和PHP），这也意味着你可以在你的电脑上安装WordPress。</p>
<p>分开安装这些程序在技术上是一个很大的挑战，但是有些程序仍能够帮助我们安装并且管理他们。</p>
<p>如果你是Windows用户，你就可以试试<a href="http://www.apachefriends.org/en/xampp-windows.html" target="_blank" rel="external">XAMPP</a>。</p>
<p>如果你运行的是Mac，你就需要下载<a href="http://www.mamp.info/en/index.html" target="_blank" rel="external">MAPP</a>。</p>
<p>如果你是Linux用户，用命令行把骚年。</p>
<h1 id="在远程服务器上开发代码"><a href="#在远程服务器上开发代码" class="headerlink" title="在远程服务器上开发代码"></a>在远程服务器上开发代码</h1><p>如果你想在远程服务器上开发主题的话（比如HostGator、Blue Host），你就需要使用FTP客户端来访问站点，对于更多关于FTP的客户端，你也可以在<a href="http://codex.wordpress.org/FTP_Clients" target="_blank" rel="external">Codex page</a>上看到更多信息。</p>
<p>如果你没有一个FTP的客户端，你就需要安装一个，这里有一些免费的工具：</p>
<ul>
<li>CyberDuck - 针对Mac和Windows</li>
<li>FileZilla - 针对Mac，PC和Linux</li>
</ul>
<p>在你下载并且安装了FTP客户端之后，你就需要通过它来连接到你的网站。你可以通过查看你选择的客户端文档来知道如何做到。</p>
<p>一旦你连接到了你的站点，你就可以安装WordPress了。</p>
<h1 id="虚拟内容"><a href="#虚拟内容" class="headerlink" title="虚拟内容"></a>虚拟内容</h1><p>你的WordPress的安装需要一些样本，有些还可能是虚构的。在你的WordPress的后台中，在<strong>工具 &gt; 导入</strong>中选择<strong>从wordpress中导入</strong>。现在我们只需要<code>WXR</code>格式的博文数据来导入。</p>
<h2 id="现在有一些你可以用的选项"><a href="#现在有一些你可以用的选项" class="headerlink" title="现在有一些你可以用的选项"></a>现在有一些你可以用的选项</h2><ul>
<li><a href="http://codex.wordpress.org/Theme_Unit_Test" target="_blank" rel="external">The Theme Unit Test data</a></li>
<li><a href="http://wpcandy.com/articles/easier-theme-development-with-the-sample-post-collection.html" target="_blank" rel="external">WPCandy Sample Content</a></li>
</ul>
<p>每一个测试数据集都有他们的发布的信息。我喜欢干的一件事情就是尽可能导入所有的虚拟文件。这样就不会丢失任何信息。当你想你怎么做的时候，你就可以使用博文导航来浏览每一个博文。你可以检出按照年月或者目录排序的历史记录。有着稳健的虚拟内容的支撑，当有些东西没考虑到的话，我们也可以轻易发现。</p>
<h2 id="添加一些真实的内容"><a href="#添加一些真实的内容" class="headerlink" title="添加一些真实的内容"></a>添加一些真实的内容</h2><p>除了虚拟的内容，添加一些真实的内容也是很机智的。事实上，动态内容并不只是Lorem Ipsum和Little Blind Text的重复显示。从来自一个真实的博客和计算机中的文档中获得信息并且从中创建一些博文都是很必要的。一个真实的内容将会渲染一个非常精准的内容，内容将会显示主题在实际环境中是怎么起作用的（如果你想知道相关的信息，你可以看这一片文章 <a href="https://themeshaper.com/2012/02/27/dont-let-lorem-ipsum-decide-the-fonts-used-in-your-wordpress-themes/" target="_blank" rel="external">Don’t let Lorem Ipsum decide the fonts used in your WordPress Themes</a>）。</p>
<h1 id="开发指导"><a href="#开发指导" class="headerlink" title="开发指导"></a>开发指导</h1><p>如果你对当前主题开发感兴趣，<a href="http://codex.wordpress.org/Theme_Review" target="_blank" rel="external">主题检查指导</a>也是一个非常好的起点。</p>
<h1 id="必要的插件"><a href="#必要的插件" class="headerlink" title="必要的插件"></a>必要的插件</h1><p>如果你想获得开发插件的副本的话，你可以到<a href="http://automattic.com/" target="_blank" rel="external">Automattic</a>中获得进一步情况。在激活之后，他会给出成吨的你可以安装的插件来帮助你优化你的WordPress开发环境并且测试你的WordPress主题是否是最佳的代码体验。如果您想获得更多的信息，你就可以查看 <a href="https://themeshaper.com/2012/09/20/developer-plugin-v1-1-optimize-your-theme-development-environment/" title="Developer plugin v1.1: Optimize Your Theme Development Environment" target="_blank" rel="external">our brief overview of the Developer Plugin</a>。</p>
<p>由 <a href="http://wordpress.mfields.org/" target="_blank" rel="external">Michael Fields</a>开发的<a href="https://themeshaper.com/2012/05/15/introducing-the-monster-widget/" title="Introducing the Monster Widget" target="_blank" rel="external">Monster Widget</a>，也是一个对于开发者必备的插件。通过把monster小组件拖拽到你的侧边栏，你就能够一次性测试WordPress的核心小组件了。</p>
<h1 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h1><p>你不需要任何特殊的针对WordPress主题开发的图形界面，也许一个简陋的文本编辑器也是可以的。当然有总比没有好。</p>
<p>对于Windows来说，你可以尝试<a href="http://notepad-plus.sourceforge.net/uk/site.htm" target="_blank" rel="external">Notepad++</a>。它是个免费而且开源的软件，并且也被<a href="http://lifehacker.com/385929/best-text-editors" target="_blank" rel="external">Lifehacker</a>所推荐的。</p>
<p>对于Mac来说，我推荐<a href="http://www.barebones.com/products/TextWrangler/" target="_blank" rel="external">Text Wrangler</a>。</p>
<p>对于Linux来说，Visual Code Editor也是很好用的。</p>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h2><p>自然，你可以使用任何针对网页开发的浏览器，但是我很推荐火狐浏览器。特别是接下来的两个插件，当提到WordPress开发的时候，他们会让你的开发更加简洁。</p>
<p><a href="https://addons.mozilla.org/en-US/firefox/addon/60" target="_blank" rel="external">Web Developer Add-on for Firefox</a>会添加一个工具条，这个工具条会给你提供从禁用CSS样式到验证本地HTML代码的一整套的检查和调试的方案。</p>
<p><a href="https://addons.mozilla.org/en-US/firefox/addon/1843" target="_blank" rel="external">Firebug Add-on for Firefox</a>也是必不可少的。有了Firefox之后，你就可以在浏览器窗口中点击任何元素来获得对应的源代码。你也能够检查每个单独的样式规则。你也可以禁用这个规则来观察效果。你甚至可以添加或者修改规则以便观察实时变化。</p>
<p>Firefox 10+将会有一个类似firebug的内建的网页探测器。他也能够在浏览器窗口中点击任何元素来获得对应的源代码。这个网页探测器，虽然好用，但是终究不能替代Firebug的特性和功能。</p>
<h2 id="Safari和Chrome"><a href="#Safari和Chrome" class="headerlink" title="Safari和Chrome"></a>Safari和Chrome</h2><p>如果Firefox不是你的那碗菜，Safari和Google Chrome也是很值得推荐的。这两个浏览器都包含一个类似Firebug的内建开发工具。</p>
<p>这里是<a href="https://developer.apple.com/technologies/safari/developer-tools.html" target="_blank" rel="external">Safari</a>的开发文档，这里则是<a href="http://developers.google.com/chrome-developer-tools/docs/overview" target="_blank" rel="external">Chrome</a>的开发工具文档。</p>
<h1 id="HTML和CSS"><a href="#HTML和CSS" class="headerlink" title="HTML和CSS"></a>HTML和CSS</h1><p>对于HTML和CSS的熟识将会帮助您的WordPress开发。我推荐关于HTML的这两本书。</p>
<ul>
<li><a href="http://htmldog.com/guides/htmlbeginner/" target="_blank" rel="external">HTML Beginner Tutorial</a></li>
<li><a href="http://www.htmldog.com/guides/cssbeginner/" target="_blank" rel="external">CSS Beginner Tutorial</a></li>
</ul>
<p>如果你想快速上手，你就可以看<a href="http://html5doctor.com/element-index/" target="_blank" rel="external"> Element Index from HTML5 Doctor</a>。阅读这些指南是完全可选的，他们对您理解一些基本概念有益无害。</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>那PHP呢？你难道不应该知道PHP来创建一个WordPress主题吗？这个答案是肯定的。但是我会告诉你充足的关于WordPress主题的一些雷区。当然这也是不必须的，你所需要的仅仅是学习一些基本的常识。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇博文将会告诉你如何从草图中创建一个强大的WordPress主题，从头开始阅读并且亲自码代码是一件非常美妙的事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在我们开始开发wordpress主题之前，我们也需要把我们的工具带到位。在这一片博文中，我们将使用最好最强大的跨平台编译工具。&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="wordpress" scheme="http://kidozh.com/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>主题感</title>
    <link href="http://kidozh.com/2016/10/20/e4-b8-bb-e9-a2-98-e6-84-9f/"/>
    <id>http://kidozh.com/2016/10/20/e4-b8-bb-e9-a2-98-e6-84-9f/</id>
    <published>2016-10-19T20:21:23.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是主题感"><a href="#什么是主题感" class="headerlink" title="什么是主题感"></a>什么是主题感</h1><p>什么是主题感？主题感就是对WordPress主题的一种对于渲染主题的文件以及这些文件在WordPress中的作用的联系。这个现在讲起来很费劲，你也可以在这个入门的结尾中了解到什么是主题感。</p>
<h1 id="主题感并不是对代码囫囵吞枣"><a href="#主题感并不是对代码囫囵吞枣" class="headerlink" title="主题感并不是对代码囫囵吞枣"></a>主题感并不是对代码囫囵吞枣</h1><p>让我们想想数学和对数学的观感。如果你想让一个孩子通过卡片来牢记运算法则，而你却没告诉他为什么答案是这样。那么当他们没有记下答案的时候，小孩子就会问题不知所措。</p>
<p><img src="http://kidozh.com/wp-content/uploads/2016/10/numbersense1.png" alt="numbersense1"></p>
<p>举个例子，使用卡片来5+2=7是如何运算，这样结合事实的方法能够阐述事实。即使他们没有记下来答案，孩子也可以之后活学活用，来帮助解决他们可能在以后遇到的种种困难。</p>
<h1 id="如何培养我的主题感"><a href="#如何培养我的主题感" class="headerlink" title="如何培养我的主题感"></a>如何培养我的主题感</h1><p>如果你已经看到这里了，你也差不多了。主题感会应用于你正在做的，做出精准而明确的决定的时候。举个例子，如果有人让你去设计一个汽车，你可能立马就知道你的设计中应该包含什么 - 引擎、框架、轮胎、窗户、尾气管等等。你可能不知道他们每个是怎么工作的，但是你一定能够解释，在你的设计中，为什么需要这些东西并且你也可以检查它们的质量 - 对于安全来说至关重要。你的驾龄也会引导你主题感的产生。</p>
<p>当你做以后的主题工程的时候，你也可以使用相似的方法。有一个很常见的问题就是：我应该在我的主题中包含哪些文件？这些文件是干什么的？为什么我会在我的主题中有这一串代码？这串代码从哪来，到哪去？这串代码很落后吗？这串代码值得信任吗？</p>
<p>你不一定要了解每一行PHP代码的运行机理，因为他可能会变化很多次。更为重要的是，和车的设计一样，你一个能够阐述一个对你主题要做什么的宏观的理解。</p>
<p>这也就是说，你一个在培养宏观的感官中，做了下面事情之后，你的主题感就会更为敏锐。</p>
<h1 id="知道WordPress的一些新鲜事"><a href="#知道WordPress的一些新鲜事" class="headerlink" title="知道WordPress的一些新鲜事"></a>知道WordPress的一些新鲜事</h1><p>WordPress的代码都是在网站中随处可见，其甚至可以在离线，书本和杂志中见到。当你仰望星空的时候，你知道他们已经存在千年。同样的，当你检查一个WordPress代码样本的时候，那也仅仅是WordPress的惊鸿一瞥，并且也不一定是WordPress所必要的。</p>
<p>掌握WordPress的最新最新版本和主要新特性，你就能够很好的预估WordPress入门和插件的走向。为了跟上WordPress的步伐，你可以订阅<a href="http://wordpress.org/news/" target="_blank" rel="external">WordPress新闻博客</a>。</p>
<h1 id="把检查日期当作一种习惯"><a href="#把检查日期当作一种习惯" class="headerlink" title="把检查日期当作一种习惯"></a>把检查日期当作一种习惯</h1><p>在看入门或者书本之前，你都必须首先检查其发布的时间。为什么知道WordPress更新了什么这么重要？因为这回帮助我们评估入门中的哪些部分还能够抓住时间的尾巴，并且仍能够对于现在的主题饭否。你可能知道，在主题中使用过时的代码是很危险的，因为黑客可以轻易的把代码的漏洞给挖出来。</p>
<p>如果你在主题中使用了过时的代码，这也并不是世界末日。有些插件，比如<a href="http://wordpress.org/extend/plugins/developer/" target="_blank" rel="external">Developer</a>和<a href="http://wordpress.org/extend/plugins/theme-check/" target="_blank" rel="external">Theme-Check</a>就能够帮助你优化你WordPress主题的开发环境并且扫描你现在的主题代码。</p>
<p>对于开发者插件而言，养成符合安全规范<a href="http://codex.wordpress.org/Theme_Review#Theme_Settings_and_Data_Security" target="_blank" rel="external">listed in the Theme Security and Privacy Guidelines</a>的习惯是非常好的。这个规范也可以在WordPress Codex中看到。查看这个列表，你可以找到你正在使用特性的参考。举个例子，关于<a href="http://codex.wordpress.org/Data_Validation" target="_blank" rel="external">数据验证和检查</a>对于防止站点受到<a href="http://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">XSS</a>攻击来说，非常有用。</p>
<p>当我们提及代码相关和及时性，我认为在列表中的第二项的原则是非常恰当的。</p>
<blockquote>
<p>主题应该显示的执行主题选项以及设定而不是直接把结果硬编码到网站之中。</p>
</blockquote>
<p>复制粘贴代码可能很快，但是这个方法不仅仅应用在了主题选项代码里了，同样的其不可以被其他人所更改。我指示想让你知道代码的及时性以及安全性的重要。</p>
<h1 id="对于WordPress主题的一些必需元素的理解"><a href="#对于WordPress主题的一些必需元素的理解" class="headerlink" title="对于WordPress主题的一些必需元素的理解"></a>对于WordPress主题的一些必需元素的理解</h1><p>大多数网站，不管是运行着WordPress还是没有，都通常由下面的部分构成：页头，主要区域，侧边栏和页脚。如果你把这些想象成一个组件，那对于你的理解来说是大有裨益的。对于一些块，比如页头，页脚，主要内容和侧边栏，你可能会在你开发的每个主题之中都会遇见。你要做的仅仅是根据用户的需求把他们粘到一起。和WordPress的主题类似，一些诸如header.php、index.php、sidebar.php和footer.php都是块，因此，主题实际上就是一个你针对这些块勾践的一个完整的结构。</p>
<p>了解到这些必要的元素之后，我们就能够更好的培养这些感觉。如果你想快速查阅WordPress的类的话，你可以查看<a href="http://codex.wordpress.org/Theme_Development#Template_Files" target="_blank" rel="external"> The Theme Development page on the WordPress Codex</a></p>
<h1 id="知道哪里能找到最新的代码标准和样例"><a href="#知道哪里能找到最新的代码标准和样例" class="headerlink" title="知道哪里能找到最新的代码标准和样例"></a>知道哪里能找到最新的代码标准和样例</h1><p><a href="WordPress.org Codex">http://codex.wordpress.org</a>是一个研究WordPresshan函数和模板标签很好的起点。如果一个函数被废弃了，Codex页面上就会标记并且告诉你可以替换的函数。你也可以在<a href="http://codex.wordpress.org/Category:Deprecated_Functions" target="_blank" rel="external">这个清单</a>里找到所有被废弃的函数。</p>
<p>WordPress主题审核团队有一系列的审核标准，这个标准确保了所有的主题都应该符合。这样就可以被WordPress.org买南非主题目录所收录。把你的代码和这些标准比对能帮助你保持最佳的体验。</p>
<p>最后，当你对某些事情感到困惑，你可以上一些地方提问，比如<a href="http://wordpress.org/support/forum/themes-and-templates" target="_blank" rel="external">Themes &amp; Templates</a>。如果你更倾向于实时聊天，那么在irc.freenode.net上#wordpress的频道里，你也可以获得帮助。</p>
<p>当然，这也不是说在构建主题的时候，你必须墨守成规。反而，能够了解到你正在做的决定以及你为什么这么做是很机智的。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这里你需要注意的点有：</p>
<ul>
<li>注意wordpress现在的情况</li>
<li>知道最新版本的wordpress引入了哪些新特性</li>
<li>注意所有wordpress教程的时间。把他和wordpress新特性的特征结合起来就能估计任何教程的相关性</li>
<li>理解代码迭代很快，但是基础的组成件几乎是一成不变的</li>
<li>知道最新的标准，这也能在评估教程的相关性时也很重要</li>
<li>知道你为什么做出这个决定，举个例子，每个模板文件是干什么的？如果你正要粘贴来自Google搜索的一大段代码的话，你是否知道这串代码在做什么？和现在的版本相容吗？及时吗？安全吗？你当然没有必要记下PHP代码中的每一行。因为你能够在宏观层次上架构你的代码才是更难得的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是主题感&quot;&gt;&lt;a href=&quot;#什么是主题感&quot; class=&quot;headerlink&quot; title=&quot;什么是主题感&quot;&gt;&lt;/a&gt;什么是主题感&lt;/h1&gt;&lt;p&gt;什么是主题感？主题感就是对WordPress主题的一种对于渲染主题的文件以及这些文件在WordPress中的
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="wordpress" scheme="http://kidozh.com/tags/wordpress/"/>
    
      <category term="PHP" scheme="http://kidozh.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>创建一个WordPress主题</title>
    <link href="http://kidozh.com/2016/10/19/e5-88-9b-e5-bb-ba-e4-b8-80-e4-b8-aawordpress-e4-b8-bb-e9-a2-98/"/>
    <id>http://kidozh.com/2016/10/19/e5-88-9b-e5-bb-ba-e4-b8-80-e4-b8-aawordpress-e4-b8-bb-e9-a2-98/</id>
    <published>2016-10-19T13:54:23.000Z</published>
    <updated>2017-04-29T08:28:11.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>翻译自<a href="https://themeshaper.com/2012/10/22/the-themeshaper-wordpress-theme-tutorial-2nd-edition/" target="_blank" rel="external">https://themeshaper.com/2012/10/22/the-themeshaper-wordpress-theme-tutorial-2nd-edition/</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在仅仅的16个课程里，这个WordPress主题知道将会告诉你如何开始构建一个强大而与时俱进的WordPress主题。在接下来的课程之中，我会解释一些或好或坏的我对于一些特定技术的理解以及我选择某项技术的原因。更为重要的是，我会告诉你一切和WordPress主题开发相关的任何事情。</p>
<p>在这个入门之中，你能够随心所欲的开发WordPress了。</p>
<p><img src="http://kidozh.com/wp-content/uploads/2016/10/theme-shaper-cloud1.png" alt="theme-shaper-cloud1"></p>
<h1 id="下划线-s-的开始主题的入门"><a href="#下划线-s-的开始主题的入门" class="headerlink" title="下划线(_s)的开始主题的入门"></a>下划线(_s)的开始主题的入门</h1><p>如果你还没有听说过<code>_s</code>，简而言之，这是一个100%的GPL，由社区开发的开始主题。这个主题包含了一些现代化的模板，初学者的CSS和一个组织良好的文件结构。这意味着，你所需要做的就只是从头开始设计。你也可以使用<code>_s</code>作为你将来主题开发大厦的一块奠基石。如果你想了解更多<code>_s</code>背后的故事，你也可以花些时间来看看<a href="https://themeshaper.com/2012/02/13/introducing-the-underscores-theme/" target="_blank" rel="external">A 1000-Hour Head Start: Introducing the _s Theme.</a></p>
<p>我们将要在这个入门里将会构建一个很简单的主题，<a href="https://themeshaper.files.wordpress.com/2014/03/shape1.zip" target="_blank" rel="external">shape</a>（这个主题在入门的第一版里被提到了，现在他会为第二版做出一些更新），这个主题也基于<code>_s</code>。如果你想看我们将来要完成的代码，那么不妨下载并且略观一二。在我们学习CSS的课程之前，显然这是比较乏力的。但是如果你想看看我们最终创建shape这个主题的设计思路的话，你就可以<a href="https://themeshaper.files.wordpress.com/2013/10/shape-sample-style.zip" target="_blank" rel="external">点这里</a>了。</p>
<h2 id="历史的一些包袱"><a href="#历史的一些包袱" class="headerlink" title="历史的一些包袱"></a>历史的一些包袱</h2><p>如果你阅读了这篇第一版的入门指南，那么我会告诉你，第一版中的代码有些已经过时了。但这还好，因为更重要的事情就是你能够理解一些很宽泛的概念，这也是为什么他们仍在这里抛头露面的原因。同样的，你也可以在这里获得一份关于<a href="https://github.com/automattic/_s" target="_blank" rel="external"> the latest _s source code from the GitHub repository</a>的复印件。</p>
<p>下面是一些你可能会涉及到关于主题的内容：</p>
<ul>
<li>一个良好组织并且模块化的文件结构</li>
<li>一些实用的针对搜索引擎的优化</li>
<li>谷歌支持的<a href="http://google.com/support/webmasters/bin/answer.py?answer=146897" target="_blank" rel="external">Microformat</a>的语义</li>
<li>有效并且具有逻辑的语义标记结构，这个结构能够创建ANY布局</li>
<li>智能的CSS布局</li>
<li>支持本地化：支持翻译以及从右到左的层叠表</li>
<li>动态的主体，文章和评论CSS类</li>
<li>分离的回溯和评论系统</li>
<li>两个小工具区域，第一个是默认的小工具，第二个当其为空的时候就会消失</li>
<li>对于<code>Aside</code>投稿格式的支持（在这个教程节数之后，你就能够轻松的对更多博客格式给予支持）</li>
<li>一个自定义的目录，弹性的自定义头图片和一个自定义的背景</li>
<li>一个简单的响应式样式，包括一个对移动设备轻量化的导航菜单</li>
<li>还有你想获得的所有WordPress的资料</li>
</ul>
<p>我认为对任何WordPress主题这也是重要的。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;来源&quot;&gt;&lt;a href=&quot;#来源&quot; class=&quot;headerlink&quot; title=&quot;来源&quot;&gt;&lt;/a&gt;来源&lt;/h1&gt;&lt;p&gt;翻译自&lt;a href=&quot;https://themeshaper.com/2012/10/22/the-themeshaper-wordpre
    
    </summary>
    
      <category term="网页" scheme="http://kidozh.com/categories/%E7%BD%91%E9%A1%B5/"/>
    
    
      <category term="网页" scheme="http://kidozh.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="wordpress" scheme="http://kidozh.com/tags/wordpress/"/>
    
      <category term="模板" scheme="http://kidozh.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
