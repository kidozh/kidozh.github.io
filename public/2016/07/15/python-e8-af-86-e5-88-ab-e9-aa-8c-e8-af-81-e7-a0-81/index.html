<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python识别验证码 · kidozh</title><meta name="description" content="Python识别验证码 - kido zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://kidozh.com/atom.xml" title="kidozh"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1793490853" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/kidozh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python识别验证码</h1><div class="post-info">2016年7月15日</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在网页爬虫的时候往往我们需要破解验证码，这篇博文是为了论证如何依赖Python来识别验证码。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先我们需要安装PIL这个库。</p>
<p><pre class="lang:sh decode:true">sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev \<br>libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk<br>sudo pip install pillow</pre><br>Pillow相对于老版本的PIL好处已经在网上有很多，这里也不再介绍了。。。</p>
<h1 id="提取图片文件"><a href="#提取图片文件" class="headerlink" title="提取图片文件"></a>提取图片文件</h1><p>首先我们可以下载一个验证码包，你可以使用下面的命令下载：</p>
<p><pre class="lang:sh decode:true">$ wget <a href="http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip" target="_blank" rel="external">http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip</a><br>$ unzip python_captcha.zip<br>$ cd python_captcha</pre><br>这样就可以下载到验证码了。</p>
<p>比如这一张：<img src="/wp-content/uploads/2016/07/captcha.gif" alt="captcha"></p>
<p><pre class="lang:python decode:true">#coding:UTF-8<br><strong>author</strong> = ‘exbot’<br>from PIL import Image</pre></p>
<p>im = Image.open(“python_captcha/captcha.gif”)</p>
<p>#(将图片转换为8位像素模式)<br>im = im.convert(“P”)</p>
<p>#打印颜色直方图<br>print im.histogram()<br>这样最后就能输出颜色的直方图：</p>
<p><pre class="lang:python decode:true">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 1, 2, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 3, 1, 3, 3, 0, 0, 0, 0, 0, 0, 1, 0, 3, 2, 132, 1, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 15, 0, 1, 0, 1, 0, 0, 8, 1, 0, 0, 0, 0, 1, 6, 0, 2, 0, 0, 0, 0, 18, 1, 1, 1, 1, 1, 2, 365, 115, 0, 1, 0, 0, 0, 135, 186, 0, 0, 1, 0, 0, 0, 116, 3, 0, 0, 0, 0, 0, 21, 1, 1, 0, 0, 0, 2, 10, 2, 0, 0, 0, 0, 2, 10, 0, 0, 0, 0, 1, 0, 625]<br></pre><br>颜色直方图的每一位数字都代表了在图片中含有对应位的颜色的像素的数量。</p>
<p>每个像素点可表现256种颜色，你会发现白点是最多（白色序号255的位置，也就是最后一位，可以看到，有625个白色像素）。红像素在序号200左右，我们可以通过排序，得到有用的颜色。</p>
<p>接下来，我们继续操作这个直方图：</p>
<p><pre class="lang:python decode:true ">his = im.histogram()<br>values = {}</pre></p>
<p>for i in range(256):<br>    values[i] = his[i]</p>
<p>for j,k in sorted(values.items(),key=lambda x:x[1],reverse = True)[:10]:<br>    print j,k<br>这样就会按照顺序输出直方图中的原来值和对应的键值的序列了。</p>
<p><pre class="lang:default decode:true ">255 625<br>212 365<br>220 186<br>219 135<br>169 132<br>227 116<br>213 115<br>234 21<br>205 18<br>184 15</pre><br>这样我们就得到了很多种颜色，而很明显的，在验证码里面我们只需要红色和灰色，其他的我们可以视为杂色排除。而通过这样我们就能过构造出一个灰色图出来。</p>
<p><pre class="lang:default decode:true ">#-<em>- coding:utf8 -</em>-<br>from PIL import Image</pre></p>
<p>im = Image.open(“captcha.gif”)<br>im = im.convert(“P”)<br>im2 = Image.new(“P”,im.size,255)</p>
<p>for x in range(im.size[1]):<br>    for y in range(im.size[0]):<br>        pix = im.getpixel((y,x))<br>        if pix == 220 or pix == 227: # these are the numbers to get<br>            im2.putpixel((y,x),0)</p>
<p>im2.show()<br>这样我们就得到了只有红色和灰色的图像，这就比较容易辨识了。</p>
<h1 id="提取单个字符"><a href="#提取单个字符" class="headerlink" title="提取单个字符"></a>提取单个字符</h1><p>由于这种字符比较简单，我们就直接纵向切割，提取单个字符就可以了。</p>
<p><pre class="lang:python decode:true ">inletter = False<br>foundletter=False<br>start = 0<br>end = 0</pre></p>
<p>letters = []</p>
<p>for y in range(im2.size[0]):<br>    for x in range(im2.size[1]):<br>        pix = im2.getpixel((y,x))<br>        if pix != 255:<br>            inletter = True<br>    if foundletter == False and inletter == True:<br>        foundletter = True<br>        start = y</p>
<pre><code>if foundletter == True and inletter == False:
    foundletter = False
    end = y
    letters.append((start,end))

inletter=False
</code></pre><p>print letters<br>这样就输出：</p>
<p><pre class="lang:python decode:true">[(6, 14), (15, 25), (27, 35), (37, 46), (48, 56), (57, 67)]</pre><br>这样就可以知道每个字符开始和结束的序列号。</p>
<p><pre class="lang:python decode:true ">import hashlib<br>import time</pre></p>
<p>count = 0<br>for letter in letters:<br>    m = hashlib.md5()<br>    im3 = im2.crop(( letter[0] , 0, letter[1],im2.size[1] ))<br>    m.update(“%s%s”%(time.time(),count))<br>    im3.save(“./%s.gif”%(m.hexdigest()))<br>    count += 1<br>对图像进行切割就可以得到字符了。</p>
<h1 id="向量空间搜索"><a href="#向量空间搜索" class="headerlink" title="向量空间搜索"></a>向量空间搜索</h1><p>在这里我们使用向量空间搜索引擎来做字符识别，它具有很多优点：</p>
<ul>
<li>不需要大量的训练迭代</li>
<li>不会训练过度</li>
<li>你可以随时加入／移除错误的数据查看效果</li>
<li>很容易理解和编写成代码</li>
<li>提供分级结果，你可以查看最接近的多个匹配</li>
<li>对于无法识别的东西只要加入到搜索引擎中，马上就能识别了。<br>当然它也有缺点，例如分类的速度比神经网络慢很多，它不能找到自己的方法解决问题等等。</li>
</ul>
<p>举个例子，你有3篇文档，筛选出其中的单词作为特征，对应单词的数量作为特征的值。取n个单词就生成一个n维空间，而每一篇文档就是在这个空间中的矢量，我们只要计算矢量之间的角度就能得到文章的相似度了。</p>
<p><pre class="lang:python decode:true ">import math</pre></p>
<p>class VectorCompare:</p>
<pre><code>#计算矢量大小
def magnitude(self,concordance):
    total = 0
    for word,count in concordance.iteritems():
        total += count ** 2
    return math.sqrt(total)

#计算矢量之间的 cos 值
def relation(self,concordance1, concordance2):
    relevance = 0
    topvalue = 0
    for word, count in concordance1.iteritems():
        if concordance2.has_key(word):
            topvalue += count * concordance2[word]
    return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))&lt;/pre&gt;
</code></pre><p>这样他就会计算两个Python的字典类型并且输出他们的相似度。</p>
<p>取大量验证码提取单个字符图片作为训练集合的工作，但只要是有好好读上文的同学就一定知道这些工作要怎么做，在这里就略去了。可以直接使用提供的训练集合来进行下面的操作。</p>
<p>iconset目录下放的是我们的训练集。</p>
<p>最后追加的内容：</p>
<p><pre class="lang:python decode:true ">#将图片转换为矢量<br>def buildvector(im):<br>    d1 = {}<br>    count = 0<br>    for i in im.getdata():<br>        d1[count] = i<br>        count += 1<br>    return d1</pre></p>
<p>v = VectorCompare()</p>
<p>iconset = [‘0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’,’0’,’a’,’b’,’c’,’d’,’e’,’f’,’g’,’h’,’i’,’j’,’k’,’l’,’m’,’n’,’o’,’p’,’q’,’r’,’s’,’t’,’u’,’v’,’w’,’x’,’y’,’z’]</p>
<p>#加载训练集<br>imageset = []<br>for letter in iconset:<br>    for img in os.listdir(‘./iconset/%s/‘%(letter)):<br>        temp = []<br>        if img != “Thumbs.db” and img != “.DS_Store”:<br>            temp.append(buildvector(Image.open(“./iconset/%s/%s”%(letter,img))))<br>        imageset.append({letter:temp})</p>
<p>count = 0</p>
<p>#对验证码图片进行切割<br>for letter in letters:<br>    m = hashlib.md5()<br>    im3 = im2.crop(( letter[0] , 0, letter[1],im2.size[1] ))</p>
<pre><code>guess = []

#将切割得到的验证码小片段与每个训练片段进行比较
for image in imageset:
    for x,y in image.iteritems():
        if len(y) != 0:
            guess.append( ( v.relation(y[0],buildvector(im3)),x) )

guess.sort(reverse=True)
print &quot;&quot;,guess[0]
count += 1&lt;/pre&gt;
</code></pre><p>下面就是全部代码了：</p>
<p><pre class="lang:python decode:true ">from PIL import Image<br>import hashlib<br>import time<br>import os</pre></p>
<p>import math</p>
<p>class VectorCompare:<br>    def magnitude(self,concordance):<br>        total = 0<br>        for word,count in concordance.iteritems():<br>            total += count ** 2<br>        return math.sqrt(total)</p>
<pre><code>def relation(self,concordance1, concordance2):
    relevance = 0
    topvalue = 0
    for word, count in concordance1.iteritems():
        if concordance2.has_key(word):
            topvalue += count * concordance2[word]
    return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))
</code></pre><p>def buildvector(im):<br>    d1 = {}</p>
<pre><code>count = 0
for i in im.getdata():
    d1[count] = i
    count += 1

return d1
</code></pre><p>v = VectorCompare()</p>
<p>iconset = [‘0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’,’0’,’a’,’b’,’c’,’d’,’e’,’f’,’g’,’h’,’i’,’j’,’k’,’l’,’m’,’n’,’o’,’p’,’q’,’r’,’s’,’t’,’u’,’v’,’w’,’x’,’y’,’z’]</p>
<p>imageset = []</p>
<p>for letter in iconset:<br>    for img in os.listdir(‘./iconset/%s/‘%(letter)):<br>        temp = []<br>        if img != “Thumbs.db” and img != “.DS_Store”: # windows check…<br>            temp.append(buildvector(Image.open(“./iconset/%s/%s”%(letter,img))))<br>        imageset.append({letter:temp})</p>
<p>im = Image.open(“captcha.gif”)<br>im2 = Image.new(“P”,im.size,255)<br>im = im.convert(“P”)<br>temp = {}</p>
<p>for x in range(im.size[1]):<br>    for y in range(im.size[0]):<br>        pix = im.getpixel((y,x))<br>        temp[pix] = pix<br>        if pix == 220 or pix == 227: # these are the numbers to get<br>            im2.putpixel((y,x),0)</p>
<p>inletter = False<br>foundletter=False<br>start = 0<br>end = 0</p>
<p>letters = []</p>
<p>for y in range(im2.size[0]): # slice across<br>    for x in range(im2.size[1]): # slice down<br>        pix = im2.getpixel((y,x))<br>        if pix != 255:<br>            inletter = True</p>
<pre><code>if foundletter == False and inletter == True:
    foundletter = True
    start = y

if foundletter == True and inletter == False:
    foundletter = False
    end = y
    letters.append((start,end))

inletter=False
</code></pre><p>count = 0<br>for letter in letters:<br>    m = hashlib.md5()<br>    im3 = im2.crop(( letter[0] , 0, letter[1],im2.size[1] ))</p>
<pre><code>guess = []

for image in imageset:
    for x,y in image.iteritems():
        if len(y) != 0:
            guess.append( ( v.relation(y[0],buildvector(im3)),x) )

guess.sort(reverse=True)
print &quot;&quot;,guess[0]

count += 1&lt;/pre&gt;
</code></pre><p>这样直接运行就可以得到我们的验证码信息了。</p>
<h1 id="pytesser库"><a href="#pytesser库" class="headerlink" title="pytesser库"></a>pytesser库</h1><ol>
<li>pytesser依赖于PIL,因此需要先安装PIL模块，详见：<a href="http://wenyue.me/blog/278" target="_blank" rel="external"><span style="color: #0066cc;">http://wenyue.me/blog/278</span></a></li>
<li>pytesser调用了tesseract，因此需要安装tesseract：<br>先用包管理器安装这几个库：<br><pre class="lang:sh decode:true">sudo apt-get install libpng12-dev<br>sudo apt-get install libjpeg62-dev<br>sudo apt-get install libtiff4-dev<br>sudo apt-get install zlibg-dev</pre><br>下载tesseract的源码包：<a href="http://tesseract-ocr.googlecode.com/files/tesseract-3.00.tar.gz" target="_blank" rel="external">http://tesseract-ocr.googlecode.com/files/tesseract-3.00.tar.gz</a><br>解压、cd到解压后目录下tesseract-3.00/<br>运行./configure -prefix=你想要安装到的路径，比如:<br><pre class="">./configure –prefix=/home/pf-miles/installation/install/tesseract</pre><br>然后make &amp; make install<br>将tesseract的运行脚本加到环境变量中，比如：<br><pre class="">export PATH=$PATH:/home/pf-miles/installation/install/tesseract/bin<br></pre><br>, 这个路径与刚才你configure的时候设置的路径有关<br>到<a href="http://code.google.com/p/tesseract-ocr/downloads/list" target="_blank" rel="external"><span style="color: #0066cc;">http://code.google.com/p/tesseract-ocr/downloads/list</span></a>页 面去下载最新的<code>eng.traineddata.gz</code>文件，解压后的<code>eng.traineddata</code>放到<code>/home/pf-miles /installation/install/tesseract/share/tessdata</code>目录下，注意，虽然tesseract的svn trunk里也有这个文件，但那个用不得，会报<br><pre class="">actual_tessdata_num<em>entries</em> &lt;= TESSDATA_NUM_ENTRIES:Error:Assert failed:in file tessdatamanager.cpp, line 55</pre><br>错误，详见：<a href="http://www.uluga.ubuntuforums.org/showthread.php?p=10248384" target="_blank" rel="external"><span style="color: #0066cc;">http://www.uluga.ubuntuforums.org/showthread.php?p=10248384</span></a>，所以一定要用<a href="http://code.google.com/p/tesseract-ocr/downloads/list" target="_blank" rel="external"><span style="color: #0066cc;">http://code.google.com/p/tesseract-ocr/downloads/list</span></a>这里下载的那一份<br>试一试：<br><pre class="">tesseract<br>Usage:tesseract imagename outputbase [-l lang] [configfile [[+|-]varfile]…]</pre><br>OK,tesseract安装完毕</li>
<li>下载pytesser包：<a href="http://pytesser.googlecode.com/files/pytesser_v0.0.1.zip" target="_blank" rel="external"><span style="color: #0066cc;">http://pytesser.googlecode.com/files/pytesser_v0.0.1.zip</span></a>(目前是0.0.1版本), 解压…并cd到解压后的目录下</li>
<li>目录下有个“phototest.tif”图片文件作为测试用，直接在目录下写一个python脚本进行测试：<br>test.py:<br><div>from pytesser import * im = Image.open(‘phototest.tif’) text = image_to_string(im) print text</div><br>运行：<br><div><br><pre class="lang:default decode:true"> python test.py 2</pre><br></div><br>结果：<br>Thls IS a lot of 12 pornt text to test the<br>ocr code and see lf It works on all types<br>of frle format<br>lazy fox The qurck brown dog jumped<br>over the lazy fox The qulck brown dog<br>jumped over the lazy fox The QUICK<br>brown dog jumped over the lazy fox<br>The quick brown dog jumped over the<br>应该说准确率还令人满意吧</li>
</ol>
<p>pytesser的验证码识别能力比较低，只能对规规矩矩不歪不斜数字和字母验证码进行识别，这里还是要介绍下它的用法。有关它的安装和python对应的模块可以参考<a href="http://wenyue.me/blog/tag/pytesser" target="_blank" rel="external">http://wenyue.me/blog/tag/pytesser</a>。<br>pytesser只能对tiff（tif）格式的图片文件进行识别，大部分网站的验证码图片不是tiff格式的，所以需要进行转换。可使用Image模块转化图片格式：</p>
<p><pre class="lang:python decode:true ">#需要保存成tmp.tiff，发现保存成tmp.tif的话pytesser无法识别<br>Image.open(‘tmp.gif’).convert(‘RGB’).save(‘tmp.tiff’)</pre><br>获取验证码的时候需要让对方服务器写如cookie，所以需要以下这段</p>
<p><pre class="lang:python decode:true ">jk = cookielib.LWPCookieJar()<br>cookies = urllib2.HTTPCookieProcessor(jk)<br>opener = urllib2.build_opener(cookies)</pre><br>然后再需要拿着这个opener去登录， 登录成功后的，再去请求其他需要登录的页面的时候也需要使用这个opener去urlopen</p>
<p>&nbsp;</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/21/e6-94-af-e6-8c-81-e5-90-91-e9-87-8f-e8-87-aa-e5-8a-a8-e6-9c-ba/" class="prev">上一篇</a><a href="/2016/07/13/e8-b7-a8-e7-ab-99-e7-82-b9-e8-af-b7-e6-b1-82-e4-bc-aa-e9-80-a0/" class="next">下一篇</a></div><div class="copyright"><p>© 2013 - 2017 <a href="http://kidozh.com">kido zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>