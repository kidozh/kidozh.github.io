<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> python获取系统状态psutil的模块 · kidozh</title><meta name="description" content="python获取系统状态psutil的模块 - kido zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://kidozh.com/atom.xml" title="kidozh"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1793490853" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/kidozh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">python获取系统状态psutil的模块</h1><div class="post-info">2016年12月1日</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要一个可以实时访问系统信息的模块，网上搜索以后，发现了psutil可以大致满足我的要求。</p>
<h1 id="psutil简介"><a href="#psutil简介" class="headerlink" title="psutil简介"></a>psutil简介</h1><p>psutil(Python system and process utilities)是一个跨平台的进程管理和系统工具的python库，可以处理系统CPU，memory，disks，network等信息。主要用于系统资源的监控，分析，以及对进程进行一定的管理。通过psutil可以实现如<code>ps</code>，<code>top</code>，<code>lsof</code>，<code>netstat</code>，<code>ifconfig</code>， <code>who</code>，<code>df</code>，<code>kill</code>，<code>free</code>，<code>nice</code>，<code>ionice</code>，<code>iostat</code>，<code>iotop</code>，<code>uptime</code>，<code>pidof</code>，<code>tty</code>，<code>taskset</code>，<code>pmap</code>。在Linux，windows，OSX，freebsdSun，Solaris等系统上工作，最新的版本python是要高于2.6(Python 2.4 Python2.5 可以用2.1.3版本)</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先确定下当前系统有没有psutil模块</p>
<pre class="lang:python decode:true">import psutil</pre>

<p>如果有的话，就直接导入模块成功，如果没有，就会提示错误然后到官网上下载psutil-2.0.0.tar.gz源码包</p>
<pre class="lang:sh decode:true ">tar -zxf psutil-2.0.0.tar.gz &amp; cd psutil-2.0.0
python setup.py install</pre>

<p>也可以直接使用<span class="lang:sh decode:true  crayon-inline ">pip install psutil</span> 来安装</p>
<h1 id="系统相关功能"><a href="#系统相关功能" class="headerlink" title="系统相关功能"></a>系统相关功能</h1><h2 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h2><h3 id="cpu-times"><a href="#cpu-times" class="headerlink" title="cpu_times"></a>cpu_times</h3><pre class="lang:python decode:true">psutil.cpu_times(precpu=False) </pre>

<p>返回系统CPU运行时间的元组，时间为秒。</p>
<h3 id="cpu-percent"><a href="#cpu-percent" class="headerlink" title="cpu_percent"></a>cpu_percent</h3><pre class="lang:python decode:true ">psutil.cpu_percent(interval=None, percpu=False)</pre>

<p>返回一个浮点数，代表当前cpu的利用率的百分比，包括sy+user. 当<code>interval</code>为0或者None时，表示的是interval时间内的sys的利用率。 当<code>percpu</code>为True返回是每一个cpu的利用率。</p>
<h3 id="cpu-count"><a href="#cpu-count" class="headerlink" title="cpu_count"></a>cpu_count</h3><pre class="lang:python decode:true ">psutil.cpu_count()</pre>

<p>返回CPU的逻辑个数</p>
<pre class="lang:python decode:true ">psutil.cpu_count(logical=True)</pre>

<p>返回CPU的物理个数</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><pre class="lang:python decode:true ">psutil.virtual_memory()</pre>

<p>返回一个内存信息的元组，大小为字节</p>
<ul>
<li>total: 内存的总大小.</li>
<li>available: 可以用来的分配的内存，不同系统计算方式不同； Linux下的计算公式:free+ buffers +cached</li>
<li>percent: 已经用掉内存的百分比 (total - available) / total 100.</li>
<li>used: 已经用掉内存大小，不同系统计算方式不同</li>
<li>*free: 空闲未被分配的内存，Linux下不包括buffers和cached</li>
</ul>
<p>Platform-specific fields:</p>
<ul>
<li>active: (UNIX): 最近使用内存和正在使用内存。</li>
<li>inactive: (UNIX): 已经分配但是没有使用的内存</li>
<li>buffers: (Linux, BSD): 缓存，linux下的Buffers</li>
<li>cached:(Linux, BSD): 缓存，Linux下的cached.</li>
<li>wired: (BSD, OSX): 一直存在于内存中的部分，不会被移除</li>
<li>shared: (BSD): 缓存</li>
</ul>
<p>内存总大小不等于Used+available,在windows系统可用内存和空闲内存是用一个。</p>
<pre class="lang:default decode:true">psutil.swap_memory()</pre>

<p>返回系统的swap信息</p>
<ul>
<li>total: swap的总大小 单位为字节</li>
<li>used: 已用的swap大小 bytes</li>
<li>free: 空闲的swap大小 bytes</li>
<li>percent: 已用swap的百分比</li>
<li>sin: 从磁盘调入是swap的大小</li>
<li>sout: 从swap调出到disk的大小<blockquote>
<p><code>sin</code>，<code>sout</code>在windows<strong>没有意义</strong>。</p>
</blockquote>
</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><pre class="lang:python decode:true">psutil.disk_partitions(all=False)</pre>

<p>返回所有挂载的分区的信息的列表，列表中的每一项类似于df命令的格式输出，包括分区，挂载点，文件系统格式，挂载参数等，会忽略掉<code>/dev/shm</code>,<code>/proc/filesystem</code>等，windows上分区格式 “<code>removable</code>“, “<code>fixed</code>“, “<code>remote</code>“, “<code>cdrom</code>“, “<code>unmounted</code>“ or “<code>ramdisk</code>“。</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.disk_partitions()
[sdiskpart(device='/dev/sda3', mountpoint='/', fstype='ext4', opts='rw,errors=remount-ro'),
 sdiskpart(device='/dev/sda7', mountpoint='/home', fstype='ext4', opts='rw')]</pre>
<pre class="lang:python decode:true">psutil.disk_usage(path) </pre>

<p>返回硬盘，分区或者目录的使用情况，单位字节</p>
<p>如果不存在会报“<code>OSError</code>”错误。</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.disk_usage('/')
sdiskusage(total=21378641920, used=4809781248, free=15482871808, percent=22.5)</pre>
<pre class="lang:python decode:true ">psutil.disk_io_counters(perdisk=False)</pre>

<p>返回当前磁盘的io情况</p>
<ul>
<li>read_count: number of reads</li>
<li>write_count: number of writes</li>
<li>read_bytes: number of bytes read</li>
<li>write_bytes: number of bytes written</li>
<li>read_time: time spent reading from disk (in milliseconds)</li>
<li>write_time: time spent writing to disk (in milliseconds)</li>
</ul>
<h2 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h2><p>返回整个系统的网络信息</p>
<pre class="lang:python decode:true">psutil.net_io_counters(pernic=False)</pre>

<ul>
<li>bytes_sent: 发送的字节数</li>
<li>bytes_recv: 接收的字节数</li>
<li>packets_sent: 发送到数据包的个数</li>
<li>packets_recv: 接受的数据包的个数</li>
<li>errin:</li>
<li>errout: 发送数据包错误的总数</li>
<li>dropin: 接收时丢弃的数据包的总数</li>
<li>dropout: 发送时丢弃的数据包的总数(OSX和BSD系统总是0)</li>
</ul>
<p>如果 <code>pernic</code>值为True，会显示具体各个网卡的信息。</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.net_io_counters()
snetio(bytes_sent=14508483, bytes_recv=62749361, packets_sent=84311, packets_recv=94888, errin=0, errout=0, dropin=0, dropout=0)
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.net_io_counters(pernic=True)
{'lo': snetio(bytes_sent=547971, bytes_recv=547971, packets_sent=5075, packets_recv=5075, errin=0, errout=0, dropin=0, dropout=0),
'wlan0': snetio(bytes_sent=13921765, bytes_recv=62162574, packets_sent=79097, packets_recv=89648, errin=0, errout=0, dropin=0, dropout=0)}</pre>
<pre class="lang:python decode:true">psutil.net_connections(kind='inet') </pre>

<p>返回系统的整个socket连接的信息，可以选择查看哪些类型的连接信息，类似于netstat命令</p>
<p>&nbsp;</p>
<p><strong>fd</strong>:</p>
<p> <strong>family</strong>: the address family, either AF_INET, AF_INET6 or AF_UNIX.</p>
<p> <strong>type</strong>: the address type, either SOCK_STREAM or SOCK_DGRAM.</p>
<p> <strong>laddr</strong>: the local address as a (ip, port) tuple or a path in case of AF_UNIX sockets.</p>
<p> <strong>raddr</strong>: the remote address as a (ip, port) tuple or an absolute path in case of UNIX sockets. When the remote endpoint is not connected you’ll <strong>get an empty tuple (AF_INET*) or None (AF_UNIX). On Linux AF_UNIX sockets will always have this set to None. </strong>status<strong>: represents the status of a TCP connection. The return value is one of the psutil.CONN_* constants (a string). For UDP and UNIX </strong>sockets this is always going to be psutil.CONN_NONE.</p>
<p> <strong>pid</strong>: the PID of the process which opened the socket, if retrievable, else None. On some platforms (e.g. Linux) the availability of this field **changes depending on process privileges (root is needed).</p>
<p>参数kind的类型：</p>
<p> “inet” IPv4 and IPv6</p>
<p> “inet4” IPv4</p>
<p> “inet6” IPv6</p>
<p> “tcp” TCP</p>
<p> “tcp4” TCP over IPv4</p>
<p> “tcp6” TCP over IPv6</p>
<p> “udp” UDP</p>
<p> “udp4” UDP over IPv4</p>
<p> “udp6” UDP over IPv6</p>
<p> “unix” UNIX socket (both UDP and TCP protocols)</p>
<p> “all” the sum of all the possible families and protocols</p>
<pre><code>&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; psutil.net_connections()
[pconn(fd=115, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 48776), raddr=(&apos;93.186.135.91&apos;, 80), status=&apos;ESTABLISHED&apos;, pid=1254),
 pconn(fd=117, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 43761), raddr=(&apos;72.14.234.100&apos;, 80), status=&apos;CLOSING&apos;, pid=2987),
 pconn(fd=-1, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 60759), raddr=(&apos;72.14.234.104&apos;, 80), status=&apos;ESTABLISHED&apos;, pid=None),
 pconn(fd=-1, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 51314), raddr=(&apos;72.14.234.83&apos;, 443), status=&apos;SYN_SENT&apos;, pid=None)
 ...]`&lt;/pre&gt;

## Other system info

`psutil.users()`

 返回当前系统用户登录信息

**user**: 用户的名称

 **terminal**: 运行终端，tty还是pts等

 **host**: 登录的IP

 **started**: 登录了多长时间

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; psutil.users()
[suser(name=&apos;giampaolo&apos;, terminal=&apos;pts/2&apos;, host=&apos;localhost&apos;, started=1340737536.0),
 suser(name=&apos;giampaolo&apos;, terminal=&apos;pts/3&apos;, host=&apos;localhost&apos;, started=1340737792.0)]`&lt;/pre&gt;

`psutil.boot_time()`

 返回当前的时间

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil, datetime
&amp;gt;&amp;gt;&amp;gt; psutil.boot_time()
1389563460.0
&amp;gt;&amp;gt;&amp;gt; datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
&apos;2014-01-12 22:51:00&apos;`&lt;/pre&gt;

* * *

## Processes

### Functions

`psutil.pids()`

 返回当前运行的进程pid列表

`psutil.pid_exists(pid)`

 是否存在次pid，快速的验证方式`pid in psutil.pids()`

`psutil.process_iter()`

 返回一个包含Process对象的迭代器。每一个对象只创建一次，创建后缓存起来。当一个进程更新时，会更新缓存。遍历所有进程首选psutil.pids().迭代器排序是根据pid。

&lt;pre&gt;`import psutil

for proc in psutil.process_iter():
    try:
        pinfo = proc.as_dict(attrs=[&apos;pid&apos;, &apos;name&apos;])
    except psutil.NoSuchProcess:
        pass
    else:
        print(pinfo)`&lt;/pre&gt;

`psutil.wait_procs(procs, timeout=None, callback=None)`

Convenience function which waits for a list of Process instances to terminate. Return a (gone, alive) tuple indicating which processes are gone and which ones are still alive. The gone ones will have a new returncode attribute indicating process exit status (it may be None). callback is a function which gets called every time a process terminates (a Process instance is passed as callback argument). Function will return as soon as all processes terminate or when timeout occurs. Tipical use case is:

send SIGTERM to a list of processes

 give them some time to terminate

 send SIGKILL to those ones which are still alive

Example:

&lt;pre&gt;`import psutil

def on_terminate(proc):
    print(&quot;process {} terminated&quot;.format(proc))

procs = [...]  # a list of Process instances
for p in procs:
    p.terminate()
gone, alive = wait_procs(procs, timeout=3, callback=on_terminate)
for p in alive:
    p.kill()`&lt;/pre&gt;

### Exceptions

`class psutil.Error`

 基础异常，psutil的其他异常都继承这个

`class psutil.NoSuchProcess(pid, name=None, msg=None)`

 当进程不在进程列表中，或者进程不存在时触发。

`class psutil.AccessDenied(pid=None, name=None, msg=None)`

 没有权限时，被触发

`class psutil.TimeoutExpired(seconds, pid=None, name=None, msg=None)`

 当Process.wait() 超时，并且Process 一直在运行时.

# psutil

标签（空格分隔）： Python

* * *

## Process class

`class psutil.Process(pid=None)`

 Process类是一个带有pid的进程。如果没有指定pid，则默认的进程为`os.getpid()`所得进程。Process会触发`NoSuchProcess`（当进程不存在时）和`AccessDenied`异常，

**注意**

&gt; Process是通过pid绑定的。如果在一个Process实例，在psutil运行中pid进程死掉，而
</code></pre><blockquote>
<pre><code>这个pid又绑定给了别的新的进程。为了保证Process的安全性可以通过pid+createion time

方式来确认进程是否是同一个。
</code></pre></blockquote>
<pre><code>`pid`

 进程的PID

`ppid()`

 父进程pid. On Windows the return value is cached after first call.

`name()`

 进程名.

`exe()`

 进程运行命令的绝对路径。

`cmdline()`

 The command line this process has been called with.

`create_time()`

 进程创建时间

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil, datetime
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.create_time()
1307289803.47
&amp;gt;&amp;gt;&amp;gt; datetime.datetime.fromtimestamp(p.create_time()).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
&apos;2011-03-05 18:03:52&apos;`&lt;/pre&gt;

`as_dict(attrs=None, ad_value=None)`

 返回进程信息的哈希字典的实用方法，`attrs`指定的值必须是Process的属性值，例如（[&apos;cpu_times&apos;,&apos;name&apos;]）

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.as_dict(attrs=[&apos;pid&apos;, &apos;name&apos;, &apos;username&apos;])
{&apos;username&apos;: &apos;giampaolo&apos;, &apos;pid&apos;: 12366, &apos;name&apos;: &apos;python&apos;}`&lt;/pre&gt;

`parent()`

 返回父进程，如果不存在父进程，则返回None。

`status()`

 进程当前运行状态，string形式。

`cwd()`

 进程运行的所在的目录

`username()`

 哪个用户下运行的进程

`uids()`

 返回real=uid，effective，saved用户的uid

**Availability**: UNIX

`gids()`

**Availability**: UNIX

`terminal()`

 The terminal associated with this process, if any, else None. This is similar to “tty” command but can be used for every process PID.

**Availability**: UNIX

`nice(value=None)`

 获取或者设置进程的nice值，

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.nice(10)  # set
&amp;gt;&amp;gt;&amp;gt; p.nice()  # get
10
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

在windows系统上，只能通过`GetProrityClass`和`SetPriorityClass`的`psutil.*_PRIORITY_CLASS`包含的值来设定

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; p.nice(psutil.HIGH_PRIORITY_CLASS)`&lt;/pre&gt;

`ionice(ioclass=None, value=None)`

 获取或者设置进程I/O的优先级。Linux上的`ioclass`的值`psutil.IOPRO_CLASS_*`值在0-7，windows 2 为正常，1为优先级低，0为非常低。

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.ionice(psutil.IOPRIO_CLASS_IDLE)  # set
&amp;gt;&amp;gt;&amp;gt; p.ionice()  # get
pionice(ioclass=3, value=0)
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

`rlimit(resource, limits=None)`

 Get or set process resource limits (see man prlimit). resource is one of the psutil.RLIMIT_* constants. limits is a (soft, hard) tuple. This is the same as resource.getrlimit() and resource.setrlimit() but can be used for every process PID and only on Linux. Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; # process may open no more than 128 file descriptors
&amp;gt;&amp;gt;&amp;gt; p.rlimit(psutil.RLIMIT_NOFILE, (128, 128))
&amp;gt;&amp;gt;&amp;gt; # process may create files no bigger than 1024 bytes
&amp;gt;&amp;gt;&amp;gt; p.rlimit(psutil.RLIMIT_FSIZE, (1024, 1024))
&amp;gt;&amp;gt;&amp;gt; # get
&amp;gt;&amp;gt;&amp;gt; p.rlimit(psutil.RLIMIT_FSIZE)
(1024, 1024)
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

**Availability**: Linux

`io_counters()`

 返回这个进程的IO情况

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.io_counters()
pio(read_count=454556, write_count=3456, read_bytes=110592, write_bytes=0)`&lt;/pre&gt;

**Availability**: all platforms except OSX

`num_ctx_switches()`

 The number voluntary and involuntary context switches performed by this process.

`num_fds()`

 The number of file descriptors used by this process.

**Availability**: UNIX

`num_handles()`

 The number of handles used by this process.

**Availability**: Windows

`num_threads()`

 The number of threads currently used by this process.

`threads()`

 Return threads opened by process as a list of namedtuples including thread id and thread CPU times (user/system).

`cpu_times()`

 Return a tuple whose values are process CPU user and system times which means the amount of time expressed in seconds that a process has spent in user / system mode. This is similar to os.times() but can be used for every process PID.

`cpu_percent(interval=None)`

 Return a float representing the process CPU utilization as a percentage. When interval is &amp;gt; 0.0 compares process times to system CPU times elapsed before and after the interval (blocking). When interval is 0.0 or None compares process times to system CPU times elapsed since last call, returning immediately. That means the first time this is called it will return a meaningless 0.0 value which you are supposed to ignore. In this case is recommended for accuracy that this function be called a second time with at least 0.1 seconds between calls. Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # blocking
&amp;gt;&amp;gt;&amp;gt; p.cpu_percent(interval=1)
2.0
&amp;gt;&amp;gt;&amp;gt; # non-blocking (percentage since last call)
&amp;gt;&amp;gt;&amp;gt; p.cpu_percent(interval=None)
2.9
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

Note a percentage &amp;gt; 100 is legitimate as it can result from a process with multiple threads running on different CPU cores.

 Warning the first time this method is called with interval = 0.0 or None it will return a meaningless 0.0 value which you are supposed to ignore.

 cpu_affinity(cpus=None)

 Get or set process current CPU affinity. CPU affinity consists in telling the OS to run a certain process on a limited set of CPUs only. The number of eligible CPUs can be obtained with list(range(psutil.cpu_count())).

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; psutil.cpu_count()
4
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity()  # get
[0, 1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity([0])  # set; from now on, process will run on CPU #0 only
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity()
[0]
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # reset affinity against all CPUs
&amp;gt;&amp;gt;&amp;gt; all_cpus = list(range(psutil.cpu_count()))
&amp;gt;&amp;gt;&amp;gt; p.cpu_affinity(all_cpus)
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

**Availability**: Linux, Windows, BSD

Changed in version 2.2.0: added support for FreeBSD

`memory_info()`

 Return a tuple representing RSS (Resident Set Size) and VMS (Virtual Memory Size) in bytes. On UNIX rss and vms are the same values shown by ps. On Windows rss and vms refer to “Mem Usage” and “VM Size” columns of taskmgr.exe. For more detailed memory stats use memory_info_ex().

`memory_info_ex()`

 Return a namedtuple with variable fields depending on the platform representing extended memory information about the process. All numbers are expressed in bytes.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Linux&lt;/th&gt;
&lt;th&gt;OSX&lt;/th&gt;
&lt;th&gt;BSD&lt;/th&gt;
&lt;th&gt;SunOS&lt;/th&gt;
&lt;th&gt;Windows&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;rss&lt;/td&gt;
&lt;td&gt;num_page_faults&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;vms&lt;/td&gt;
&lt;td&gt;peak_wset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shared&lt;/td&gt;
&lt;td&gt;pfaults&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;wset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;pageins&lt;/td&gt;
&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;peak_paged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lib&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;stack&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;paged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;peak_nonpaged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dirty&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;nonpaged_pool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;pagefile&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;peak_pagefile&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;private&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Windows metrics are extracted from PROCESS_MEMORY_COUNTERS_EX structure. Example on Linux:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.memory_info_ex()
pextmem(rss=15491072, vms=84025344, shared=5206016, text=2555904, lib=0, data=9891840, dirty=0)`&lt;/pre&gt;

`memory_percent()`

 Compare physical system memory to process resident memory (RSS) and calculate process memory utilization as a percentage.

`memory_maps(grouped=True)`

 Return process’s mapped memory regions as a list of nameduples whose fields are variable depending on the platform. As such, portable applications should rely on namedtuple’s path and rss fields only. This method is useful to obtain a detailed representation of process memory usage as explained here. If grouped is True the mapped regions with the same path are grouped together and the different memory fields are summed. If grouped is False every mapped region is shown as a single entity and the namedtuple will also include the mapped region’s address space (addr) and permission set (perms). See examples/pmap.py for an example application.

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.memory_maps()
[pmmap_grouped(path=&apos;/lib/x8664-linux-gnu/libutil-2.15.so&apos;, rss=16384, anonymous=8192, swap=0),
 pmmap_grouped(path=&apos;/lib/x8664-linux-gnu/libc-2.15.so&apos;, rss=6384, anonymous=15, swap=0),
 pmmap_grouped(path=&apos;/lib/x8664-linux-gnu/libcrypto.so.0.1&apos;, rss=34124, anonymous=1245, swap=0),
 pmmap_grouped(path=&apos;[heap]&apos;, rss=54653, anonymous=8192, swap=0),
 pmmap_grouped(path=&apos;[stack]&apos;, rss=1542, anonymous=166, swap=0),
 ...]
&amp;gt;&amp;gt;&amp;gt;`&lt;/pre&gt;

`children(recursive=False)`

 Return the children of this process as a list of Process objects, pre-emptively checking whether PID has been reused. If recursive is True return all the parent descendants. Example assuming A == this process:

A ─┐

 │

 ├─ B (child) ─┐

 │ └─ X (grandchild) ─┐

 │ └─ Y (great grandchild)

 ├─ C (child)

 └─ D (child)

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt; p.children()
B, C, D
&amp;gt;&amp;gt;&amp;gt; p.children(recursive=True)
B, X, Y, C, D`&lt;/pre&gt;

Note that in the example above if process X disappears process Y won’t be returned either as the reference to process A is lost.

`open_files()`

 Return regular files opened by process as a list of namedtuples including the absolute file name and the file descriptor number (on Windows this is always -1). Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; f = open(&apos;file.ext&apos;, &apos;w&apos;)
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process()
&amp;gt;&amp;gt;&amp;gt; p.open_files()
[popenfile(path=&apos;/home/giampaolo/svn/psutil/file.ext&apos;, fd=3)]`&lt;/pre&gt;

`connections(kind=&quot;inet&quot;)`

 Return socket connections opened by process as a list of namedutples. To get system-wide connections use psutil.net_connections(). Every namedtuple provides 6 attributes:

**fd:** the socket file descriptor. This can be passed to socket.fromfd() to obtain a usable socket object. This is only available on UNIX; on Windows -1 is always returned.

 **family:** the address family, either AF_INET, AF_INET6 or AF_UNIX.

 **type:** the address type, either SOCK_STREAM or SOCK_DGRAM.

 **laddr:** the local address as a (ip, port) tuple or a path in case of AF_UNIX sockets.

 **raddr:** the remote address as a (ip, port) tuple or an absolute path in case of UNIX sockets. When the remote endpoint is not connected you’ll get an empty tuple (AF_INET) or None (AF_UNIX). On Linux AF_UNIX sockets will always have this set to None.

 **status:** represents the status of a TCP connection. The return value is one of the psutil.CONN_* constants. For UDP and UNIX sockets this is always going to be `psutil.CONN_NONE`.

The kind parameter is a string which filters for connections that fit the following criteria:

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Kind value&lt;/th&gt;
&lt;th&gt;Connections using&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;“inet”&lt;/td&gt;
&lt;td&gt;IPv4 and IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“inet4”&lt;/td&gt;
&lt;td&gt;IPv4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“inet6”&lt;/td&gt;
&lt;td&gt;IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“tcp”&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“tcp4”&lt;/td&gt;
&lt;td&gt;TCP over IPv4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“tcp6”&lt;/td&gt;
&lt;td&gt;TCP over IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“udp”&lt;/td&gt;
&lt;td&gt;UDP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“udp4”&lt;/td&gt;
&lt;td&gt;UDP over IPv4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“udp6”&lt;/td&gt;
&lt;td&gt;UDP over IPv6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“unix”&lt;/td&gt;
&lt;td&gt;UNIX socket (both UDP and TCP protocols)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“all”&lt;/td&gt;
&lt;td&gt;the sum of all the possible families and protocols&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Example:

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; p = psutil.Process(1694)
&amp;gt;&amp;gt;&amp;gt; p.name()
&apos;firefox&apos;
&amp;gt;&amp;gt;&amp;gt; p.connections()
[pconn(fd=115, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 48776), raddr=(&apos;93.186.135.91&apos;, 80), status=&apos;ESTABLISHED&apos;),
 pconn(fd=117, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 43761), raddr=(&apos;72.14.234.100&apos;, 80), status=&apos;CLOSING&apos;),
 pconn(fd=119, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 60759), raddr=(&apos;72.14.234.104&apos;, 80), status=&apos;ESTABLISHED&apos;),
 pconn(fd=123, family=2, type=1, laddr=(&apos;10.0.0.1&apos;, 51314), raddr=(&apos;72.14.234.83&apos;, 443), status=&apos;SYN_SENT&apos;)]`&lt;/pre&gt;

`is_running()`

 判断进程是否存活

 Return whether the current process is running in the current process list. This is reliable also in case the process is gone and its PID reused by another process, therefore it must be preferred over doing psutil.pid_exists(p.pid).

Note this will return True also if the process is a zombie (p.status() == psutil.STATUS_ZOMBIE).

 `send_signal(signal)`

 发送新号给进程

 Send a signal to process (see signal module constants) pre-emptively checking whether PID has been reused. This is the same as os.kill(pid, sig). On Windows only SIGTERM is valid and is treated as an alias for kill().

`suspend()`

 Suspend process execution with SIGSTOP signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGSTOP). On Windows this is done by suspending all process threads execution.

`resume()`

 Resume process execution with SIGCONT signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGCONT). On Windows this is done by resuming all process threads execution.

`terminate()`

 Terminate the process with SIGTERM signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGTERM). On Windows this is an alias for kill().

`kill()`

 Kill the current process by using SIGKILL signal pre-emptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGKILL). On Windows this is done by using TerminateProcess.

`wait(timeout=None)`

 Wait for process termination and if the process is a children of the current one also return the exit code, else None. On Windows there’s no such limitation (exit code is always returned). If the process is already terminated immediately return None instead of raising NoSuchProcess. If timeout is specified and process is still alive raise TimeoutExpired exception. It can also be used in a non-blocking fashion by specifying timeout=0 in which case it will either return immediately or raise TimeoutExpired. To wait for multiple processes use psutil.wait_procs().

### Popen class

`class psutil.Popen(*args, **kwargs)`

 A more convenient interface to stdlib subprocess.Popen. It starts a sub process and deals with it exactly as when using subprocess.Popen but in addition it also provides all the methods of psutil.Process class in a single interface. For method names common to both classes such as send_signal(), terminate() and kill() psutil.Process implementation takes precedence. For a complete documentation refer to subprocess module documentation.

Note Unlike subprocess.Popen this class pre-emptively checks wheter PID has been reused on send_signal(), terminate() and kill() so that you don’t accidentally terminate another process, fixing [http://bugs.python.org/issue6973](http://bugs.python.org/issue6973).

&lt;pre&gt;`&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import psutil
&amp;gt;&amp;gt;&amp;gt; from subprocess import PIPE
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; p = psutil.Popen([&quot;/usr/bin/python&quot;, &quot;-c&quot;, &quot;print(&apos;hello&apos;)&quot;], stdout=PIPE)
&amp;gt;&amp;gt;&amp;gt; p.name()
&apos;python&apos;
&amp;gt;&amp;gt;&amp;gt; p.username()
&apos;giampaolo&apos;
&amp;gt;&amp;gt;&amp;gt; p.communicate()
(&apos;hello\n&apos;, None)
&amp;gt;&amp;gt;&amp;gt; p.wait(timeout=2)
0
&amp;gt;&amp;gt;&amp;gt;
</code></pre><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><blockquote>
<p>psutil.STATUS_RUNNING</p>
<p> psutil.STATUS_SLEEPING</p>
<p> psutil.STATUS_DISK_SLEEP</p>
<p> psutil.STATUS_STOPPED</p>
<p> psutil.STATUS_TRACING_STOP</p>
<p> psutil.STATUS_ZOMBIE</p>
<p> psutil.STATUS_DEAD</p>
<p> psutil.STATUS_WAKE_KILL</p>
<p> psutil.STATUS_WAKING</p>
<p> psutil.STATUS_IDLE</p>
<p> psutil.STATUS_LOCKED</p>
<p> psutil.STATUS_WAITING</p>
</blockquote>
<p>A set of strings representing the status of a process. Returned by psutil.Process.status().</p>
<blockquote>
<p>psutil.CONN_ESTABLISHED</p>
<p> psutil.CONN_SYN_SENT</p>
<p> psutil.CONN_SYN_RECV</p>
<p> psutil.CONN_FIN_WAIT1</p>
<p> psutil.CONN_FIN_WAIT2</p>
<p> psutil.CONN_TIME_WAIT</p>
<p> psutil.CONN_CLOSE</p>
<p> psutil.CONN_CLOSE_WAIT</p>
<p> psutil.CONN_LAST_ACK</p>
<p> psutil.CONN_LISTEN</p>
<p> psutil.CONN_CLOSING</p>
<p> psutil.CONN_NONE</p>
<p> psutil.CONN_DELETE_TCB(Windows)</p>
<p> psutil.CONN_IDLE(Solaris)</p>
<p> psutil.CONN_BOUND(Solaris)</p>
</blockquote>
<p>A set of strings representing the status of a TCP connection. Returned by psutil.Process.connections() (status field).</p>
<blockquote>
<p>psutil.ABOVE_NORMAL_PRIORITY_CLASS</p>
<p> psutil.BELOW_NORMAL_PRIORITY_CLASS</p>
<p> psutil.HIGH_PRIORITY_CLASS</p>
<p> psutil.IDLE_PRIORITY_CLASS</p>
<p> psutil.NORMAL_PRIORITY_CLASS</p>
<p> psutil.REALTIME_PRIORITY_CLASS</p>
<p> A set of integers representing the priority of a process on Windows (see MSDN documentation). They can be used in conjunction with psutil.Process.nice() to get or set process priority.</p>
</blockquote>
<p><strong>Availability</strong>: Windows</p>
<p>psutil.IOPRIO_CLASS_NONE</p>
<p> psutil.IOPRIO_CLASS_RT</p>
<p> psutil.IOPRIO_CLASS_BE</p>
<p> psutil.IOPRIO_CLASS_IDLE</p>
<p> A set of integers representing the I/O priority of a process on Linux. They can be used in conjunction with psutil.Process.ionice() to get or set process I/O priority. IOPRIO_CLASS_NONE and IOPRIO_CLASS_BE (best effort) is the default for any process that hasn’t set a specific I/O priority. IOPRIO_CLASS_RT (real time) means the process is given first access to the disk, regardless of what else is going on in the system. IOPRIO_CLASS_IDLE means the process will get I/O time when no-one else needs the disk. For further information refer to manuals of ionice command line utility or ioprio_get system call.</p>
<p><strong>Availability</strong>: Linux</p>
<blockquote>
<p>psutil.RLIMIT_INFINITY</p>
<p> psutil.RLIMIT_AS</p>
<p> psutil.RLIMIT_CORE</p>
<p> psutil.RLIMIT_CPU</p>
<p> psutil.RLIMIT_DATA</p>
<p> psutil.RLIMIT_FSIZE</p>
<p> psutil.RLIMIT_LOCKS</p>
<p> psutil.RLIMIT_MEMLOCK</p>
<p> psutil.RLIMIT_MSGQUEUE</p>
<p> psutil.RLIMIT_NICE</p>
<p> psutil.RLIMIT_NOFILE</p>
<p> psutil.RLIMIT_NPROC</p>
<p> psutil.RLIMIT_RSS</p>
<p> psutil.RLIMIT_RTPRIO</p>
<p> psutil.RLIMIT_RTTIME</p>
<p> psutil.RLIMIT_RTPRIO</p>
<p> psutil.RLIMIT_SIGPENDING</p>
<p> psutil.RLIMIT_STACK</p>
<p> Constants used for getting and setting process resource limits to be used in conjunction with psutil.Process.rlimit(). See man prlimit for futher information.</p>
</blockquote>
<p><strong>Availability</strong>: Linux</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/12/12/e7-ab-99-e7-82-b9-e8-bf-81-e7-a7-bb-e5-88-b0-e6-96-b0-e5-8a-a0-e5-9d-a1/" class="prev">上一篇</a><a href="/2016/11/28/bcrypt-e7-9a-84-e4-bd-bf-e7-94-a8-e6-96-b9-e6-b3-95/" class="next">下一篇</a></div><div class="copyright"><p>© 2013 - 2017 <a href="http://kidozh.com">kido zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>