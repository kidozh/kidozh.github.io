<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [Django]模型字段参考 · kidozh</title><meta name="description" content="[Django]模型字段参考 - kido zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://kidozh.com/atom.xml" title="kidozh"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1793490853" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/kidozh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[Django]模型字段参考</h1><div class="post-info">2016年2月1日</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文档包含了Django提供的全部模型字段的字段选项 和 字段类型的API参考。</p>
<p>如果内建的字段不能满足你的需要，你可以尝试对特定国家和文化有效的包含配套代码的 <a href="https://django-localflavor.readthedocs.org/" target="_blank" rel="external">django-localflavor</a>。当然，你也可以很容易的编写你自定义的字段。</p>
<p>严格意义上来讲， model 是定义在<code>django.db.models.fields</code>里面，但为了使用方便，它们被导入到 <code>django.db.models</code>中；标准上，我们导入<span class="lang:python decode:true  crayon-inline ">from django.db import models</span> ，然后使用 <code>models.&amp;lt;Foo&amp;gt;Field</code>的形式使用字段。</p>
<h1 id="字段选项"><a href="#字段选项" class="headerlink" title="字段选项"></a>字段选项</h1><p>下列参数是全部字段类型都可用的，都是可选的。</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p><code>Field.null</code></p>
<p>如果为<code>True</code>，Django 将空值以<code>NULL</code> 存储到数据库中。默认值是 <code>False</code>。</p>
<p>字符串字段例如<code>CharField</code> 和<code>TextField</code> 要避免使用<code>null</code>，因为空字符串值将始终储存为空字符串而不是<code>NULL</code>。如果字符串字段的<code>null=True</code>，那意味着对于“无数据”有两个可能的值：<code>NULL</code> 和空字符串。在大多数情况下，对于“无数据”声明两个值是赘余的，Django 的惯例是使用空字符串而不是<code>NULL</code>。</p>
<p>无论是字符串字段还是非字符串字段，如果你希望在表单中允许空值，你将还需要设置<code>blank=True</code>，因为null 仅仅影响数据库存储（参见<a href="http://python.usyiyi.cn/django_182/ref/models/fields.html#django.db.models.Field.blank" target="_blank" rel="external">blank</a>）。</p>
<p>注意：</p>
<p>在使用Oracle 数据库时，数据库将存储<code>NULL</code> 来表示空字符串，而与这个属性无关。</p>
<p>如果你希望<code>BooleanField</code> 接受null 值，请用 <code>NullBooleanField</code> 代替。</p>
<h2 id="blank"><a href="#blank" class="headerlink" title="blank"></a>blank</h2><p><code>Field.blank</code></p>
<p>如果为<code>True</code>，则该字段允许为空白。 默认值是 <code>False</code>。</p>
<p>注意它与<code>null</code>不同。<code>null</code> 纯粹是数据库范畴的概念，而<code>blank</code> 是数据验证范畴的。如果字段设置<code>blank=True</code>，表单验证时将允许输入空值。如果字段设置<code>blank=False</code>，则该字段为必填。</p>
<h2 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h2><p><code>Field.choices</code></p>
<p>它是一个可迭代的结构(比如，列表或是元组)，由可迭代的二元组组成(比如<span class="lang:python decode:true  crayon-inline ">[(A, B), (A, B) …]</span> )，用来给这个字段提供选择项。如果设置了 <code>choices</code> ，默认表格样式就会显示选择框，而不是标准的文本框，而且这个选择框的选项就是 <code>choices</code> 中的元组。</p>
<p>每个元组中的第一个元素，是存储在数据库中的值；第二个元素是该选项更易理解的描述。 比如:</p>
<pre class="lang:python decode:true">YEAR_IN_SCHOOL_CHOICES = (
    ('FR', 'Freshman'),
    ('SO', 'Sophomore'),
    ('JR', 'Junior'),
    ('SR', 'Senior'),
)</pre>

<p> 一般来说，最好在模型类内部定义<code>choices</code>，然后再给每个值定义一个合适名字的常量。</p>
<pre class="lang:python decode:true">from django.db import models

class Student(models.Model):
    FRESHMAN = 'FR'
    SOPHOMORE = 'SO'
    JUNIOR = 'JR'
    SENIOR = 'SR'
    YEAR_IN_SCHOOL_CHOICES = (
        (FRESHMAN, 'Freshman'),
        (SOPHOMORE, 'Sophomore'),
        (JUNIOR, 'Junior'),
        (SENIOR, 'Senior'),
    )
    year_in_school = models.CharField(max_length=2,
                                      choices=YEAR_IN_SCHOOL_CHOICES,
                                      default=FRESHMAN)

    def is_upperclass(self):
        return self.year_in_school in (self.JUNIOR, self.SENIOR)</pre>

<p> 尽管你可以在模型类的外部定义choices然后引用它，在模型类中定义choices和其每个<code>choice</code>的name可以保存所有的关于应用到此信息的类的信息， 也使得choices更容易被应用（例如， <code>Student.SOPHOMORE</code> 可以在任何引入Student 模型的位置生效)。</p>
<p>你也可以归类可选的<code>choices</code>到已命名的组中用来达成组织整理的目的:</p>
<pre class="lang:python decode:true">MEDIA_CHOICES = (
    ('Audio', (
            ('vinyl', 'Vinyl'),
            ('cd', 'CD'),
        )
    ),
    ('Video', (
            ('vhs', 'VHS Tape'),
            ('dvd', 'DVD'),
        )
    ),
    ('unknown', 'Unknown'),
)</pre>

<p> 每个元组的第一个元素是组的名字。第二个元素是一组可迭代的二元元组，每一个二元元组包含一个值和一个给人看的名字构成一个选项。分组的选项可能会和未分组的选项合在同一个<code>list</code>中。 （就像例中的<code>unknown</code>选项）。</p>
<p>对于每个有choices set的模型字段, Django 将会加入一个通过该字段现在的值取回给人看的名字的方法。参见数据库API文档中的<code>get_FOO_display()</code>。</p>
<p>请注意<code>choices</code>可以是任何可迭代的对象 – 不是必须是列表或者元组。这一点使你可以动态的构建<code>choices</code>。但是如果你发现你自己搞不定动态的<code>choices</code>，你最好还是使用<code>ForeignKey</code>来构建一个合适的数据库表。<code>choices</code>意味着那些变动不多的静态数据，如果有的（变动）话。</p>
<p>除非字段中默认了<code>blank=False</code>，那么<code>---------</code>就会在选择框中被渲染出来。你也可以向元祖中添加一个包含<code>None</code>的<code>choices</code>来覆盖这个行为（比如：<code>(None, &#39;Your String For Display&#39;)</code>）。</p>
<h2 id="db-column"><a href="#db-column" class="headerlink" title="db_column"></a>db_column</h2><p><code>Field.db_column</code></p>
<p>数据库中用来表征该字段的名称。如果未指定，那么Django将会使用<code>Field</code>名作为字段名.</p>
<p>如果你的数据库列名为SQL语句的保留字，或者是包含不能作为Python 变量名的字符，很明显地如连字符，仍然可以的。Django 会在后台给列名和表名加上双引号。</p>
<h2 id="db-index"><a href="#db-index" class="headerlink" title="db_index"></a>db_index</h2><p><code>Field.db_index</code></p>
<p>若值为 <code>True</code>, 则 <code>django-admin sqlindexes</code> 将会为此字段输出 <code>CREATE INDEX</code> 语句。（译注：为此字段创建索引）</p>
<h2 id="db-tablespace"><a href="#db-tablespace" class="headerlink" title="db_tablespace"></a>db_tablespace</h2><p><code>Field.db_tablespace</code></p>
<p>如果该字段有索引的话，<code>database tablespace</code>的名称用作该字段的索引。 如果<code>DEFAULT_INDEX_TABLESPACE</code> 已经设置，则默认值是由<code>DEFAULT_INDEX_TABLESPACE</code>指定, 如果没有设置则由 <code>db_tablespace</code> 指定。如果后台数据库不支持表空间，或者索引，则该选项被忽略。</p>
<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p><code>Field.default</code></p>
<p>该字段的默认值. 它可以是一个值或者一个可调用对象. 如果是一个可调用对象，那么在每一次创建新对象的时候，它将会调用一次.</p>
<p>这个默认值不可以是一个可变对象（如字典，列表，等等）,因为对于所有模型的一个新的实例来说，它们指向同一个引用。或者，把他们包装为一个可调用的对象。例如，你有一个自定义的<code>JSONField</code>，并且想指定一个特定的字典值，可以如下使用：</p>
<pre class="lang:python decode:true">def contact_default():
    return {"email": "to1@example.com"}

contact_info = JSONField("ContactInfo", default=contact_default)</pre>

<p> 请注意<code>lambdas</code> 函数不可作为如 <code>default</code> 这类可选参数的值.因为它们无法被 <code>migrations</code>命令序列化. 请参见文档其他部分。</p>
<p>默认值会在新实例创建并且没有给该字段提供值时使用。如果字段为主键，默认值也会在设置为<a id="more"></a><code>None</code>时使用。</p>
<p><code>Changed in Django 1.8:</code></p>
<p>之前的版本不会使用<code>None</code>作为主键 </p>
<h2 id="editable"><a href="#editable" class="headerlink" title="editable"></a>editable</h2><p><code>Field.editable</code></p>
<p>如果为<code>False</code>, 这个字段将不会出现在<code>admin</code>或者其他 <code>ModelForm</code>. 他们也会跳过 模型验证. 默认是<code>True</code>.</p>
<h2 id="error-messages"><a href="#error-messages" class="headerlink" title="error_messages"></a>error_messages</h2><p><code>Field.error_messages</code></p>
<p><code>error_messages</code> 参数能够让你重写默认抛出的错误信息。通过指定<code>key</code>来确认你要重写的错误信息。</p>
<p><code>error_messages</code> 的 <code>key</code> 值包括 <code>null</code>, <code>blank</code>, <code>invalid</code>, <code>invalid_choice</code>, <code>unique</code>, 和 <code>unique_for_date</code>. 其余的 <code>error_messages</code> 的 <code>keys</code> 是不一样的在不同的章节下 <code>Field types</code> 。</p>
<p><code>New in Django 1.7.</code></p>
<p>这个 <code>unique_for_date</code> 的 <code>error_messages</code> 的<code>key</code> 是在 1.7 中加的。</p>
<h2 id="help-text"><a href="#help-text" class="headerlink" title="help_text"></a>help_text</h2><p><code>Field.help_text</code></p>
<p>额外的 ‘<code>help</code>‘ 文本被显示在表单控件中  <code>form</code>。如果你没有字表单字段中使用，它对文档事件很有帮助。</p>
<p>注意这 不 会自动添加 <code>HTML</code> 标签。需要你在 <code>help_text</code> 包含自己需要的格式。例如:</p>
<pre class="lang:python decode:true">help_text="Please use the following format: &lt;em&gt;YYYY-MM-DD&lt;/em&gt;."</pre>

<p>另外, 你可以使用简单文本和<code>django.utils.html.escape()</code>以避免任何HTML特定的字符。为了防止CSRF攻击，需要保证来自不可信用户的所有的帮助文本能够被编码。</p>
<h2 id="primary-key"><a href="#primary-key" class="headerlink" title="primary_key"></a>primary_key</h2><p><code>Field.primary_key</code></p>
<p>若为 <!--more--><code>True</code>, 则该字段会成为模型的主键字段。</p>
<p>如果你没有在模型的任何字段上指定 <code>primary_key=True</code>, Django会自动添加一个 <code>AutoField</code> 字段来充当主键。 所以除非你想要覆盖默认的主键行为，否则不需要在任何字段上设定<code>primary_key=True</code> 。更多内容 请参考<a href="http://python.usyiyi.cn/django_182/topics/db/models.html#automatic-primary-key-fields" target="_blank" rel="external">Automatic primary key fields</a>.</p>
<p><code>primary_key=True</code> 暗含着<code>null=False</code> 和<code>unique=True</code>. 一个对象上只能拥有一个主键.</p>
<p>主键字段是只读的。如果你改变了一个已存在对象上的主键并且保存的话，会创建一个新的对象，而不是覆盖旧的.</p>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><code>Field.unique</code></p>
<p>如果为 <code>True</code>, 这个字段在表中必须有唯一值.</p>
<p>这是一个在数据库级别的强制性动作,并且通过模型来验证。如果你试图用一个重复的值来保存<code>unique</code> 字段，那么一个<code>django.db.IntegrityError</code>就会通过模型的<code>save()</code> 函数抛出来。</p>
<p>除了<code>ManyToManyField</code>、<code>OneToOneField</code>和<code>FileField</code> 以外的其他字段类型都可以使用这个设置。</p>
<p>注意当设置<code>unique</code> 为<code>True</code> 时，你不需要再指定 <code>db_index</code>，因为<code>unique</code> 本身就意味着一个索引的创建。</p>
<h2 id="unique-for-date"><a href="#unique-for-date" class="headerlink" title="unique_for_date"></a>unique_for_date</h2><p><code>Field.unique_for_date</code></p>
<p>当设置它为<code>DateField</code> 和<code>DateTimeField</code> 字段的名称时，表示要求该字段对于相应的日期字段值是唯一的。</p>
<p>例如，你有一个title 字段设置<code>unique_for_date=&quot;pub_date&quot;</code>，那么Django 将不允许两个记录具有相同的<code>title</code> 和<code>pub_date</code>。</p>
<p>注意，如果你将它设置为<code>DateTimeField</code>，只会考虑其日期部分。此外，如果<code>USE_TZ</code> 为<code>True</code>，检查将以对象保存时的当前的时区 进行。</p>
<p>这是在模型验证期间通过<code>Model.validate_unique()</code> 强制执行的，而不是在数据库层级进行验证。如果<code>unique_for_date</code> 约束涉及的字段不是<code>ModelForm</code>（例如，exclude中列出的字段或者设置了<code>editable=False</code>），<code>Model.validate_unique()</code> 将忽略该特殊的约束。</p>
<h2 id="unique-for-month"><a href="#unique-for-month" class="headerlink" title="unique_for_month"></a>unique_for_month</h2><p><code>Field.unique_for_month</code></p>
<p>类似<code>unique_for_date</code>，只是要求字段对于月份是唯一的。</p>
<h2 id="unique-for-year"><a href="#unique-for-year" class="headerlink" title="unique_for_year"></a>unique_for_year</h2><p><code>Field.unique_for_year</code></p>
<p>类似<code>unique_for_date</code> 和 <code>unique_for_month</code>。</p>
<h2 id="verbose-name"><a href="#verbose-name" class="headerlink" title="verbose_name"></a>verbose_name</h2><p><code>Field.verbose_name</code></p>
<p>一个字段的可读性更高的名称。如果用户没有设定冗余名称字段，Django会自动将该字段属性名中的下划线转换为空格，并用它来创建冗余名称。可以参照 <a href="http://python.usyiyi.cn/django_182/topics/db/models.html#verbose-field-names" target="_blank" rel="external">Verbose field names</a>.</p>
<h2 id="validators"><a href="#validators" class="headerlink" title="validators"></a>validators</h2><p><code>Field.validators</code></p>
<p>该字段将要运行的一个<code>Validator</code> 的列表。更多信息参见<code>Validators</code> 的文档。</p>
<h2 id="注册和获取查询"><a href="#注册和获取查询" class="headerlink" title="注册和获取查询"></a>注册和获取查询</h2><p><code>Field</code> 实现了查询注册API。该API 可以用于自定义一个字段类型的可用的查询，以及如何从一个字段获取查询。</p>
<h1 id="字段类型（Field-Type）"><a href="#字段类型（Field-Type）" class="headerlink" title="字段类型（Field Type）"></a>字段类型（Field Type）</h1><h2 id="自增字段"><a href="#自增字段" class="headerlink" title="自增字段"></a>自增字段</h2><p><code>class AutoField(**options)</code></p>
<p>一个<code>IntegerField</code> 根据实际ID自动增长. 你通常不需要直接使用;如果不指定,一个主键字段将自动添加到你创建的模型中.详细查看<a href="http://python.usyiyi.cn/django_182/topics/db/models.html#automatic-primary-key-fields" target="_blank" rel="external"> 主键字段</a>.</p>
<h2 id="BigIntegerField"><a href="#BigIntegerField" class="headerlink" title="BigIntegerField"></a>BigIntegerField</h2><p><code>class BigIntegerField([**options])</code></p>
<p>一个64位整数, 类似于一个 <code>IntegerField</code> ,它的值的范围是 -9223372036854775808 到9223372036854775807之间. 这个字段默认的表单组件是一个<code>TextInput</code>.</p>
<h2 id="BinaryField"><a href="#BinaryField" class="headerlink" title="BinaryField"></a>BinaryField</h2><p><code>class BinaryField([**options])</code></p>
<p>这是一个用来存储原始二进制码的<code>Field</code>. 只支持<code>bytes</code> 声明，注意这个Field只有很<strong>有限</strong>的功能。例如，不大可能在一个<code>BinaryField</code> 值的数据上进行查询</p>
<p>滥用 <code>BinaryField</code></p>
<p>尽管你可能想使用数据库来存储你的文件，但是99%的情况下这都是不好的设计。这个字段不是合理操作静态文件的替代（XAE上可以使用storage替代）.</p>
<h2 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h2><p><code>class CharField(max_length=None[, **options])</code></p>
<p>一个用来存储从小到很大各种长度的字符串的地方</p>
<p>如果是巨大的文本类型, 可以用 <code>TextField</code>.</p>
<p>这个字段默认的表单样式是 <code>TextInput</code>.</p>
<p><code>CharField</code>接收一个额外的必须参数。</p>
<p><code>CharField.max_length</code></p>
<p>字段的最大字符长度.max_length将在数据库层和Django表单验证中起作用, 用来限定字段的长度. </p>
<p>需要注意的是：</p>
<p>如果你在写一个需要导出到多个不同数据库后端的应用，你需要注意某些后端对<code>max_length</code>有一些限制，<a href="http://python.usyiyi.cn/django_182/ref/databases.html" target="_blank" rel="external">查看数据库后端</a>注意事项来获取更多的细节</p>
<p>如果你是用了MySQLdb 1.2.2并且采用utf8_bin核对（并不是默认选项），这里就需要注意了，在<a href="http://python.usyiyi.cn/django_182/ref/databases.html#mysql-collation" target="_blank" rel="external">MySQL database notes</a>中有说明。</p>
<h2 id="CommaSeparatedIntegerField"><a href="#CommaSeparatedIntegerField" class="headerlink" title="CommaSeparatedIntegerField"></a>CommaSeparatedIntegerField</h2><p><code>class CommaSeparatedIntegerField(max_length=None[, **options])</code></p>
<p>一个逗号分隔的整数字段。像 <code>CharField</code>一样， 需要一个<code>max_length</code> 参数， 同时数据库移植时也需要注意。</p>
<h2 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h2><p><code>class DateField([auto_now=False, auto_now_add=False, **options])</code></p>
<p>这是一个使用Python的<code>datetime.date</code>实例表示的日期. 有几个额外的设置参数:</p>
<h3 id="DateField-auto-now"><a href="#DateField-auto-now" class="headerlink" title="DateField.auto_now"></a>DateField.auto_now</h3><p>每次保存对象时，自动设置该字段为当前时间。用于”最后一次修改”的时间戳. 注意,它总是always使用当前日期; 它不仅是一个默认值，您可以重写。</p>
<h3 id="DateField-auto-now-add"><a href="#DateField-auto-now-add" class="headerlink" title="DateField.auto_now_add"></a>DateField.auto_now_add</h3><p>当对象第一次被创建时自动设置当前时间。用于创建时间的时间戳. 它总是使用当前日期（第一次被创建时的时间？）; 它不仅是一个默认值，您可以重写。</p>
<p>该字段默认对应的表单控件是一个<code>TextInput</code>. 在管理员站点添加了一个JavaScript写的日历控件，和一个“Today”的快捷按钮.包含了一个额外的<code>invalid_date</code>错误消息键.</p>
<p><code>auto_now_add</code>, <code>auto_now</code>, 和 <code>default</code> 这些设置是相互排斥的. 他们之间的任何组合将会发生错误的结果.</p>
<p>需要注意的是：</p>
<p>在目前的实现中，设置<code>auto_now</code>或者<code>auto_now_add</code>为<code>True</code>将为让这个字段同时得到<code>editable=False</code>和<code>blank=True</code>这两个设置.</p>
<p>注意：</p>
<p><code>auto_now</code>和<code>auto_now_add</code>这两个设置会在对象创建或更新的时刻,总是使用<code>default timezone</code>(默认时区)的日期. 如果你不想这样，你可以考虑一下简单地使用你自己的默认调用或者重写<code>save()</code>(在<code>save()</code>函数里自己添加保存时间的机制.译者注)而不是使用<code>auto_now</code> 或者 <code>auto_now_add</code>; 或者使用<code>DateTimeField</code>字段类来替换<code>DateField</code> 并且在给用户呈现时间的时候,决定如何处理从<code>datetime</code>到<code>date</code>的转换.</p>
<h2 id="DateTimeField"><a href="#DateTimeField" class="headerlink" title="DateTimeField"></a>DateTimeField</h2><p><code>class DateTimeField([auto_now=False, auto_now_add=False, **options])</code></p>
<p>它是通过Pythondatetime.datetime实例表示的日期和时间. 携带了跟DateField一样的额外参数.</p>
<p>该字段默认对应的表单控件是一个单个的<code>TextInput</code>(单文本输入框). 管理员系统使用两个单独Javascript的<code>TextInput</code>控件来完成输入。</p>
<h2 id="DecimalField"><a href="#DecimalField" class="headerlink" title="DecimalField"></a>DecimalField</h2><p><code>class DecimalField(max_digits=None, decimal_places=None[, **options])</code></p>
<p>十进制浮点数,表示python中 <code>Decimal</code> 的一个实例. 有两个 必须的参数:</p>
<h3 id="DecimalField-max-digits"><a href="#DecimalField-max-digits" class="headerlink" title="DecimalField.max_digits"></a>DecimalField.max_digits</h3><p>位数总数，包括小数点后的位数。该值必须大于等于<code>decimal_places</code>.</p>
<h3 id="DecimalField-decimal-places"><a href="#DecimalField-decimal-places" class="headerlink" title="DecimalField.decimal_places"></a>DecimalField.decimal_places</h3><p>小数点后的数字数量。</p>
<p>举个例子，为了存储一个最大到999且含有两位数字的数字，你可以这样使用：</p>
<pre class="lang:python decode:true">models.DecimalField(..., max_digits=5, decimal_places=2)</pre>

<p> 你要是想存储一个十亿的具有10位小数的数字，你可以使用这个：</p>
<pre class="lang:python decode:true">models.DecimalField(..., max_digits=19, decimal_places=10)</pre>

<p>这个字段默认表单中的控件是<code>TextInput</code>。</p>
<p>注意的是：</p>
<p>关于<code>FloatField</code>和<code>DecimalField</code>的区别，你可以点击<a href="http://python.usyiyi.cn/django_182/ref/models/fields.html#floatfield-vs-decimalfield" target="_blank" rel="external">这里</a>。</p>
<h2 id="DurationField"><a href="#DurationField" class="headerlink" title="DurationField"></a>DurationField</h2><p><strong>New in Django 1.8.</strong></p>
<p><code>class DurationField([**options])</code></p>
<p>用作存储一段时间的字段类型 - 类似Python中的<code>timedelta</code>. 当使用PostgreSQL的时候，使用的数据类型是<code>interval</code>，而在Oracle里就是 <code>INTERVAL DAY(9) TO SECOND(6)</code>.其他的就是一个微秒的<code>bigint</code></p>
<p><strong>需要注意的是：</strong></p>
<p>在大多数情况下，<code>DurationField</code>能够正常工作。然而除了PostgreSQL以外，在DateTimeField计算<code>DurationField</code>的值的时候将有可能不如预期的工作。</p>
<h2 id="EmailField"><a href="#EmailField" class="headerlink" title="EmailField"></a>EmailField</h2><p><code>class EmailField([max_length=254, **options])</code></p>
<p>是一个会检查有效的邮件地址的<code>CharField</code>，其会使用<code>EmailValidator</code>来<a href="http://python.usyiyi.cn/django_182/ref/validators.html#django.core.validators.EmailValidator" target="_blank" rel="external">验证</a>这个输入。</p>
<p><strong>Changed in Django 1.8:</strong></p>
<p>max_length的默认值为了与<code>RFC3696/5321</code>所兼容，会从75到254的长度间所兼容。</p>
<h2 id="FileField"><a href="#FileField" class="headerlink" title="FileField"></a>FileField</h2><p><code>class FileField([upload_to=None, max_length=100, **options])</code></p>
<p>一个上传文件的字段。</p>
<p>注意</p>
<p>如果使用<code>primary_key</code> 和<code>unique</code>参数会生成 <code>TypeError</code>错误</p>
<p>有两个可选参数：</p>
<p><code>FileField.upload_to</code></p>
<p>Changed in Django 1.7:</p>
<p>在旧版本Django中，<code>upload_to</code> 属性是必须要有的;</p>
<p>将会添加一个本地文件系统路径到 <code>MEDIA_ROOT</code> 设置中，来明确 url 属性的值。</p>
<p>这个路径可能会包含一个 <code>strftime()</code> 格式串,并且会在文件上传时被替换为 实际的<code>date/time</code>作为文件路径 (这样上传的文件就不会塞满你指定的文件夹了).</p>
<p>这也可以是一个可调用对象，如函数。可以调用它来获取上传路径，包括文件名。它必须接受两个参数，并且返回一个Unix-style的路径(带有/)给存储系统。这被传递的两个参数为:</p>
<table style="width: 805px; box-sizing: border-box; height: 220px;" border="0" width="439" cellspacing="0" cellpadding="0"><colgroup> <col style="mso-width-source: userset; mso-width-alt: 4096; width: 96pt; box-sizing: border-box;" width="128"> <col style="mso-width-source: userset; mso-width-alt: 9952; width: 233pt; box-sizing: border-box;" width="311"> </colgroup><tbody><tr style="height: 15.0pt; box-sizing: border-box;"><td class="xl63" style="height: 15.0pt; width: 96pt;" width="128" height="20">Argument</td><td class="xl63" style="width: 233pt;" width="311">Description</td></tr><tr style="height: 85.5pt; box-sizing: border-box;"><td class="xl67" style="height: 85.5pt; border-top: none; width: 96pt; box-sizing: border-box;" width="128" height="114"><span style="box-sizing: border-box; font-variant-ligatures: no-common-ligatures; text-rendering: optimizeSpeed;">instance</span></td><td class="xl64" style="width: 233pt; box-sizing: border-box;" width="311"><span style="box-sizing: border-box; font-variant-ligatures: no-common-ligatures; text-rendering: optimizeSpeed;">FileField<span class="font5" style="box-sizing: border-box;"> </span><span class="font7" style="box-sizing: border-box;">被定义时的一个实例</span><span class="font5">. </span><span class="font7">更准确地说，这是一个包含当前文件的特殊实例。在大多数情况下</span><span class="font5">, this object will not have been saved to the database yet, so if it uses the default</span><span class="font7"> </span><span class="font5">AutoField,</span><span class="font7"> </span><span class="font5">it might not yet have a value for its primary key field.</span></span></td></tr><tr style="height: 43.5pt; box-sizing: border-box;"><td class="xl66" style="height: 43.5pt; width: 96pt; box-sizing: border-box;" width="128" height="58"><span style="box-sizing: border-box; font-variant-ligatures: no-common-ligatures; text-rendering: optimizeSpeed;">filename</span></td><td class="xl65" style="width: 233pt; box-sizing: border-box;" width="311">The filename that was originally given to the file. This may or may not be taken into account when determining the final destination path.</td></tr></tbody></table>

<h2 id="FileField-storage"><a href="#FileField-storage" class="headerlink" title="FileField.storage"></a>FileField.storage</h2><p>一个storage对象，用于你的文件的存取。参见<a href="http://python.usyiyi.cn/django_182/topics/files.html" target="_blank" rel="external">Managing files</a>获取这个对象的细节。</p>
<p>这个字段在表格里的默认组件是 <code>ClearableFileInput</code>.</p>
<p>在模型中使用<code>FileField</code>或者<code>ImageField</code>需要进行以下几步：</p>
<ol>
<li>在你的设置文件之中，你需要作为定义<code>MEDIA_ROOT</code>作为完整地址为Django上传的地址（举个例子，为了高性能，这些文件最好不要存储于数据库之中）</li>
<li>向模型中添加<code>FileField</code>或者<code>ImageField</code>，你就可以定义<code>upload_to</code>来指定<code>MEDIA_ROOT</code>下的子文件作为上传的文档</li>
<li>所有存储到数据库中的文件都将以相对路径的形式存储到数据库之中，你可以使用Django提供的简便的url属性来指明其地址。举个例子，如果你的<code>ImageField</code>被<code>mug_shot</code>所捕获了，你就能在模板中使用<code>{{ object.mug_shot.url }}</code>来取得到图像的绝对路径。</li>
</ol>
<p>例如，如果你的 <code>MEDIA_ROOT</code>设定为 ‘<code>/home/media</code>‘，并且 upload_to设定为 ‘photos/%Y/%m/%d’。 <code>upload_to</code>的’<code>%Y/%m/%d</code>‘被<code>strftime()</code>所格式化；’%Y’ is the four-digit year, ‘%m’ is the two-digit month and ‘%d’ is the two-digit day. If you upload a file on Jan. 15, 2007, it will be saved in the directory <code>/home/media/photos/2007/01/15</code>.</p>
<p>如果你想获得上传文件的存盘文件名，或者是文件大小，你可以分别使用 <code>name</code> 和 <code>size</code>属性； for more information on the available attributes and methods, see the <a href="http://python.usyiyi.cn/django_182/ref/files/file.html#django.core.files.File" target="_blank" rel="external">File</a> class reference and the <a href="http://python.usyiyi.cn/django_182/topics/files.html" target="_blank" rel="external">Managing files</a> topic guide.</p>
<p>Note</p>
<p>保存的文件作为模型存储在数据库中的一部分，所以在磁盘上使用的实际的文件名在模型保存完毕之前是不可靠的。</p>
<p>上传的文件对应的URL可以通过使用 url 属性获得. 在内部，它会调用  Storage 类下的<code>url()</code>方法.</p>
<p>值得注意的是，无论你在任何时候处理上传文件的需求，你都应该密切关注你的文件将被上传到哪里，上传的文件类型，以避免安全漏洞。认证所有上传文件 以确保那些上传的文件是你所认为的文件。例如，如果你盲目的允许其他人在无需认证的情况下上传文件至你的web服务器的root目录中，那么别人可以上传一个CGI或者PHP脚本然后通过访问一个你网站的URL来执行这个脚本。所以，不要允许这个发生。</p>
<p>甚至是上传HTML文件也值得注意，它可以通过浏览器（虽然不是服务器）执行，也可以引发相当于是XSS或者CSRF攻击的安全威胁。</p>
<p><code>FileField</code> 实例将会在你的数据库中创建一个默认最大长度为100字符的<code>varchar</code> 列。就像其他的<code>fields</code>一样, 你可以用 <code>max_length</code> 参数改变最大长度的值。</p>
<h3 id="FileField和FieldFile"><a href="#FileField和FieldFile" class="headerlink" title="FileField和FieldFile"></a>FileField和FieldFile</h3><p><code>class FieldFile[source]</code></p>
<p>当你在模型之中访问<code>FileField</code>，你就能够使用使用代理模型来访问潜在的文件。这样也能从<code>django.core.files.File</code>中继承类，这个类也有几个函数能够和文件数据进行交互：</p>
<h3 id="FieldFile-url"><a href="#FieldFile-url" class="headerlink" title="FieldFile.url"></a>FieldFile.url</h3><p>一个通过<code>url()</code>方式只读文件<code>Storage</code>类的相对路径的属性。</p>
<h3 id="FieldFile-open-mode-’rb’"><a href="#FieldFile-open-mode-’rb’" class="headerlink" title="FieldFile.open(mode=’rb’)"></a>FieldFile.open(mode=’rb’)</h3><p>能像标准Python函数的<code>open()</code>那样打开在这个模式下在指定模型实例所关联的文件。</p>
<h3 id="FieldFile-close"><a href="#FieldFile-close" class="headerlink" title="FieldFile.close()"></a>FieldFile.close()</h3><p>能像标准Python函数的close()那样打开在这个模式下在指定模型实例所关联的文件。</p>
<h3 id="FieldFile-save-name-content-save-True"><a href="#FieldFile-save-name-content-save-True" class="headerlink" title="FieldFile.save(name, content, save=True)"></a>FieldFile.save(name, content, save=True)</h3><p>这个方式会获取文件名以及文件内容并且把他传递到字段的存储类之中，然后模型字段会和储存文件关联。如果你想手动在模型实例使用<code>FileField</code>关联文件的话，<code>save()</code>这个函数就能够保存文件数据。</p>
<p>其会使用两个必选参数：文件名称和一个包含文件内容的对象。可选参数就是一个控制在关联字段的文件发生变更的时候模型实例是否会被保存。默认是<code>True</code>。</p>
<p>需要注意的是，内容参数应该是<code>django.core.files.File</code>的一个实例而不是Python的内建对象，你能够这样从一个现有的Python文件对象之中构建这个文件：</p>
<pre class="lang:python decode:true">from django.core.files import File
# Open an existing file using Python's built-in open()
f = open('/tmp/hello.world')
myfile = File(f)</pre>

<p>或者你可以这样构造Python的字符串：</p>
<pre class="lang:python decode:true">from django.core.files.base import ContentFile
myfile = ContentFile("hello world")</pre>

<p>更多的信息，你可以查看<a href="http://python.usyiyi.cn/django_182/topics/files.html" target="_blank" rel="external">Managing files</a>.</p>
<h3 id="FieldFile-delete-save-True"><a href="#FieldFile-delete-save-True" class="headerlink" title="FieldFile.delete(save=True)"></a>FieldFile.delete(save=True)</h3><p>删除与实例相关的文件并且关闭字段中所有的属性。需要注意的是，这个方式当<code>delete()</code>被调用的时候会关闭文件。</p>
<p>可选<code>save</code>项会控制在关联字段的文件发生删除的时候模型实例是否会被保存。默认是<code>True</code>。</p>
<p>注意，model删除的时候，与之关联的文件并不会被删除。如果你要把文件也清理掉，你需要自己处理。</p>
<h2 id="FilePathField"><a href="#FilePathField" class="headerlink" title="FilePathField"></a>FilePathField</h2><p><code>class FilePathField(path=None[, match=None, recursive=False, max_length=100, **options])</code></p>
<p>一个 <code>CharField</code> ，内容只限于文件系统内特定目录下的文件名。有三个参数, 其中第一个是 必需的:</p>
<h3 id="FilePathField-path"><a href="#FilePathField-path" class="headerlink" title="FilePathField.path"></a>FilePathField.path</h3><p>必选项。文件系统<code>FilePathField</code>需要获得的选项的绝对路径。</p>
<p>举个例子： “<code>/home/images</code>“.</p>
<h3 id="FilePathField-match"><a href="#FilePathField-match" class="headerlink" title="FilePathField.match"></a>FilePathField.match</h3><p>可选项。<code>FilePathField</code>用于过滤文件名的一个正则表达式。需要注意的是，正则表达式会被应用于基本文件夹而不是绝对路径。</p>
<p>举个例子：<code>foo.*.txt$</code>“会匹配名为foo23.txt而不会匹配<code>bar.txt</code>或者<code>foo23.png</code>。</p>
<h3 id="FilePathField-recursive"><a href="#FilePathField-recursive" class="headerlink" title="FilePathField.recursive"></a>FilePathField.recursive</h3><p>可选项。布尔值，默认值为False。指定所有子文件夹的是否应该被包括。</p>
<h3 id="FilePathField-allow-files"><a href="#FilePathField-allow-files" class="headerlink" title="FilePathField.allow_files"></a>FilePathField.allow_files</h3><p>可选项。布尔值，默认为True。在指定位置下的文件是否应该被包括。这个或者<code>allow_folders</code>有一个必须为True。</p>
<h3 id="FilePathField-allow-folders"><a href="#FilePathField-allow-folders" class="headerlink" title="FilePathField.allow_folders"></a>FilePathField.allow_folders</h3><p>可选项，布尔值，默认为False。在指定位置下的文件夹是否应该被包括。这个或者<code>allow_files</code>有一个必须为True。</p>
<p>当然，这些参数能够一起使用</p>
<p>有一点需要提醒的是 match只匹配基本文件名（base filename）, 而不是整个文件路径（full path）. So, this example:</p>
<pre class="lang:python decode:true">FilePathField(path="/home/images", match="foo.*", recursive=True)</pre>

<p> 会匹配<code>/home/images/foo.png</code>但是并不会匹配<code>/home/images/bar.png</code>，因为这个前者的匹配会应用于<code>foo.png</code>和<code>bar.png</code>。</p>
<p><code>FilePathField</code>实例会以最大长度为100个字符的<code>varchar</code>的行在数据库中储存。和别的字段一样，你也能通过使用max_length的参数来改变最大长度。</p>
<h2 id="FloatField"><a href="#FloatField" class="headerlink" title="FloatField"></a>FloatField</h2><p><code>class FloatField([**options])</code></p>
<p>一个浮点数会由Python的一个浮点数实例所代表。</p>
<p>默认表格的控件是<code>TextInput</code>。</p>
<p><code>FloatField</code> vs. <code>DecimalField</code></p>
<p><code>FloatField</code>会和<code>DecimalField</code>类会混淆。尽管他们都能表示实数，但是他们表示的方式却很不相同。<code>FloatField</code>会使用Python的内建的浮点类型而<code>DecimalField</code>会使用Python的小数类型。在<a href="https://docs.python.org/3/library/decimal.html#module-decimal" target="_blank" rel="external">这里</a>有关于<code>decimal</code>模组的更多信息。</p>
<h2 id="ImageField"><a href="#ImageField" class="headerlink" title="ImageField"></a>ImageField</h2><p><code>class ImageField([upload_to=None, height_field=None, width_field=None, max_length=100, **options])</code></p>
<p>继承了 <code>FileField</code>的所有属性和方法, 但还对上传的对象进行校验，确保它是个有效的image.</p>
<p>除了从<code>FileField</code>继承来的属性外，ImageField 还有宽和 高属性。</p>
<p>为了辅助查询这些属性，<code>ImageField</code>有两个额外的参数：</p>
<h3 id="ImageField-height-field"><a href="#ImageField-height-field" class="headerlink" title="ImageField.height_field"></a>ImageField.height_field</h3><p>每当模组实例保存的时候，会被自动存储的图片高度的模型字段的名称。</p>
<h3 id="ImageField-width-field"><a href="#ImageField-width-field" class="headerlink" title="ImageField.width_field"></a>ImageField.width_field</h3><p>每当模组实例保存的时候，会被自动存储的图片宽度的模型字段的名称。</p>
<p>ImageField字段需要调用<a href="http://pillow.readthedocs.org/en/latest/" target="_blank" rel="external">Pillow</a> 库.</p>
<p><code>ImageField</code> 实例将会在你的数据库中创建一个默认最大长度为100字符的<code>varchar</code> 列。就像其他的fields一样, 你可以用 <code>max_length</code> 参数改变最大长度的值。</p>
<p>这个字段的默认的表单控件是<code>ClearableFileInput</code>。</p>
<h2 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h2><p><code>class IntegerField([**options])</code></p>
<p>一个整数。在Django所支持的所有数据库中，从 -2147483648 到 2147483647 范围内的值是合法的。默认的表单输入工具是<code>TextInput</code>.</p>
<h2 id="GenericIPAddressField"><a href="#GenericIPAddressField" class="headerlink" title="GenericIPAddressField"></a>GenericIPAddressField</h2><p><code>class GenericIPAddressField([protocol=both, unpack_ipv4=False, **options])</code></p>
<p>一个IPv4或者一个IPv6的地址（比如<code>192.0.2.30</code>或者<code>2a02:42fe::4</code>），默认的表单控件式<code>TextInput</code>。</p>
<p>IPv6的地址格式化会遵循<code>RFC 4291</code>的标准，包含IPv4推荐的格式，例如<code>::ffff:192.0.2.0</code>。举个例子，<code>2001:0::0:01</code>会被格式化为<code>2001::1</code>，<code>::ffff:0a0a:0a0a</code>会被转换成<code>::ffff:10.10.10.10</code>，所有的字符都会转换成小写。</p>
<h3 id="GenericIPAddressField-protocol"><a href="#GenericIPAddressField-protocol" class="headerlink" title="GenericIPAddressField.protocol"></a>GenericIPAddressField.protocol</h3><p>可以限制指定的套接字，IPv4或者IPv6都是可以的，这里大小写敏感。</p>
<h3 id="GenericIPAddressField-unpack-ipv4"><a href="#GenericIPAddressField-unpack-ipv4" class="headerlink" title="GenericIPAddressField.unpack_ipv4"></a>GenericIPAddressField.unpack_ipv4</h3><p>把IPv4展开成类似于<code>::ffff:192.0.2.1</code>的地址，当这个选项可用的时候，地址就会被转换成<code>192.0.2.1</code>.默认是禁用的，当套接字被设置为<code>both</code>的时候才能被使用。</p>
<p>如果你允许空值，因为空值会以<code>null</code>来存储，你必须允许空值的通行。</p>
<h2 id="NullBooleanField"><a href="#NullBooleanField" class="headerlink" title="NullBooleanField"></a>NullBooleanField</h2><p><code>class NullBooleanField([**options])</code></p>
<p>和<code>BooleanField</code>一样，但是能够允许<code>NULL</code>作为其中的一个选项。需要使用这个而不是一个<code>null=True</code>的<code>BooleanField</code>。默认的表单控件是<code>NullBooleanSelect</code>。</p>
<h2 id="PositiveIntegerField"><a href="#PositiveIntegerField" class="headerlink" title="PositiveIntegerField"></a>PositiveIntegerField</h2><p><code>class PositiveIntegerField([**options])</code></p>
<p>从0-2147483647的值在Django所支持的数据库中都支持，0的支持与否是根据后台兼容所决定的。</p>
<h2 id="PositiveSmallIntegerField"><a href="#PositiveSmallIntegerField" class="headerlink" title="PositiveSmallIntegerField"></a>PositiveSmallIntegerField</h2><p><code>class PositiveSmallIntegerField([**options])</code></p>
<p>该模型字段类似 <code>PositiveIntegerField</code>, 但是只允许小于某一特定值（依据数据库类型而定）。从0 到 32767 这个区间，对于Django所支持的所有数据库而言都是安全的。</p>
<h2 id="SlugField"><a href="#SlugField" class="headerlink" title="SlugField"></a>SlugField</h2><p><code>class SlugField([max_length=50, **options])</code></p>
<p>Slug 是一个新闻术语（通常叫做短标题）。一个slug只能包含字母、数字、下划线或者是连字符，通常用来作为短标签。通常它们是用来放在URL里的。</p>
<p>和<code>CharField</code>一样，你能够指定最大长度，如果并没有指定，Django会使用50作为其的值。</p>
<p>指定<code>setting Field.db_index</code>为<code>True</code>。</p>
<p>自动创建<code>SlugField</code>会基于其他值。你能够在管理员网页中使用<code>prepopulated_fields</code>所自动使用它。</p>
<h2 id="SmallIntegerField"><a href="#SmallIntegerField" class="headerlink" title="SmallIntegerField"></a>SmallIntegerField</h2><p><code>class SmallIntegerField([**options])</code></p>
<p>和<code>IntegerField</code>一样，但是只会允许基于数据库的值，从-32768到32767在所有Django能够支持的数据库之中的数据都是安全的。</p>
<h2 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h2><p><code>class TextField([**options])</code></p>
<p>长文本的字段，默认表单控件是<code>Textarea</code>。</p>
<p><strong>Changed in Django 1.7:</strong></p>
<p>如果你指定了<code>max_length</code>的属性，其会在自动生成的表单字段中的控件所响应，然而在模型和数据库的层面上并不会强制要求这个属性。你可以使用<code>CharField</code>来解决这个问题。</p>
<p>MySQL users</p>
<p>如果你正在使用<code>MySQLdb 1.2.1p2</code>并且<code>utf8_bin</code>的核对方法的话这里就需要注意一些问题了，在<a href="http://python.usyiyi.cn/django_182/ref/databases.html#mysql-collation" target="_blank" rel="external">MySQL database notes</a>中就可以获得详情。</p>
<h2 id="TimeField"><a href="#TimeField" class="headerlink" title="TimeField"></a>TimeField</h2><p><code>class TimeField([auto_now=False, auto_now_add=False, **options])</code></p>
<p>这个字段会被Python中的<code>datetime.time</code>实例所代表，其也接受一个同样自动创建的和<code>DateField</code>一样的选项。</p>
<p>默认的表单控件是<code>TextInput</code>，管理员站点会使用JavaScript的一个快捷方式。</p>
<h2 id="URLField"><a href="#URLField" class="headerlink" title="URLField"></a>URLField</h2><p><code>class URLField([max_length=200, **options])</code></p>
<p>一个为URL所涉及的<code>CharField</code>。</p>
<p>默认的表单控件是<code>TextInput</code>。</p>
<p>和所有的<code>CharField</code>的子类一样，<code>URLField</code>会使用<code>max_length</code>参数作为可选项。如果你并没有指定<code>max_length</code>的值，默认会使用200作为其值。</p>
<h2 id="UUIDField"><a href="#UUIDField" class="headerlink" title="UUIDField"></a>UUIDField</h2><p><strong>New in Django 1.8.</strong></p>
<p><code>class UUIDField([**options])</code></p>
<p>一个为了存储<a href="http://baike.baidu.com/link?url=hwOmlIib6lr_lkrd-Ea3-DW8NaJtN7aV6ZQ_aUTesW_nLcbtAaV49zx7ByqY52NDF4sWvLC6a7QV-6ARGI0vKa" title="UUID" target="_blank" rel="external">通用唯一识别码</a>的字段，使用Python的<code>UUID</code>这个类，当使用PostgreSQL的时候，其会以<code>uuid</code>的数据类型储存而不是<code>char(32)</code>的格式。</p>
<p><a href="http://baike.baidu.com/link?url=hwOmlIib6lr_lkrd-Ea3-DW8NaJtN7aV6ZQ_aUTesW_nLcbtAaV49zx7ByqY52NDF4sWvLC6a7QV-6ARGI0vKa" title="UUID" target="_blank" rel="external">通用唯一识别码</a>是一个能够替代<code>primary_key</code>的一个<code>AutoField</code>，数据库并不会自动生成<code>UUID</code>，所以使用默认类型还是比较好的。</p>
<pre class="lang:python decode:true ">import uuid
from django.db import models

class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields</pre>

<p> 需要注意的是一个<code>callable</code>会被传递给<code>default</code>，而不是<a href="http://baike.baidu.com/link?url=hwOmlIib6lr_lkrd-Ea3-DW8NaJtN7aV6ZQ_aUTesW_nLcbtAaV49zx7ByqY52NDF4sWvLC6a7QV-6ARGI0vKa" target="_blank" rel="external">UUID</a>的实例。</p>
<h1 id="关系字段"><a href="#关系字段" class="headerlink" title="关系字段"></a>关系字段</h1><p>Django 同样定义了一系列的字段来描述数据库之间的关联。</p>
<h2 id="ForeignKey"><a href="#ForeignKey" class="headerlink" title="ForeignKey"></a>ForeignKey</h2><p><code>class ForeignKey(othermodel[, **options])</code></p>
<p>多对一关系。需要一个位置参数：与该模型关联的类。</p>
<p>若要创建一个递归的关联 —— 对象与自己具有多对一的关系 —— 请使用<code>models.ForeignKey(&#39;self&#39;)</code>。</p>
<p>如果你需要关联到一个还没有定义的模型，你可以使用模型的名字而不用模型对象本身：</p>
<pre class="lang:python decode:true ">from django.db import models

class Car(models.Model):
    manufacturer = models.ForeignKey('Manufacturer')
    # ...

class Manufacturer(models.Model):
    # ...
    pass</pre>

<p> 若要引用在其它应用中定义的模型，你可以用带有完整标签名的模型来显式指定。例如，如果上面提到的Manufacturer 模型是在一个名为production 的应用中定义的，你应该这样使用它：</p>
<pre class="lang:python decode:true ">class Car(models.Model):
    manufacturer = models.ForeignKey('production.Manufacturer')</pre>

<p> 在解析两个应用之间具有相互依赖的导入时，这种引用将会很有帮助。</p>
<p><code>ForeignKey</code> 会自动创建数据库索引。你可以通过设置<code>db_index</code> 为<code>False</code> 来取消。如果你创建外键是为了一致性而不是用来Join，或者如果你将创建其它索引例如部分或多列索引，你也许想要避免索引的开销。</p>
<p>警告</p>
<p>不建议从一个没有迁移的应用中创建一个<code>ForeignKey</code> 到一个具有迁移的应用。更多细节参见<a href="http://python.usyiyi.cn/django_182/topics/migrations.html#unmigrated-dependencies" target="_blank" rel="external">依赖性文档</a>。</p>
<h3 id="数据库中的表示"><a href="#数据库中的表示" class="headerlink" title="数据库中的表示"></a>数据库中的表示</h3><p>在幕后，Django 会在字段名上添加”<code>_id</code>“ 来创建数据库中的列名。在上面的例子中，Car 模型的数据库表将会拥有一个manufacturer_id 列。（你可以通过显式指定<code>db_column</code> 改变它）。但是，你的代码永远不应该处理数据库中的列名称，除非你需要编写自定义的SQL。你应该永远只处理你的模型对象中的字段名称。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>ForeignKey</code> 接受额外的参数集 —— 全都是可选的 —— 它们定义关联关系如何工作的细节。</p>
<h4 id="ForeignKey-limit-choices-to"><a href="#ForeignKey-limit-choices-to" class="headerlink" title="ForeignKey.limit_choices_to"></a>ForeignKey.limit_choices_to</h4><p>当这个字段使用模型表单或者<code>Admin</code> 渲染时（默认情况下，查询集中的所有对象都可以使用），为这个字段设置一个可用的选项。它可以是一个字典、一个Q 对象或者一个返回字典或Q对象的可调用对象。</p>
<p>例如：</p>
<pre class="lang:python decode:true ">staff_member = models.ForeignKey(User, limit_choices_to={'is_staff': True})</pre>

<p> 将使得模型表单 中对应的字段只列出<code>is_staff=True</code> 的<code>Users</code>。 这在Django 的<code>Admin</code> 中也可能有用处。</p>
<p>可调用对象的形式同样非常有用，比如与Python 的<code>datetime</code>模块一起使用来限制选择的时间范围。例如：</p>
<pre class="lang:python decode:true ">def limit_pub_date_choices():
    return {'pub_date__lte': datetime.date.utcnow()}

limit_choices_to = limit_pub_date_choices</pre>

<p> 如果<code>limit_choices_to</code> 自己本身是或者返回一个用于复杂查询的Q 对象，当字段没有在模型的<code>ModelAdmin</code>中的<code>raw_id_fields</code> 列出时，它将只会影响<code>Admin</code>中的可用的选项。</p>
<p><strong>Changed in Django 1.7:</strong></p>
<p>以前的Django 版本不允许传递一个可调用的对象给<code>limit_choices_to</code>。</p>
<p><em>注</em></p>
<p>如果<code>limit_choices_to</code> 使用可调用对象，这个可调用对象将在每次创建一个新表单的时候都调用。它还可能在一个模型校验的时候调用，例如被管理命令或者<code>Admin</code>。<code>Admin</code> 多次构造查询集来验证表单在各种边缘情况下的输入，所以你的可调用对象可能调用多次。</p>
<h4 id="ForeignKey-related-name"><a href="#ForeignKey-related-name" class="headerlink" title="ForeignKey.related_name"></a>ForeignKey.related_name</h4><p>这个名称用于让关联的对象反查到源对象。它还是<code>related_query_name</code> 的默认值（关联的模型进行反向过滤时使用的名称）。完整的解释和示例参见关联对象的文档。注意，当你为抽象模型定义关联关系的时，必须设置这个参数的值；而且当你这么做的时候需要用到一些特殊语法。</p>
<p>如果你不想让Django 创建一个反向关联，请设置<code>related_name</code> 为 ‘+’ 或者以’+’ 结尾。 例如，下面这行将确定User 模型将不会有到这个模型的返回关联：</p>
<pre class="lang:python decode:true ">user = models.ForeignKey(User, related_name='+')</pre>

<h4 id="ForeignKey-related-query-name"><a href="#ForeignKey-related-query-name" class="headerlink" title="ForeignKey.related_query_name"></a>ForeignKey.related_query_name</h4><p>这个名称用于目标模型的反向过滤。如果设置了<code>related_name</code>，则默认为它的值，否则默认值为模型的名称：</p>
<pre class="lang:python decode:true "># Declare the ForeignKey with related_query_name
class Tag(models.Model):
    article = models.ForeignKey(Article, related_name="tags", related_query_name="tag")
    name = models.CharField(max_length=255)

# That's now the name of the reverse filter
Article.objects.filter(tag__name="important")</pre>

<h4 id="ForeignKey-to-field"><a href="#ForeignKey-to-field" class="headerlink" title="ForeignKey.to_field"></a>ForeignKey.to_field</h4><p>关联到的关联对象的字段名称。默认地，Django 使用关联对象的主键。</p>
<h4 id="ForeignKey-db-constraint"><a href="#ForeignKey-db-constraint" class="headerlink" title="ForeignKey.db_constraint"></a>ForeignKey.db_constraint</h4><p>控制是否在数据库中为这个外键创建约束。默认值为<code>True</code>，而且这几乎一定是你想要的效果；设置成<code>False</code> 对数据的完整性来说是很糟糕的。即便如此，有一些场景你也许想要这么设置：</p>
<ul>
<li>你有遗留的无效数据。</li>
<li>你正在对数据库缩容。</li>
</ul>
<p>如果被设置成<code>False</code>，访问一个不存在的关联对象将抛出 <code>DoesNotExist</code> 异常。</p>
<h4 id="ForeignKey-on-delete"><a href="#ForeignKey-on-delete" class="headerlink" title="ForeignKey.on_delete"></a>ForeignKey.on_delete</h4><p>当一个<code>ForeignKey</code> 引用的对象被删除时，Django 默认模拟<code>SQL</code> 的<code>ON DELETE CASCADE</code> 的约束行为，并且删除包含该<code>ForeignKey</code>的对象。这种行为可以通过设置<code>on_delete</code> 参数来改变。例如，如果你有一个可以为空的<code>ForeignKey</code>，在其引用的对象被删除的时你想把这个<code>ForeignKey</code> 设置为空：</p>
<pre class="lang:python decode:true ">user = models.ForeignKey(User, blank=True, null=True, on_delete=models.SET_NULL)</pre>

<p> <code>on_delete</code> 在<code>django.db.models</code>中可以找到的值有：</p>
<h4 id="CASCADE"><a href="#CASCADE" class="headerlink" title="CASCADE"></a>CASCADE</h4><p>级联删除；默认值。</p>
<h4 id="PROTECT"><a href="#PROTECT" class="headerlink" title="PROTECT"></a>PROTECT</h4><p>抛出<code>ProtectedError</code> 以阻止被引用对象的删除，它是<code>django.db.IntegrityError</code> 的一个子类。</p>
<h4 id="SET-NULL"><a href="#SET-NULL" class="headerlink" title="SET_NULL"></a>SET_NULL</h4><p>把<code>ForeignKey</code> 设置为<code>null</code>； <code>null</code> 参数为<code>True</code> 时才可以这样做。</p>
<h4 id="SET-DEFAULT"><a href="#SET-DEFAULT" class="headerlink" title="SET_DEFAULT"></a>SET_DEFAULT</h4><p><code>ForeignKey</code> 值设置成它的默认值；此时必须设置<code>ForeignKey</code> 的default 参数。</p>
<h4 id="SET"><a href="#SET" class="headerlink" title="SET()"></a>SET()</h4><p>设置<code>ForeignKey</code> 为传递给<code>SET()</code> 的值，如果传递的是一个可调用对象，则为调用后的结果。在大部分情形下，传递一个可调用对象用于避免<code>models.py</code> 在导入时执行查询：</p>
<pre class="lang:python decode:true ">from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import models

def get_sentinel_user():
    return get_user_model().objects.get_or_create(username='deleted')[0]

class MyModel(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL,
                             on_delete=models.SET(get_sentinel_user))</pre>

<h4 id="DO-NOTHING"><a href="#DO-NOTHING" class="headerlink" title="DO_NOTHING"></a>DO_NOTHING</h4><p>不采取任何动作。如果你的数据库后端强制引用完整性，它将引发一个<code>IntegrityError</code> ，除非你手动添加一个<code>ON DELETE</code> 约束给数据库自动（可能要用到初始化的SQL）。</p>
<h3 id="ForeignKey-swappable"><a href="#ForeignKey-swappable" class="headerlink" title="ForeignKey.swappable"></a>ForeignKey.swappable</h3><p><strong>New in Django 1.7.</strong></p>
<p>控制迁移框架的的重复行为如果该<code>ForeignKey</code> 指向一个可切换的模型。如果它是默认值True，那么如果ForeignKey 指向的模型与<code>settings.AUTH_USER_MODEL</code> 匹配（或其它可切换的模型），则保存在迁移中的关联关系将使用对setting 中引用而不是直接对模型的引用。</p>
<p>只有当你确定你的模型将永远指向切换后的模型 —— 例如如果它是专门为你的自定义用户模型设计的模型时，你才会想将它设置成<code>False</code>。</p>
<p>设置为<code>False</code> 并不表示你可以引用可切换的模型即使在它被切换出去之后 —— <code>False</code> 只是表示生成的迁移中<code>ForeignKey</code> 将始终引用你指定的准确模型（所以，如果用户试图允许一个你不支持的User 模型时将会失败）。</p>
<p>如果有疑问，请保留它的默认值<code>True</code>。</p>
<h3 id="ForeignKey-allow-unsaved-instance-assignment"><a href="#ForeignKey-allow-unsaved-instance-assignment" class="headerlink" title="ForeignKey.allow_unsaved_instance_assignment"></a>ForeignKey.allow_unsaved_instance_assignment</h3><p><strong>New in Django 1.8:</strong></p>
<p>添加这个标志是为了向后兼容，因为老版本的Django 始终允许赋值未保存的模型实例。</p>
<p>Django 阻止未保存的模型实例被分配给一个<code>ForeignKey</code> 字段以防止意味的数据丢失（当保存一个模型实例时，未保存的外键将默默忽略）。</p>
<p>如果你需要允许赋值未保存的实例且不关心数据的丢失（例如你不会保存对象到数据库），你可以通过创建这个字段的子类并设置其<code>allow_unsaved_instance_assignment</code> 属性为<code>True</code> 来关闭这个检查。例如：</p>
<pre class="lang:python decode:true ">class UnsavedForeignKey(models.ForeignKey):
    # A ForeignKey which can point to an unsaved object
    allow_unsaved_instance_assignment = True

class Book(models.Model):
    author = UnsavedForeignKey(Author)</pre>

<h2 id="ManyToManyField"><a href="#ManyToManyField" class="headerlink" title="ManyToManyField"></a>ManyToManyField</h2><p><code>class ManyToManyField(othermodel[, **options])</code></p>
<p>一个多对多关联。要求一个关键字参数：与该模型关联的类，与ForeignKey 的工作方式完全一样，包括<a href="http://python.usyiyi.cn/django_182/ref/models/fields.html#recursive-relationships" target="_blank" rel="external">递归关系</a> 和<a href="http://python.usyiyi.cn/django_182/ref/models/fields.html#lazy-relationships" target="_blank" rel="external">惰性关系</a>。</p>
<p>关联的对象可以通过字段的<code>RelatedManager</code>添加、删除和创建。</p>
<p>警告</p>
<p>不建议从一个没有迁移的应用中创建一个ForeignKey 到一个具有迁移的应用。 更多细节参见依赖性文档。</p>
<h3 id="数据库中的表示-1"><a href="#数据库中的表示-1" class="headerlink" title="数据库中的表示"></a>数据库中的表示</h3><p>在幕后，Django 创建一个中间表来表示多对多关系。默认情况下，这张中间表的名称使用多对多字段的名称和包含这张表的模型的名称生成。因为某些数据库支持的表的名字的长度有限制，这些标的名称将自动截短到64 个字符并加上一个唯一性的哈希值。这意味着，你看的表的名称可能类似 <code>author_books_9cdf4</code>；这再正常不过了。你可以使用<code>db_table</code> 选项手工提供中间表的名称。</p>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p><code>ManyToManyField</code> 接收一个参数集来控制关联关系的功能 —— 它们都是可选的。</p>
<h4 id="ManyToManyField-related-name"><a href="#ManyToManyField-related-name" class="headerlink" title="ManyToManyField.related_name"></a>ManyToManyField.related_name</h4><p>与<code>ForeignKey.related_name</code> 相同。</p>
<h4 id="ManyToManyField-related-query-name"><a href="#ManyToManyField-related-query-name" class="headerlink" title="ManyToManyField.related_query_name"></a>ManyToManyField.related_query_name</h4><p>与<code>ForeignKey.related_query_name</code> 相同。</p>
<h4 id="ManyToManyField-limit-choices-to"><a href="#ManyToManyField-limit-choices-to" class="headerlink" title="ManyToManyField.limit_choices_to"></a>ManyToManyField.limit_choices_to</h4><p>与<code>ForeignKey.limit_choices_to</code> 相同。</p>
<p><code>limit_choices_to</code> 对于使用<code>through</code> 参数自定义中间表的<code>ManyToManyField</code> 不生效。</p>
<h4 id="ManyToManyField-symmetrical"><a href="#ManyToManyField-symmetrical" class="headerlink" title="ManyToManyField.symmetrical"></a>ManyToManyField.symmetrical</h4><p>只用于与自身进行关联的<code>ManyToManyField</code>。例如下面的模型：</p>
<pre class="lang:python decode:true ">from django.db import models

class Person(models.Model):
    friends = models.ManyToManyField("self")</pre>

<p> 当Django 处理这个模型的时候，它定义该模型具有一个与自身具有多对多关联的<code>ManyToManyField</code>，因此它不会向Person 类添加<code>person_set</code> 属性。Django 将假定这个<code>ManyToManyField</code> 字段是对称的 —— 如果我是你的朋友，那么你也是我的朋友。</p>
<p>如果你希望与self 进行多对多关联的关系不具有对称性，可以设置<code>symmetrical</code> 为<code>False</code>。这会强制让Django 添加一个描述器给反向的关联关系，以使得<code>ManyToManyField</code> 的关联关系不是对称的。</p>
<h4 id="ManyToManyField-through"><a href="#ManyToManyField-through" class="headerlink" title="ManyToManyField.through"></a>ManyToManyField.through</h4><p>Django 会自动创建一个表来管理多对多关系。不过，如果你希望手动指定中介表，可以使用<code>through</code> 选项来指定Django 模型来表示你想要使用的中介表。</p>
<p>这个选项最常见的使用场景是当你想要关联额外的数据到多对多关联关系的时候。</p>
<p>如果你没有显式指定<code>through</code> 的模型，仍然会有一个隐式的<code>through</code> 模型类，你可以用它来直接访问对应的表示关联关系的数据库表。它由三个字段来链接模型。</p>
<p>如果源模型和目标不同，则生成以下字段：</p>
<ul>
<li><code>id</code>：关系的主键。</li>
<li><code>&amp;lt;containing_model&amp;gt;_id</code>：声明<code>ManyToManyField</code> 字段的模型的<code>id</code>。</li>
<li><code>&amp;lt;other_model&amp;gt;_id</code>：<code>ManyToManyField</code> 字段指向的模型的<code>id</code>。</li>
</ul>
<p>如果ManyToManyField 的源模型和目标模型相同，则生成以下字段：</p>
<ul>
<li>id：关系的主键。</li>
<li><code>from_&amp;lt;model&amp;gt;_id</code>：源模型实例的<code>id</code><!--more--><!--more-->。</li>
<li><code>to_&amp;lt;model&amp;gt;_id</code>：目标模型实例的<code>id</code>。</li>
</ul>
<p>这个类可以让一个给定的模型像普通的模型那样查询与之相关联的记录。</p>
<h4 id="ManyToManyField-through-fields"><a href="#ManyToManyField-through-fields" class="headerlink" title="ManyToManyField.through_fields"></a>ManyToManyField.through_fields</h4><p><strong>New in Django 1.7.</strong></p>
<p>只能在指定了自定义中间模型的时候使用。 Django 一般情况会自动决定使用中间模型的哪些字段来建立多对多关联。但是，考虑如下模型：</p>
<pre class="lang:python decode:true ">from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=50)

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership', through_fields=('group', 'person'))

class Membership(models.Model):
    group = models.ForeignKey(Group)
    person = models.ForeignKey(Person)
    inviter = models.ForeignKey(Person, related_name="membership_invites")
    invite_reason = models.CharField(max_length=64)</pre>

<p> Membership 有两个 外键指向Person （person 和inviter），这使得关联关系含混不清并让Django 不知道使用哪一个。在这种情况下，你必须使用<code>through_fields</code> 明确指定Django 应该使用哪些外键，就像上面例子一样。</p>
<p><code>through_fields</code> 接收一个二元组(‘field1’, ‘field2’)，其中field1 为指向定义<code>ManyToManyField</code> 字段的模型的外键名称（本例中为group），field2 为指向目标模型的外键的名称（本例中为person）。</p>
<p>当中间模型具有多个外键指向多对多关联关系模型中的任何一个（或两个），你必须 指定<code>through_fields</code>。这通用适用于递归的关联关系，当用到中间模型而有多个外键指向该模型时，或当你想显式指定Django 应该用到的两个字段时。</p>
<p>递归的关联关系使用的中间模型始终定义为非对称的，也就是<code>symmetrical=False</code> —— 所以具有源和目标的概念。这种情况下，’field1’ 将作为管理关系的源，而’field2’ 作为目标。</p>
<h4 id="ManyToManyField-db-table"><a href="#ManyToManyField-db-table" class="headerlink" title="ManyToManyField.db_table"></a>ManyToManyField.db_table</h4><p>为存储多对多数据而创建的表的名称。如果没有提供，Django 将基于定义关联关系的模型和字段假设一个默认的名称。</p>
<h4 id="ManyToManyField-db-constraint"><a href="#ManyToManyField-db-constraint" class="headerlink" title="ManyToManyField.db_constraint"></a>ManyToManyField.db_constraint</h4><p>控制中间表中的外键是否创建约束。默认为<code>True</code>，而且这是几乎就是你想要的；设置为<code>False</code> 对数据完整性将非常糟糕。下面是你可能需要这样设置的一些场景：</p>
<p>你具有不合法的遗留数据。</p>
<ul>
<li>你正在对数据库缩容。</li>
<li>不可以同时传递<code>db_constraint</code> 和 <code>through</code>。</li>
</ul>
<h4 id="ManyToManyField-swappable"><a href="#ManyToManyField-swappable" class="headerlink" title="ManyToManyField.swappable"></a>ManyToManyField.swappable</h4><p><strong>New in Django 1.7.</strong></p>
<p>控制<code>ManyToManyField</code> 指向一个可切换的模型时迁移框架的行为。如果它是默认值True，那么如果<code>ManyToManyField</code> 指向的模型与<code>settings.AUTH_USER_MODEL</code> 匹配（或其它可切换的模型），则保存在迁移中的关联关系将使用对<code>setting</code> 中引用而不是直接对模型的引用。</p>
<p>只有当你确定你的模型将永远指向切换后的模型 —— 例如如果它是专门为你的自定义用户模型设计的模型时，你才会想将它设置成<code>False</code>。</p>
<p>如果不确定，请将它保留为<code>True</code>。</p>
<h4 id="ManyToManyField-allow-unsaved-instance-assignment"><a href="#ManyToManyField-allow-unsaved-instance-assignment" class="headerlink" title="ManyToManyField.allow_unsaved_instance_assignment"></a>ManyToManyField.allow_unsaved_instance_assignment</h4><p>New in Django 1.8.</p>
<p>与<code>ForeignKey.allow_unsaved_instance_assignment</code> 的工作方式类似。</p>
<p><code>ManyToManyField</code> 不支持<code>validators</code>。</p>
<p><code>null</code> 不生效，因为无法在数据库层次要求关联关系。</p>
<h2 id="OneToOneField"><a href="#OneToOneField" class="headerlink" title="OneToOneField"></a>OneToOneField</h2><p><code>class OneToOneField(othermodel[, parent_link=False, **options])</code></p>
<p>一对一关联关系。概念上将，这个字段很像是<code>ForeignKey</code> 设置了<code>unique=True</code>，不同的是它会直接返回关系另一边的单个对象。</p>
<p>它最主要的用途是作为扩展自另外一个模型的主键；例如，多表继承就是通过对子模型添加一个隐式的一对一关联关系到父模型实现的。</p>
<p>需要一个位置参数：与该模型关联的类。 它的工作方式与<code>ForeignKey</code> 完全一致，包括所有与递归关系和惰性关系相关的选项。</p>
<p>如果你没有指定<code>OneToOneField</code> 的<code>related_name</code> 参数，Django 将使用当前模型的小写的名称作为默认值。</p>
<p>例如下面的例子：</p>
<pre class="lang:python decode:true ">from django.conf import settings
from django.db import models

class MySpecialUser(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL)
    supervisor = models.OneToOneField(settings.AUTH_USER_MODEL, related_name='supervisor_of')</pre>

<p> 你将使得User 模型具有以下属性：</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; user = User.objects.get(pk=1)
&gt;&gt;&gt; hasattr(user, 'myspecialuser')
True
&gt;&gt;&gt; hasattr(user, 'supervisor_of')
True</pre>

<p> 当反向访问关联关系时，如果关联的对象不存在对应的实例，则抛出<code>DoesNotExist</code> 异常。例如，如果一个User 没有<code>MySpecialUser</code> 指定的<code>supervisor</code>：</p>
<pre class="lang:default decode:true ">&gt;&gt;&gt; user.supervisor_of
Traceback (most recent call last):
    ...
DoesNotExist: User matching query does not exist.</pre>

<p> 另外，<code>OneToOneField</code> 除了接收<code>ForeignKey</code> 接收的所有额外的参数之外，还有另外一个参数：</p>
<h3 id="OneToOneField-parent-link"><a href="#OneToOneField-parent-link" class="headerlink" title="OneToOneField.parent_link"></a>OneToOneField.parent_link</h3><p>当它为True 并在继承自另一个具体模型 的模型中使用时，表示该字段应该用于反查的父类的链接，而不是在子类化时隐式创建的<code>OneToOneField</code>。</p>
<p><code>OneToOneField</code> 的使用示例参见<code>One-to-one</code> <a href="http://python.usyiyi.cn/django_182/topics/db/examples/one_to_one.html" target="_blank" rel="external">关联关系</a>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/02/02/django-e5-85-83-e9-80-89-e9-a1-b9-e5-8f-82-e8-80-83/" class="prev">上一篇</a><a href="/2016/01/28/charlescharles-e4-bd-bf-e7-94-a8-e6-95-99-e7-a8-8b-e6-8c-87-e5-8d-97/" class="next">下一篇</a></div><div class="copyright"><p>© 2013 - 2017 <a href="http://kidozh.com">kido zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>