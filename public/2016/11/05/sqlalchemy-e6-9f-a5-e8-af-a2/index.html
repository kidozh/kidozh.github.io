<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SQLAlchemy查询 · kidozh</title><meta name="description" content="SQLAlchemy查询 - kido zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://kidozh.com/atom.xml" title="kidozh"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1793490853" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/kidozh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SQLAlchemy查询</h1><div class="post-info">2016年11月5日</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>和Django一样，我们orm也要知道如何查询数据。</p>
<h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><p><code>Session</code>的<code>query</code>函数会返回一个<code>Query</code>对象。<code>query</code>函数可以接受多种参数类型。可以是类，或者是类的instrumented <strong>descriptor</strong>。下面的这个例子取出了所有的<code>User</code>记录。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for instance in session.query(User).order_by(User.id):
...     print(instance.name, instance.fullname)
ed Ed Jones
wendy Wendy Williams
mary Mary Contrary
fred Fred Flinstone</pre>

<p><code>Query</code>也接受ORM-instrumented descriptors作为参数。当多个参数传入时，返回结果为以同样顺序排列的tuples</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for name, fullname in session.query(User.name, User.fullname):
...     print(name, fullname)
ed Ed Jones
wendy Wendy Williams
mary Mary Contrary
fred Fred Flinstone</pre>

<p><code>Query</code>返回的tuples由<code>KeyedTuple</code>这个类提供，其成员除了用下标访问意外，还可以视为实例变量来获取。对应的变量的名称与被查询的类变量名称一样，如下例：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for row in session.query(User, User.name).all():
...    print(row.User, row.name)
&lt;User(name='ed', fullname='Ed Jones', password='f8s7ccs')&gt; ed
&lt;User(name='wendy', fullname='Wendy Williams', password='foobar')&gt; wendy
&lt;User(name='mary', fullname='Mary Contrary', password='xxg527')&gt; mary
&lt;User(name='fred', fullname='Fred Flinstone', password='blah')&gt; fred</pre>

<p>你可以通过<code>label()</code>来制定descriptor对应实例变量的名称</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for row in session.query(User.name.label('name_label')).all():
...    print(row.name_label)
ed
wendy
mary
fred</pre>

<p>而对于类参数而言，要实现同样的定制需要使用<code>aliased</code></p>
<pre class="lang:python decode:true">&gt;&gt;&gt; from sqlalchemy.orm import aliased
&gt;&gt;&gt; user_alias = aliased(User, name='user_alias')

SQL&gt;&gt;&gt; for row in session.query(user_alias, user_alias.name).all():
...    print(row.user_alias)
&lt;User(name='ed', fullname='Ed Jones', password='f8s7ccs')&gt;
&lt;User(name='wendy', fullname='Wendy Williams', password='foobar')&gt;
&lt;User(name='mary', fullname='Mary Contrary', password='xxg527')&gt;
&lt;User(name='fred', fullname='Fred Flinstone', password='blah')&gt;</pre>

<p>基本的查询操作除了上面这些之外，还包括OFFSET和LIMIT，这个可以通过Python的array slice来完成。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for u in session.query(User).order_by(User.id)[1:3]:
...    print(u)
&lt;User(name='wendy', fullname='Wendy Williams', password='foobar')&gt;
&lt;User(name='mary', fullname='Mary Contrary', password='xxg527')&gt;</pre>

<p>上述过程实际上只涉及了整体取出的操作，而没有进行筛选，筛选常用的函数是<code>filter_by</code>和<code>filter</code>。其中后者比起前者要更灵活一些，你可以在后者的参数中使用python的运算符。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for name, in session.query(User.name).\
...             filter_by(fullname='Ed Jones'):
...    print(name)
ed
&gt;&gt;&gt; for name, in session.query(User.name).\
...             filter(User.fullname=='Ed Jones'):
...    print(name)
ed</pre>

<p>注意<code>Query</code>对象是<strong>generative</strong>的，这意味你可以把他们串接起来调用，如下：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; for user in session.query(User).\
...          filter(User.name=='ed').\
...          filter(User.fullname=='Ed Jones'):
...    print(user)
&lt;User(name='ed', fullname='Ed Jones', password='f8s7ccs')&gt;</pre>

<p>串接的<code>filter</code>之间是<strong>与</strong>的关系。</p>
<h1 id="常用的filter操作符"><a href="#常用的filter操作符" class="headerlink" title="常用的filter操作符"></a>常用的filter操作符</h1><p>下面的这些操作符可以应用在<code>filter</code>函数中</p>
<ul>
<li><p><code>equals</code>:</p>
<p>query.filter(User.name == <span class="hljs-string">‘ed’</span>)`</p>
</li>
<li><p><code>not equals</code>:</p>
<pre class="hljs bash">`query.filter(User.name != <span class="hljs-string">'ed'</span>)`</pre></li>
<li><p><code>LIKE</code>:</p>
<pre class="hljs bash">`query.filter(User.name.like(<span class="hljs-string">'%ed%'</span>))`</pre></li>
<li><p><code>IN</code>:</p>
<pre class="hljs bash">`query.filter(User.name.in_([<span class="hljs-string">'ed'</span>, <span class="hljs-string">'wendy'</span>, <span class="hljs-string">'jack'</span>]))

<span class="hljs-comment"># works with query objects too:</span>
query.filter(User.name.in_(
        session.query(User.name).filter(User.name.like(<span class="hljs-string">'%ed%'</span>))
))`</pre>
</li>
<li><p><code>NOT IN</code>:</p>
<pre class="hljs bash">`query.filter(~User.name.in_([<span class="hljs-string">'ed'</span>, <span class="hljs-string">'wendy'</span>, <span class="hljs-string">'jack'</span>]))`</pre>
</li>
<li><p><code>IS NULL</code>:</p>
<pre class="hljs bash">`query.filter(User.name == None)

<span class="hljs-comment"># alternatively, if pep8/linters are a concern</span>
query.filter(User.name.is_(None))`</pre>
</li>
<li><p><code>IS NOT NULL</code>:</p>
<pre class="hljs bash">`query.filter(User.name != None)

<span class="hljs-comment"># alternatively, if pep8/linters are a concern</span>
query.filter(User.name.isnot(None))`</pre>
</li>
<li><p><code>AND</code>:</p>
<pre class="hljs bash">`<span class="hljs-comment"># use and_()</span>
from sqlalchemy import and_
query.filter(and_(User.name == <span class="hljs-string">'ed'</span>, User.fullname == <span class="hljs-string">'Ed Jones'</span>))

<span class="hljs-comment"># or send multiple expressions to .filter()</span>
query.filter(User.name == <span class="hljs-string">'ed'</span>, User.fullname == <span class="hljs-string">'Ed Jones'</span>)

<span class="hljs-comment"># or chain multiple filter()/filter_by() calls</span>
query.filter(User.name == <span class="hljs-string">'ed'</span>).filter(User.fullname == <span class="hljs-string">'Ed Jones'</span>)`</pre>
</li>
<li><p><code>OR</code>:</p>
<pre class="hljs bash">`from sqlalchemy import or_
query.filter(or_(User.name == <span class="hljs-string">'ed'</span>, User.name == <span class="hljs-string">'wendy'</span>))`</pre>
</li>
<li><p><code>MATCH</code>:</p>
<pre class="hljs bash">`query.filter(User.name.match(<span class="hljs-string">'wendy'</span>))`</pre>

<h1 id="返回列表-List-和单项-Scalar"><a href="#返回列表-List-和单项-Scalar" class="headerlink" title="返回列表(List)和单项(Scalar)"></a>返回列表(List)和单项(Scalar)</h1><p>很多<code>Query</code>的方法执行了SQL命令并返回了取出的数据库结果。</p>
</li>
<li><p><code>all()</code>返回一个列表:</p>
<pre class="hljs bash">`&gt;&gt;&gt; query = session.query(User).filter(User.name.like(<span class="hljs-string">'%ed'</span>)).order_by(User.id)
SQL&gt;&gt;&gt; query.all()
[&lt;User(name=<span class="hljs-string">'ed'</span>, fullname=<span class="hljs-string">'Ed Jones'</span>, password=<span class="hljs-string">'f8s7ccs'</span>)&gt;,
    &lt;User(name=<span class="hljs-string">'fred'</span>, fullname=<span class="hljs-string">'Fred Flinstone'</span>, password=<span class="hljs-string">'blah'</span>)&gt;]`</pre></li>
<li><p><code>first()</code>返回至多一个结果，而且以单项形式，而不是只有一个元素的tuple形式返回这个结果.</p>
<pre class="hljs bash">`&gt;&gt;&gt; query.first()
&lt;User(name=<span class="hljs-string">'ed'</span>, fullname=<span class="hljs-string">'Ed Jones'</span>, password=<span class="hljs-string">'f8s7ccs'</span>)&gt;`</pre>
</li>
<li><p><code>one()</code>返回且仅返回一个查询结果。当结果的数量不足一个或者多于一个时会报错。</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; user = query.one()
Traceback (most recent call last):
...
MultipleResultsFound: Multiple rows were found for one()</pre>

<p>没有查找到结果时：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; user = query.filter(User.id == 99).one()
Traceback (most recent call last):
...
NoResultFound: No row was found for one()</pre>
</li>
<li><p><code>one_or_none()</code>：从名称可以看出，当结果数量为0时返回<code>None</code>， 多于1个时报错</p>
</li>
<li><p><code>scalar()</code>和<code>one()</code>类似，但是返回单项而不是tuple</p>
<h1 id="嵌入使用SQL"><a href="#嵌入使用SQL" class="headerlink" title="嵌入使用SQL"></a>嵌入使用SQL</h1><p>你可以在<code>Query</code>中通过<code>text()</code>使用SQL语句。例如：</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; from sqlalchemy import text
&gt;&gt;&gt; for user in session.query(User).\
...             filter(text("id&lt;224")).\
...             order_by(text("id")).all():
...     print(user.name)
ed
wendy
mary
fred</pre>

<p>除了上面这种直接将参数写进字符串的方式外，你还可以通过<code>params()</code>方法来传递参数</p>
<pre class="lang:python decode:true">&gt;&gt;&gt; session.query(User).filter(text("id&lt;:value and name=:name")).\
...     params(value=224, name='fred').order_by(User.id).one()
&lt;User(name='fred', fullname='Fred Flinstone', password='blah')&gt;</pre>

<p>并且，你可以直接使用完整的SQL语句，但是要注意将表名和列明写正确。</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(User).from_statement(
...                     text(<span class="hljs-string">"SELECT * FROM users where name=:name"</span>)).\
...                     params(name=<span class="hljs-string">'ed'</span>).all()
[&lt;User(name=<span class="hljs-string">'ed'</span>, fullname=<span class="hljs-string">'Ed Jones'</span>, password=<span class="hljs-string">'f8s7ccs'</span>)&gt;]`</pre>

<h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><p><code>Query</code>定义了一个很方便的计数函数<code>count()</code></p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(User).filter(User.name.like(<span class="hljs-string">'%ed'</span>)).count()
SELECT count(*) AS count_1
FROM (SELECT users.id AS users_id,
                users.name AS users_name,
                users.fullname AS users_fullname,
                users.password AS users_password
FROM users
WHERE users.name LIKE ?) AS anon_1
(<span class="hljs-string">'%ed'</span>,)
<span class="hljs-number">2</span>`</pre>

<p>注意上面我们同时列出了实际的SQL指令。在SQLAlchemy中，我们总是将被计数的查询打包成一个子查询，然后对这个子查询进行计数。即便是最简单的<code>SELECT count(*) FROM table</code>，也会如此处理。为了更精细的控制计数过程，我们可以采用<code>func.count()</code>这个函数。</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy import func
SQL&gt;&gt;&gt; session.query(func.count(User.name), User.name).group_by(User.name).all()
SELECT count(users.name) AS count_1, users.name AS users_name
FROM users GROUP BY users.name
()
[(<span class="hljs-number">1</span>, u<span class="hljs-string">'ed'</span>), (<span class="hljs-number">1</span>, u<span class="hljs-string">'fred'</span>), (<span class="hljs-number">1</span>, u<span class="hljs-string">'mary'</span>), (<span class="hljs-number">1</span>, u<span class="hljs-string">'wendy'</span>)]`</pre>

<p>为了实现最简单的<code>SELECT count(*) FROM table</code>，我们可以如下调用</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(func.count(<span class="hljs-string">'*'</span>)).select_from(User).scalar()
SELECT count(?) AS count_1
FROM users
(<span class="hljs-string">'*'</span>,)
<span class="hljs-number">4</span>`</pre>

<p>如果我们对<code>User</code>的主键进行计数，那么<code>select_from</code>也可以省略。</p>
<p><pre class="hljs bash">`&gt;&gt;&gt; session.query(func.count(User.id)).scalar()<br>SELECT count(users.id) AS count_1<br>FROM users<br>()<br><span class="hljs-number">4</span></pre></p>
</li>
</ul>
<p>在下一篇教程里面我们将会介绍SQLAlchemy对于『关系』的处理方式，以及针对关系的更加复杂的查询。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/11/05/sqlalchemy-e5-85-b3-e7-b3-bb/" class="prev">上一篇</a><a href="/2016/11/05/sqlalchemy-e4-bb-8b-e7-bb-8d/" class="next">下一篇</a></div><div class="copyright"><p>© 2013 - 2017 <a href="http://kidozh.com">kido zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>