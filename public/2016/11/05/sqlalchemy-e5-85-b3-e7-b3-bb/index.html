<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SQLAlchemy关系 · kidozh</title><meta name="description" content="SQLAlchemy关系 - kido zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://kidozh.com/atom.xml" title="kidozh"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1793490853" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/kidozh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SQLAlchemy关系</h1><div class="post-info">2016年11月5日</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>『关系』是关系型数据库的一大特色，也是我们在建模过程中的一个重要的抽象过程。在前面的两个教程中，我们分别回顾了使用SQLAlchemy在数据库中进行<a href="http://www.jianshu.com/p/0d234e14b5d3" target="_blank" rel="external">创建</a>和<a href="http://www.jianshu.com/p/8d085e2f2657" target="_blank" rel="external">简单查询</a>的方法，今天我们来深入到更为复杂和抽象部分。</p>
<h1 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h1><p>之前我们已经建立了一个用户(User)表，现在我们来考虑增加一个与用户关联的新的表。在我们的系统里面，用户可以存储多个与之相关的email地址。这是一种基本的一对多的关系。我们把这个新增加的存储email地址的表称为<code>addresses</code>。应用Declarative，我们按照如下方式定义这个新表：</p>
<pre><code>&amp;gt;&amp;gt;&amp;gt; from sqlalchemy import ForeignKey
&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.orm import relationship

&amp;gt;&amp;gt;&amp;gt; class Address(Base):
...     __tablename__ = &lt;span class=&quot;hljs-string&quot;&gt;&apos;addresses&apos;&lt;/span&gt;
...     id = Column(Integer, primary_key=True)
...     email_address = Column(String, nullable=False)
...     user_id = Column(Integer, ForeignKey(&lt;span class=&quot;hljs-string&quot;&gt;&apos;users.id&apos;&lt;/span&gt;))
...
...     user = relationship(&lt;span class=&quot;hljs-string&quot;&gt;&quot;User&quot;&lt;/span&gt;, back_populates=&lt;span class=&quot;hljs-string&quot;&gt;&quot;addresses&quot;&lt;/span&gt;)
...
...     def __repr__(self):
...         &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;Address(email_address=&apos;%s&apos;)&amp;gt;&quot;&lt;/span&gt; % self.email_address

&amp;gt;&amp;gt;&amp;gt; User.addresses = relationship(
...     &lt;span class=&quot;hljs-string&quot;&gt;&quot;Address&quot;&lt;/span&gt;, order_by=Address.id, back_populates=&lt;span class=&quot;hljs-string&quot;&gt;&quot;user&quot;&lt;/span&gt;)`&lt;/pre&gt;

上面的代码中我们使用了一个新的名为`ForeignKey`的构造。其含义为，其所在的列的值域应当被限制在另一个表的指定列的取值范围之类。这一特性是关系型数据库的核心特性之一。就上例而言，`addresses.user_id`这一列的取值范围，应当包含在`users.id`的取值范围之内。

除了`ForeignKey`之外，我们还引入了一个`relationship`，来告诉ORM，`Address`类需要被连接到`User`类。`relationship`和`ForeignKey`这个两个属性决定了表之间关系的属性，决定了这个关系是多对一的。

在完成对`Address`类的声明之后，我们还定义另一个`relationship`，将其赋值给了`User.addresses`。在两个`relationship`中，我们都有传入了一个`relationship.back_populates`的属性来为反向关系所对应的属性进行命名。（作者：到这里为止，看来SQLAlchemy中定义关系要比Django的ORM要麻烦许多。Django中只需要一行就可以了。而且这里的两个`relationship`的定义明显是冗余的）

多对一的关系的反向永远都是一对多的关系。关于更多的`relationship()`的配置方法，可以参见这个链接[Basic Relationship Patterns](http://docs.sqlalchemy.org/en/rel_1_0/orm/basic_relationships.html#relationship-patterns)。

上述我们定义的两个互补的关系`Address.user`和`User.addresses`被称为双向关系([bidirectional relationship](http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-bidirectional-relationship))，这是SQLAlchemy的核心特性这一。

`relationship()`的参数配置中指向被连接的类的字符串，可以指向工程中任何位置所定义的，基于`declarative base`的类，而无先后之分。Declarative会在完成所有的映射以后的将这些字符串转换为适当的、实际使用的参数形式。

# 使用关联对象

现在，当我们创建一个`User`实例的时候，会同时创建一个空的`addresses`的collection。这个collection可能是多种类型，如list, set, 或是dictionary。默认情况下，其应当为一个Python列表。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack = User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; jack.addresses
[]`&lt;/pre&gt;

此时你可以自由的向这个列表里面插入`User`对象。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack.addresses = [
...                 Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;),
...                 Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)]`&lt;/pre&gt;

当使用bidirectional relationship时，通过其中一个方向的关系（如上例）会自动出现在另一个方向的关系上。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack.addresses[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]
&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; jack.addresses[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].user
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

让我们把jack添加进入`Session`。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; session.add(jack)
&amp;gt;&amp;gt;&amp;gt; session.commit()
INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)
INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)
INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)
COMMIT`&lt;/pre&gt;

可以发现上面执行了三个`INSERT`命令，也就是说与jack关联的两个`Address`对象也被提交了。现在我们通过查询来取出jack。

&lt;pre class=&quot;hljs php&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack = session.query(User).\
... filter_by(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;).one()
BEGIN (implicit)
SELECT users.id &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_id,
        users.name &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_name,
        users.fullname &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_fullname,
        users.password &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; users_password
FROM users
WHERE users.name = ?
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;,)

&amp;gt;&amp;gt;&amp;gt; jack
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

可以发现目前只有针对`User`表的查询，而没有对`Address`表的查询。此时访问`addresses`属性，相关的SQL才会执行

&lt;pre class=&quot;hljs php&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; jack.addresses
SELECT addresses.id &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; addresses_id,
        addresses.email_address &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt;
        addresses_email_address,
        addresses.user_id &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; addresses_user_id
FROM addresses
WHERE ? = addresses.user_id ORDER BY addresses.id
(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,)
[&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;)&amp;gt;, &amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)&amp;gt;]`&lt;/pre&gt;

上面这种方式我们称之为[lazy loading](http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-lazy-loading)。

# 使用join进行查询

现在我们有了两会在那个彼此关联的数据表了，相比与上一篇教程中的简单查询情况，此时试图对这两张表进行联合查询就更加复杂一些了。关于join技术，读者可以自行阅读[我的前一篇文章](http://www.jianshu.com/p/9e1d3793cba6)。

为了在`User`和`Address`之间构造一个简单的join，我们可以通过`Query.filter()`来连接其相关列（本质是隐式写法的JOIN）。下面是一个简单的例子：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; u, a &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User, Address).\
...                     filter(User.id==Address.user_id).\
...                     filter(Address.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;).\
...                     all():
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(u)
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a)
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;
&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

而实际的SQL JOIN语法，可以通过`Query.join()`来想实现

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; session.query(User).join(Address).\
...         filter(Address.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;).\
...         all()
users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users JOIN addresses ON users.id = addresses.user_id
WHERE addresses.email_address = ?
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;,)
[&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;]`&lt;/pre&gt;

在上面的例子中由于只存在一个ForeignKey，`Query.join`知道如何选取合适的列进行JOIN。如果没有定义ForeignKey，或者存在多个，此时你需要手动指明你参与JOIN的列。`Query.join()`以如下方式进行：

&lt;pre class=&quot;hljs bash&quot;&gt;`query.join(Address, User.id==Address.user_id)    &lt;span class=&quot;hljs-comment&quot;&gt;# explicit condition&lt;/span&gt;
query.join(User.addresses)                       &lt;span class=&quot;hljs-comment&quot;&gt;# specify relationship from left to right&lt;/span&gt;
query.join(Address, User.addresses)              &lt;span class=&quot;hljs-comment&quot;&gt;# same, with explicit target&lt;/span&gt;
query.join(&lt;span class=&quot;hljs-string&quot;&gt;&apos;addresses&apos;&lt;/span&gt;)`&lt;/pre&gt;

对于OUTER JOIN，只需要使用`Query.outerjoin()`就可以了。

&lt;pre class=&quot;hljs bash&quot;&gt;`query.outerjoin(User.addresses)   &lt;span class=&quot;hljs-comment&quot;&gt;# LEFT OUTER JOIN&lt;/span&gt;`&lt;/pre&gt;

关于`join()`更为详细的用法，还是请参考官方的文档[join](http://docs.sqlalchemy.org/en/rel_1_0/orm/query.html#sqlalchemy.orm.query.Query.join)

## 使用Aliases

当你的查询涉及多个表，而其中同一个表出现了多次时，你需要的为重复的表aliase一个新的名字来避免冲突。这个功能其实我们在上一篇文章里面也提到过，下面是关于`aliased`的一个例子：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.orm import aliased
&amp;gt;&amp;gt;&amp;gt; adalias1 = aliased(Address)
&amp;gt;&amp;gt;&amp;gt; adalias2 = aliased(Address)
&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; username, email1, email2 &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; \
...     session.query(User.name, adalias1.email_address, adalias2.email_address).\
...     join(adalias1, User.addresses).\
...     join(adalias2, User.addresses).\
...     filter(adalias1.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;).\
...     filter(adalias2.email_address==&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(username, email1, email2)
SELECT users.name AS users_name,
        addresses_1.email_address AS addresses_1_email_address,
        addresses_2.email_address AS addresses_2_email_address
FROM users JOIN addresses AS addresses_1
        ON users.id = addresses_1.user_id
JOIN addresses AS addresses_2
        ON users.id = addresses_2.user_id
WHERE addresses_1.email_address = ?
        AND addresses_2.email_address = ?
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;)
jack jack@google.com j25@yahoo.com`&lt;/pre&gt;

## 使用子查询(Subqueries)

`Query`适合于用来构造子查询。假如我们想要取出`User`记录，并且同时计算各个用户的`Address`的数量。产生这种功能的SQL指令最好的办法是按照user的id分组统计地址的数量，然后join到外层查询。此时我们需要LEFT JOIN，这样可以使得没有地址的用户也会出现在查询结果中（地址数量为0）。 我们期望的SQL命令是这样的：

&lt;pre class=&quot;hljs sql&quot;&gt;`&lt;span class=&quot;hljs-operator&quot;&gt;SELECT &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;.*, adr_count.address_count &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OUTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;JOIN&lt;/span&gt;
    (SELECT user_id, &lt;span class=&quot;hljs-keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; address_count
        &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; addresses &lt;span class=&quot;hljs-keyword&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; user_id) &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; adr_count
    &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;=adr_count.user_id&lt;/span&gt;`&lt;/pre&gt;

使用`Query`，我们可以从内到外来构造上面的语句。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.sql import func
&amp;gt;&amp;gt;&amp;gt; stmt = session.query(Address.user_id, func.count(&lt;span class=&quot;hljs-string&quot;&gt;&apos;*&apos;&lt;/span&gt;).\
...         label(&lt;span class=&quot;hljs-string&quot;&gt;&apos;address_count&apos;&lt;/span&gt;)).\
...         group_by(Address.user_id).subquery()`&lt;/pre&gt;

`func`我们已经在之前的教程中认识过了。`subquery()`可以产生一个内嵌了alias（是一个`query.statement.alias()`）的查询(SELECT)语句的表达。

当我们生成了statement之后，其完全可以视为一个`Table`来使用。你可以通过`c`来访问它的属性。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; u, count &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User, stmt.c.address_count).\
...     outerjoin(stmt, User.id==stmt.c.user_id).order_by(User.id):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(u, count)
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        anon_1.address_count AS anon_1_address_count
FROM users LEFT OUTER JOIN
    (SELECT addresses.user_id AS user_id, count(?) AS address_count
    FROM addresses GROUP BY addresses.user_id) AS anon_1
    ON users.id = anon_1.user_id
ORDER BY users.id
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;*&apos;&lt;/span&gt;,)
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;ed&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Ed Jones&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;f8s7ccs&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;wendy&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Wendy Williams&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;foobar&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;mary&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Mary Contrary&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;xxg527&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;fred&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Fred Flinstone&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;blah&apos;&lt;/span&gt;)&amp;gt; None
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;`&lt;/pre&gt;

## 从子查询中取出Entity

在前一个例子中，我们从子查询活着的是一个临时性的JOIN后的表，但是这个表并未定义我们在ORM中定义的Entity。如果我们想将这个临时表映射到ORM中的类呢？此时我们可以使用`aliased`这个函数来完成这个映射。

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; stmt = session.query(Address).\
...                 filter(Address.email_address != &lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;).\
...                 subquery()
&amp;gt;&amp;gt;&amp;gt; adalias = aliased(Address, stmt)
&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; user, address &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User, adalias).\
...         join(adalias, User.addresses):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(user)
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(address)
SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            anon_1.id AS anon_1_id,
            anon_1.email_address AS anon_1_email_address,
            anon_1.user_id AS anon_1_user_id
FROM users JOIN
    (SELECT addresses.id AS id,
            addresses.email_address AS email_address,
            addresses.user_id AS user_id
    FROM addresses
    WHERE addresses.email_address != ?) AS anon_1
    ON users.id = anon_1.user_id
(&lt;span class=&quot;hljs-string&quot;&gt;&apos;j25@yahoo.com&apos;&lt;/span&gt;,)
&amp;lt;User(name=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;, fullname=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack Bean&apos;&lt;/span&gt;, password=&lt;span class=&quot;hljs-string&quot;&gt;&apos;gjffdd&apos;&lt;/span&gt;)&amp;gt;
&amp;lt;Address(email_address=&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack@google.com&apos;&lt;/span&gt;)&amp;gt;`&lt;/pre&gt;

# 使用EXISTS

EXISTS关键字是一个BOOL型操作符。当查询结果存在至少一行时返回True。EXISTS可以常常和JOIN搭配使用。

下面是一个显式的EXISTS构造方法：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; from sqlalchemy.sql import exists
&amp;gt;&amp;gt;&amp;gt; stmt = exists().where(Address.user_id==User.id)
&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User.name).filter(stmt):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(name)
SELECT users.name AS users_name
FROM users
WHERE EXISTS (SELECT *
FROM addresses
WHERE addresses.user_id = users.id)
()
jack`&lt;/pre&gt;

`Query`还定义了若干个自动使用了EXISTS的操作。上面的例子可以用`any()`来完成：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User.name).\
...         filter(User.addresses.any()):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(name)
SELECT users.name AS users_name
FROM users
WHERE EXISTS (SELECT &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
FROM addresses
WHERE users.id = addresses.user_id)
()
jack`&lt;/pre&gt;

`any()`也接受筛选条件来限制匹配的行：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; session.query(User.name).\
...     filter(User.addresses.any(Address.email_address.like(&lt;span class=&quot;hljs-string&quot;&gt;&apos;%google%&apos;&lt;/span&gt;))):
...     &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(name)
jack`&lt;/pre&gt;

`has()`对于的many-to-one的关系，起到的是和`any()`同样的作用（注意这里`~`表示NOT）：

&lt;pre class=&quot;hljs bash&quot;&gt;`&amp;gt;&amp;gt;&amp;gt; session.query(Address).\
...         filter(~Address.user.has(User.name==&lt;span class=&quot;hljs-string&quot;&gt;&apos;jack&apos;&lt;/span&gt;)).all()
[]`&lt;/pre&gt;

## 常用的关系操作

下面只是简单的列出了一些常用的操作。想要更为详细的了解这些功能，还是推荐去官网的相关文档。
</code></pre><ul>
<li><p><strong>eq</strong>() (many-to-one “equals” comparison):</p>
<pre class="hljs swift">`query.<span class="hljs-built_in">filter</span>(<span class="hljs-type">Address</span>.user == someuser)`</pre>
</li>
<li><p><strong>ne</strong>() (many-to-one “not equals” comparison):</p>
<pre class="hljs swift">`query.<span class="hljs-built_in">filter</span>(<span class="hljs-type">Address</span>.user != someuser)`</pre>
</li>
<li><p>IS NULL (many-to-one comparison, also uses <strong>eq</strong>()):</p>
<pre class="hljs python">`query.filter(Address.user == <span class="hljs-keyword">None</span>)`</pre>
</li>
<li><p>contains() (used for one-to-many collections):</p>
<pre class="hljs css">`<span class="hljs-tag">query</span><span class="hljs-class">.filter</span>(<span class="hljs-tag">User</span><span class="hljs-class">.addresses</span><span class="hljs-class">.contains</span>(<span class="hljs-tag">someaddress</span>))`</pre>
</li>
<li><p>any() (used for collections):</p>
<pre class="hljs bash">`query.filter(User.addresses.any(Address.email_address == <span class="hljs-string">'bar'</span>))

<span class="hljs-comment"># also takes keyword arguments:</span>
query.filter(User.addresses.any(email_address=<span class="hljs-string">'bar'</span>))`</pre>
</li>
<li><p>has() (used for scalar references):</p>
<pre class="hljs bash">`query.filter(Address.user.has(name=<span class="hljs-string">'ed'</span>))`</pre>
</li>
<li><p>Query.with_parent() (used for any relationship):</p>
<pre class="hljs bash">`session.query(Address).with_parent(someuser, <span class="hljs-string">'addresses'</span>)`</pre>

<h2 id="Eager-Loading（找不到合适的翻译）"><a href="#Eager-Loading（找不到合适的翻译）" class="headerlink" title="Eager Loading（找不到合适的翻译）"></a>Eager Loading（找不到合适的翻译）</h2><p>前面的教程中我们有提及到lazing loading的机制。当我们通过查询取出用户时，与之关联的地址并没有取出来。当我们试图获取<code>User.addresses</code>时，相关的针对地址的SQL查询才起作用。如果你想要减少query的次数的话，就需要使用Eager Loading了。SQLAlchemy提供了三种Eager Loading的方式，其中两种是自动的，而第三种涉及到自定义的筛选条件。所有的这三种Eager Loading方式都会通过调用<code>Query.options()</code>来影响查询的过程，促使<code>Query</code>生成需要的额外配置来取出期望的内容。</p>
<h1 id="Subquery-Loading"><a href="#Subquery-Loading" class="headerlink" title="Subquery Loading"></a>Subquery Loading</h1><p>在上面的例子中，我们希望在 取出用户的时候就同步取出对应的地址。此时你们可以此采用<code>orm.subqueryload()</code>。这个函数可以发起第二个SELECT查询来取出与结果相关的另一个表的信息。这里取名为”subquery”的原因是，此处的<code>Query</code>在发起第二个查询时作为子查询而被复用了。详细过程参加下面的程序：</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy.orm import subqueryload
&gt;&gt;&gt; jack = session.query(User).\
...                 options(subqueryload(User.addresses)).\
...                 filter_by(name=<span class="hljs-string">'jack'</span>).one()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users
WHERE users.name = ?
(<span class="hljs-string">'jack'</span>,)
SELECT addresses.id AS addresses_id,
        addresses.email_address AS addresses_email_address,
        addresses.user_id AS addresses_user_id,
        anon_1.users_id AS anon_1_users_id
FROM (SELECT users.id AS users_id
    FROM users WHERE users.name = ?) AS anon_1
JOIN addresses ON anon_1.users_id = addresses.user_id
ORDER BY anon_1.users_id, addresses.id
(<span class="hljs-string">'jack'</span>,)
&gt;&gt;&gt; jack
&lt;User(name=<span class="hljs-string">'jack'</span>, fullname=<span class="hljs-string">'Jack Bean'</span>, password=<span class="hljs-string">'gjffdd'</span>)&gt;

&gt;&gt;&gt; jack.addresses
[&lt;Address(email_address=<span class="hljs-string">'jack@google.com'</span>)&gt;, &lt;Address(email_address=<span class="hljs-string">'j25@yahoo.com'</span>)&gt;]`</pre>

<p><strong>注意</strong>：当<code>subqueryload()</code>和涉及limiting的函数一起使用的时候（如<code>Query.first()</code>, <code>Query.limit()</code>, Query.offset()<code>等），应当加上一个以Unique的行作为参数的</code>Query.order_by()`来确保结果的正确性。详情参见<a href="http://docs.sqlalchemy.org/en/rel_1_0/orm/loading_relationships.html#subqueryload-ordering" target="_blank" rel="external">The importance of Ordering</a></p>
<h1 id="Joined-Load"><a href="#Joined-Load" class="headerlink" title="Joined Load"></a>Joined Load</h1><p>这种自动Eager Loading的方式要更为常用一些。Joined Loading发起了一个JOIN（默认是LEFT OUTER JOIN），故而查询结果和制定的与之关联的行可以被同时取出。我们这里以和上面的Subquery Loading中同样的查询目的为例。</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy.orm import joinedload

&gt;&gt;&gt; jack = session.query(User).\
...                        options(joinedload(User.addresses)).\
...                        filter_by(name=<span class="hljs-string">'jack'</span>).one()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        addresses_1.id AS addresses_1_id,
        addresses_1.email_address AS addresses_1_email_address,
        addresses_1.user_id AS addresses_1_user_id
FROM users
    LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id
WHERE users.name = ? ORDER BY addresses_1.id
(<span class="hljs-string">'jack'</span>,)

&gt;&gt;&gt; jack
&lt;User(name=<span class="hljs-string">'jack'</span>, fullname=<span class="hljs-string">'Jack Bean'</span>, password=<span class="hljs-string">'gjffdd'</span>)&gt;

&gt;&gt;&gt; jack.addresses
[&lt;Address(email_address=<span class="hljs-string">'jack@google.com'</span>)&gt;, &lt;Address(email_address=<span class="hljs-string">'j25@yahoo.com'</span>)&gt;]`</pre>

<p>注意到，如果你是在命令行运行了前一个Subquery Loading的例子的话，在这里jack的addresses实际上已经填充了的，但是这里的Joined Load仍然是会发起JOIN。另外，LEFT OUTER JOIN指令实际上有可能导致重复的User出现，但是在结果中实际得到的User却不会重复。这是因为<code>Query</code>实际上是基于Object Identity采用了一种”uniquing”的策略。</p>
<p>历史上来看<code>joinedload()</code>出现的更早一些。<code>joinedloading()</code>更加适合于处理Many-to-one的关系。</p>
<h1 id="显式的Join-EagerLoad"><a href="#显式的Join-EagerLoad" class="headerlink" title="显式的Join + EagerLoad"></a>显式的Join + EagerLoad</h1><p>第三种方式我们是我们自己显式的调用join来定位JOIN连接主键，并接着关联表的信息填充到查询结果中对应对象或者列表中。这个特性需要使用到<code>orm.contains_eager()</code>函数。这个机制最典型的用途是pre-loading many-to-one关系，同时添加对这个关系的筛选。我们用下面的这个例子来阐述说明上面这些比较绕的话。假设我们需要筛选出用户的名字为jack的邮件地址，进行这个查询的方法如下：</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy.orm import contains_eager
&gt;&gt;&gt; jacks_addresses = session.query(Address).\
...                             join(Address.user).\
...                             filter(User.name==<span class="hljs-string">'jack'</span>).\
...                             options(contains_eager(Address.user)).\
...                             all()
SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password,
        addresses.id AS addresses_id,
        addresses.email_address AS addresses_email_address,
        addresses.user_id AS addresses_user_id
FROM addresses JOIN users ON users.id = addresses.user_id
WHERE users.name = ?
(<span class="hljs-string">'jack'</span>,)

&gt;&gt;&gt; jacks_addresses
[&lt;Address(email_address=<span class="hljs-string">'jack@google.com'</span>)&gt;, &lt;Address(email_address=<span class="hljs-string">'j25@yahoo.com'</span>)&gt;]

&gt;&gt;&gt; jacks_addresses[<span class="hljs-number">0</span>].user
&lt;User(name=<span class="hljs-string">'jack'</span>, fullname=<span class="hljs-string">'Jack Bean'</span>, password=<span class="hljs-string">'gjffdd'</span>)&gt;`</pre>

<h2 id="关系中的删除问题"><a href="#关系中的删除问题" class="headerlink" title="关系中的删除问题"></a>关系中的删除问题</h2><p>沃恩尝试删除jack，来看结果：</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.delete(jack)
&gt;&gt;&gt; session.query(User).filter_by(name=<span class="hljs-string">'jack'</span>).count()
UPDATE addresses SET user_id=? WHERE addresses.id = ?
((None, <span class="hljs-number">1</span>), (None, <span class="hljs-number">2</span>))
DELETE FROM users WHERE users.id = ?
(<span class="hljs-number">5</span>,)
SELECT count(*) AS count_1
FROM (SELECT users.id AS users_id,
        users.name AS users_name,
        users.fullname AS users_fullname,
        users.password AS users_password
FROM users
WHERE users.name = ?) AS anon_1
(<span class="hljs-string">'jack'</span>,)
<span class="hljs-number">0</span>`</pre>

<p>那么与jack关联的地址呢？</p>
<pre class="hljs css">`&gt;&gt;&gt; <span class="hljs-tag">session</span><span class="hljs-class">.query</span>(<span class="hljs-tag">Address</span>)<span class="hljs-class">.filter</span>(
...     <span class="hljs-tag">Address</span><span class="hljs-class">.email_address</span><span class="hljs-class">.in_</span>(<span class="hljs-attr_selector">['jack@google.com', 'j25@yahoo.com']</span>)
...  )<span class="hljs-class">.count</span>()
2`</pre>

<p>地址记录仍然在这里。如果我们commit的话，我们可以从上面的SQL语句中发现，相关的<code>Address</code>的<code>user_id</code>属性被设置成了NULL。这不符合我们的要求。那么我们需要自己来设置关系的删除规则。</p>
<h2 id="配置delete-delete-orphan-Cascade"><a href="#配置delete-delete-orphan-Cascade" class="headerlink" title="配置delete/delete-orphan Cascade"></a>配置delete/delete-orphan Cascade</h2><p>我们通过配置<code>User.addresses</code>关系的<strong>cascade*</strong>选项来控制删除行为。尽管SQLAlchemy允许你在任何时候给ORM添加属性或者关系。此时我们还是需要移除现存的关系并且重新开始（作者：django的ORM包含）。让我们首先关闭当前的session</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.close()`</pre>

<p>并且使用一个新的<code>declarative_base()</code>:</p>
<pre class="hljs bash">`&gt;&gt;&gt; Base = declarative_base()`</pre>

<p>下面我们重新声明<code>User</code>类，注意<code>addresses</code>中的配置：</p>
<pre class="hljs bash">`&gt;&gt;&gt; class User(Base):
...     __tablename__ = <span class="hljs-string">'users'</span>
...
...     id = Column(Integer, primary_key=True)
...     name = Column(String)
...     fullname = Column(String)
...     password = Column(String)
...
...     addresses = relationship(<span class="hljs-string">"Address"</span>, back_populates=<span class="hljs-string">'user'</span>,
...                     cascade=<span class="hljs-string">"all, delete, delete-orphan"</span>)
...
...     def __repr__(self):
...        <span class="hljs-built_in">return</span> <span class="hljs-string">"&lt;User(name='%s', fullname='%s', password='%s')&gt;"</span> % (
...                                self.name, self.fullname, self.password)`</pre>

<p>接下来重新声明<code>Address</code>。</p>
<pre class="hljs bash">`&gt;&gt;&gt; class Address(Base):
...     __tablename__ = <span class="hljs-string">'addresses'</span>
...     id = Column(Integer, primary_key=True)
...     email_address = Column(String, nullable=False)
...     user_id = Column(Integer, ForeignKey(<span class="hljs-string">'users.id'</span>))
...     user = relationship(<span class="hljs-string">"User"</span>, back_populates=<span class="hljs-string">"addresses"</span>)
...
...     def __repr__(self):
...         <span class="hljs-built_in">return</span> <span class="hljs-string">"&lt;Address(email_address='%s')&gt;"</span> % self.email_address`</pre>

<p>现在让我们取出jack(下面我们使用了一个之前没有提到的函数<code>get()</code>，其参数为查询目标的主键)，现在从<code>addresses</code>中删除一个地址的话，会导致这个<code>Address</code>被删除。</p>
<pre class="hljs bash">`<span class="hljs-comment"># load Jack by primary key</span>
SQL&gt;&gt;&gt; jack = session.query(User).get(<span class="hljs-number">5</span>)

<span class="hljs-comment"># remove one Address (lazy load fires off)</span>
SQL&gt;&gt;&gt; del jack.addresses[<span class="hljs-number">1</span>]

<span class="hljs-comment"># only one address remains</span>
SQL&gt;&gt;&gt; session.query(Address).filter(
...     Address.email_address.in_([<span class="hljs-string">'jack@google.com'</span>, <span class="hljs-string">'j25@yahoo.com'</span>])
... ).count()
<span class="hljs-number">1</span>`</pre>

<p>删除jack也会导致剩下jack以及其所有的<code>Address</code>都会被删除:</p>
<pre class="hljs bash">`&gt;&gt; session.delete(jack)

SQL&gt;&gt;&gt; session.query(User).filter_by(name=<span class="hljs-string">'jack'</span>).count()
<span class="hljs-number">0</span>

SQL&gt;&gt;&gt; session.query(Address).filter(
...    Address.email_address.in_([<span class="hljs-string">'jack@google.com'</span>, <span class="hljs-string">'j25@yahoo.com'</span>])
... ).count()
<span class="hljs-number">0</span>`</pre>

<p>关于更多的Cascade配置请参见官方文档。</p>
<h2 id="建立多对多关系ManyToMany-Relationship"><a href="#建立多对多关系ManyToMany-Relationship" class="headerlink" title="建立多对多关系ManyToMany Relationship"></a>建立多对多关系ManyToMany Relationship</h2><p>现在我们需要引入一个新的模型来阐述多对多的关系了。假设我们需要完成一个博客应用。在这个应用里面我们可以书写<code>BlogPost</code>，每个博客都有若干<code>Keyword</code>。</p>
<p>对于一个多对多的关系，我们需要建立一个未映射的（也就是没有一个Python类与之对应的）表<code>Table</code>来作为中间联系的表。</p>
<pre class="hljs bash">`&gt;&gt;&gt; from sqlalchemy import Table, Text
&gt;&gt;&gt; <span class="hljs-comment"># association table</span>
&gt;&gt;&gt; post_keywords = Table(<span class="hljs-string">'post_keywords'</span>, Base.metadata,
...     Column(<span class="hljs-string">'post_id'</span>, ForeignKey(<span class="hljs-string">'posts.id'</span>), primary_key=True),
...     Column(<span class="hljs-string">'keyword_id'</span>, ForeignKey(<span class="hljs-string">'keywords.id'</span>), primary_key=True)
... )`</pre>

<p>不同于我们之前的典型的ORM方法，在上面的代码中我们直接声明了一个<code>Table</code>，而没有制定与之对应的Python类。<code>Table</code>是一个构造函数，其参数中的每个<code>Colomn</code>以逗号分隔。</p>
<p>下面我们来定义<code>BlogPost</code>和<code>Keyword</code>。我们这里需要使用<code>relationship()</code>在这两个类中定义一对互补的关系，其中每个关系的都指向<code>post_keyword</code>这个表。</p>
<pre class="hljs bash">`&gt;&gt;&gt; class B<span class="hljs-built_in">log</span>Post(Base):
...     __tablename__ = <span class="hljs-string">'posts'</span>
...
...     id = Column(Integer, primary_key=True)
...     user_id = Column(Integer, ForeignKey(<span class="hljs-string">'users.id'</span>))
...     headline = Column(String(<span class="hljs-number">255</span>), nullable=False)
...     body = Column(Text)
...
...     <span class="hljs-comment"># many to many BlogPost&lt;-&gt;Keyword</span>
...     keywords = relationship(<span class="hljs-string">'Keyword'</span>,
...                             secondary=post_keywords,
...                             back_populates=<span class="hljs-string">'posts'</span>)
...
...     def __init__(self, headline, body, author):
...         self.author = author
...         self.headline = headline
...         self.body = body
...
...     def __repr__(self):
...         <span class="hljs-built_in">return</span> <span class="hljs-string">"BlogPost(%r, %r, %r)"</span> % (self.headline, self.body, self.author)

&gt;&gt;&gt; class Keyword(Base):
...     __tablename__ = <span class="hljs-string">'keywords'</span>
...
...     id = Column(Integer, primary_key=True)
...     keyword = Column(String(<span class="hljs-number">50</span>), nullable=False, unique=True)
...     posts = relationship(<span class="hljs-string">'BlogPost'</span>,
...                          secondary=post_keywords,
...                          back_populates=<span class="hljs-string">'keywords'</span>)
...
...     def __init__(self, keyword):
...         self.keyword = keyword`</pre>

<p>在上面的定义中，我们可以发现和OneToMany关系不同，<code>relationship()</code>中多了一个<code>secondary</code>的参数，这个参数指向了中间表(原文为associated table)。这个中间表只包含了指向多对多关系两侧的表的主键的列。如果这个表包含了其他属性，甚至是自身的主键，SQLAlchemy需要你使用另一种，称为<code>association object</code>的机制来处理。</p>
<p>我们还希望我们的<code>BlogPost</code>能够拥有一个<code>author</code>属性，这个属性指向我们先前定义的<code>User</code>。此时我们需要再定义一个双向关系。由于一个作者可能拥有很多文章，我们希望访问<code>User.posts</code>的时候可以加以筛选而不是载入全部的相关文章。为此我们在定义<code>User.posts</code>中的时候，设置<code>lazy=&#39;dynamic&#39;</code>，来控制载入策略。</p>
<pre class="hljs bash">`&gt;&gt;&gt; B<span class="hljs-built_in">log</span>Post.author = relationship(User, back_populates=<span class="hljs-string">"posts"</span>)
&gt;&gt;&gt; User.posts = relationship(B<span class="hljs-built_in">log</span>Post, back_populates=<span class="hljs-string">"author"</span>, lazy=<span class="hljs-string">"dynamic"</span>)`</pre>

<p>然后让我们来创建数据库中对应的表</p>
<pre class="hljs bash">`&gt;&gt;&gt; Base.metadata.create_all(engine)
PRAGMA...
CREATE TABLE keywords (
    id INTEGER NOT NULL,
    keyword VARCHAR(<span class="hljs-number">50</span>) NOT NULL,
    PRIMARY KEY (id),
    UNIQUE (keyword)
)
()
COMMIT
CREATE TABLE posts (
    id INTEGER NOT NULL,
    user_id INTEGER,
    headline VARCHAR(<span class="hljs-number">255</span>) NOT NULL,
    body TEXT,
    PRIMARY KEY (id),
    FOREIGN KEY(user_id) REFERENCES users (id)
)
()
COMMIT
CREATE TABLE post_keywords (
    post_id INTEGER NOT NULL,
    keyword_id INTEGER NOT NULL,
    PRIMARY KEY (post_id, keyword_id),
    FOREIGN KEY(post_id) REFERENCES posts (id),
    FOREIGN KEY(keyword_id) REFERENCES keywords (id)
)
()
COMMIT`</pre>

<p>多对多关系的使用方法道也没有太大的不同之处。让我们先来给windy添加博文。</p>
<pre class="hljs bash">`&gt;&gt;&gt; wendy = session.query(User).\
...                 filter_by(name=<span class="hljs-string">'wendy'</span>).\
...                 one()
&gt;&gt;&gt; post = B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">"Wendy's Blog Post"</span>, <span class="hljs-string">"This is a test"</span>, wendy)
&gt;&gt;&gt; session.add(post)`</pre>

<p>给博文添加一些关键字。目前数据库里面还没有关键字存在，我们创建一些：</p>
<pre class="hljs bash">`&gt;&gt;&gt; post.keywords.append(Keyword(<span class="hljs-string">'wendy'</span>))
&gt;&gt;&gt; post.keywords.append(Keyword(<span class="hljs-string">'firstpost'</span>))`</pre>

<p>我们可以开始查询了。先以’firstpost’为关键字来检索所有的博文。我们使用<code>any</code>来查询拥有关键词’firstpost’的博文：</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(B<span class="hljs-built_in">log</span>Post).\
...             filter(B<span class="hljs-built_in">log</span>Post.keywords.any(keyword=<span class="hljs-string">'firstpost'</span>)).\
...             all()
[B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">"Wendy's Blog Post"</span>, <span class="hljs-string">'This is a test'</span>, &lt;User(name=<span class="hljs-string">'wendy'</span>, fullname=<span class="hljs-string">'Wendy Williams'</span>, password=<span class="hljs-string">'foobar'</span>)&gt;)]`</pre>

<p>如果我们希望将查询范围限制在wendy用户所拥有的博文之内，</p>
<pre class="hljs bash">`&gt;&gt;&gt; session.query(B<span class="hljs-built_in">log</span>Post).\
...             filter(B<span class="hljs-built_in">log</span>Post.author==wendy).\
...             filter(B<span class="hljs-built_in">log</span>Post.keywords.any(keyword=<span class="hljs-string">'firstpost'</span>)).\
...             all()
SELECT posts.id AS posts_id,
        posts.user_id AS posts_user_id,
        posts.headline AS posts_headline,
        posts.body AS posts_body
FROM posts
WHERE ? = posts.user_id AND (EXISTS (SELECT <span class="hljs-number">1</span>
    FROM post_keywords, keywords
    WHERE posts.id = post_keywords.post_id
        AND keywords.id = post_keywords.keyword_id
        AND keywords.keyword = ?))
(<span class="hljs-number">2</span>, <span class="hljs-string">'firstpost'</span>)
[B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">"Wendy's Blog Post"</span>, <span class="hljs-string">'This is a test'</span>, &lt;User(name=<span class="hljs-string">'wendy'</span>, fullname=<span class="hljs-string">'Wendy Williams'</span>, password=<span class="hljs-string">'foobar'</span>)&gt;)]`</pre>

<p>或者我们可以直接在wendy的<code>posts</code>属性上进行查询：</p>
<p><pre class="hljs bash">`&gt;&gt;&gt; wendy.posts.\<br>…         filter(B<span class="hljs-built_in">log</span>Post.keywords.any(keyword=<span class="hljs-string">‘firstpost’</span>)).\<br>…         all()<br>[B<span class="hljs-built_in">log</span>Post(<span class="hljs-string">“Wendy’s Blog Post”</span>, <span class="hljs-string">‘This is a test’</span>, &lt;User(name=<span class="hljs-string">‘wendy’</span>, fullname=<span class="hljs-string">‘Wendy Williams’</span>, password=<span class="hljs-string">‘foobar’</span>)&gt;)]</pre></p>
</li>
</ul>
<p>&nbsp;</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/11/14/abaqus-e6-a8-a1-e6-8b-9f-e8-9e-ba-e6-a0-93-e8-bf-9e-e6-8e-a5-e7-9a-84-e6-96-b9-e6-b3-95/" class="prev">上一篇</a><a href="/2016/11/05/sqlalchemy-e6-9f-a5-e8-af-a2/" class="next">下一篇</a></div><div class="copyright"><p>© 2013 - 2017 <a href="http://kidozh.com">kido zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>